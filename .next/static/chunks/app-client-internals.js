/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app-client-internals"],{

/***/ "(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5Ccciu-2023-ic%5Cnode_modules%5C.pnpm%5Cnext%4013.1.5_react-dom%4018.2.0%2Breact%4018.2.0%5Cnode_modules%5Cnext%5Cdist%5Cclient%5Ccomponents%5Clayout-router.js&modules=C%3A%5Ccciu-2023-ic%5Cnode_modules%5C.pnpm%5Cnext%4013.1.5_react-dom%4018.2.0%2Breact%4018.2.0%5Cnode_modules%5Cnext%5Cdist%5Cclient%5Ccomponents%5Crender-from-template-context.js&modules=C%3A%5Ccciu-2023-ic%5Cnode_modules%5C.pnpm%5Cnext%4013.1.5_react-dom%4018.2.0%2Breact%4018.2.0%5Cnode_modules%5Cnext%5Cdist%5Cclient%5Ccomponents%5Capp-router.js&modules=C%3A%5Ccciu-2023-ic%5Cnode_modules%5C.pnpm%5Cnext%4013.1.5_react-dom%4018.2.0%2Breact%4018.2.0%5Cnode_modules%5Cnext%5Cdist%5Cclient%5Ccomponents%5Cerror-boundary.js&server=false!":
/*!*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5Ccciu-2023-ic%5Cnode_modules%5C.pnpm%5Cnext%4013.1.5_react-dom%4018.2.0%2Breact%4018.2.0%5Cnode_modules%5Cnext%5Cdist%5Cclient%5Ccomponents%5Clayout-router.js&modules=C%3A%5Ccciu-2023-ic%5Cnode_modules%5C.pnpm%5Cnext%4013.1.5_react-dom%4018.2.0%2Breact%4018.2.0%5Cnode_modules%5Cnext%5Cdist%5Cclient%5Ccomponents%5Crender-from-template-context.js&modules=C%3A%5Ccciu-2023-ic%5Cnode_modules%5C.pnpm%5Cnext%4013.1.5_react-dom%4018.2.0%2Breact%4018.2.0%5Cnode_modules%5Cnext%5Cdist%5Cclient%5Ccomponents%5Capp-router.js&modules=C%3A%5Ccciu-2023-ic%5Cnode_modules%5C.pnpm%5Cnext%4013.1.5_react-dom%4018.2.0%2Breact%4018.2.0%5Cnode_modules%5Cnext%5Cdist%5Cclient%5Ccomponents%5Cerror-boundary.js&server=false! ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/layout-router.js */ \"(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/layout-router.js\", 23));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/render-from-template-context.js */ \"(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/render-from-template-context.js\", 23));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/app-router.js */ \"(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/app-router.js\", 23));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/error-boundary.js */ \"(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/error-boundary.js\", 23))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTMuMS41X3JlYWN0LWRvbUAxOC4yLjArcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz1DJTNBJTVDY2NpdS0yMDIzLWljJTVDbm9kZV9tb2R1bGVzJTVDLnBucG0lNUNuZXh0JTQwMTMuMS41X3JlYWN0LWRvbSU0MDE4LjIuMCUyQnJlYWN0JTQwMTguMi4wJTVDbm9kZV9tb2R1bGVzJTVDbmV4dCU1Q2Rpc3QlNUNjbGllbnQlNUNjb21wb25lbnRzJTVDbGF5b3V0LXJvdXRlci5qcyZtb2R1bGVzPUMlM0ElNUNjY2l1LTIwMjMtaWMlNUNub2RlX21vZHVsZXMlNUMucG5wbSU1Q25leHQlNDAxMy4xLjVfcmVhY3QtZG9tJTQwMTguMi4wJTJCcmVhY3QlNDAxOC4yLjAlNUNub2RlX21vZHVsZXMlNUNuZXh0JTVDZGlzdCU1Q2NsaWVudCU1Q2NvbXBvbmVudHMlNUNyZW5kZXItZnJvbS10ZW1wbGF0ZS1jb250ZXh0LmpzJm1vZHVsZXM9QyUzQSU1Q2NjaXUtMjAyMy1pYyU1Q25vZGVfbW9kdWxlcyU1Qy5wbnBtJTVDbmV4dCU0MDEzLjEuNV9yZWFjdC1kb20lNDAxOC4yLjAlMkJyZWFjdCU0MDE4LjIuMCU1Q25vZGVfbW9kdWxlcyU1Q25leHQlNUNkaXN0JTVDY2xpZW50JTVDY29tcG9uZW50cyU1Q2FwcC1yb3V0ZXIuanMmbW9kdWxlcz1DJTNBJTVDY2NpdS0yMDIzLWljJTVDbm9kZV9tb2R1bGVzJTVDLnBucG0lNUNuZXh0JTQwMTMuMS41X3JlYWN0LWRvbSU0MDE4LjIuMCUyQnJlYWN0JTQwMTguMi4wJTVDbm9kZV9tb2R1bGVzJTVDbmV4dCU1Q2Rpc3QlNUNjbGllbnQlNUNjb21wb25lbnRzJTVDZXJyb3ItYm91bmRhcnkuanMmc2VydmVyPWZhbHNlIS5qcyIsIm1hcHBpbmdzIjoiQUFBQSx5V0FBcUw7QUFDckwsdVlBQW9NO0FBQ3BNLG1XQUFrTDtBQUNsTCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvPzU1OTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCJDOlxcXFxjY2l1LTIwMjMtaWNcXFxcbm9kZV9tb2R1bGVzXFxcXC5wbnBtXFxcXG5leHRAMTMuMS41X3JlYWN0LWRvbUAxOC4yLjArcmVhY3RAMTguMi4wXFxcXG5vZGVfbW9kdWxlc1xcXFxuZXh0XFxcXGRpc3RcXFxcY2xpZW50XFxcXGNvbXBvbmVudHNcXFxcbGF5b3V0LXJvdXRlci5qc1wiKTtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiQzpcXFxcY2NpdS0yMDIzLWljXFxcXG5vZGVfbW9kdWxlc1xcXFwucG5wbVxcXFxuZXh0QDEzLjEuNV9yZWFjdC1kb21AMTguMi4wK3JlYWN0QDE4LjIuMFxcXFxub2RlX21vZHVsZXNcXFxcbmV4dFxcXFxkaXN0XFxcXGNsaWVudFxcXFxjb21wb25lbnRzXFxcXHJlbmRlci1mcm9tLXRlbXBsYXRlLWNvbnRleHQuanNcIik7XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIkM6XFxcXGNjaXUtMjAyMy1pY1xcXFxub2RlX21vZHVsZXNcXFxcLnBucG1cXFxcbmV4dEAxMy4xLjVfcmVhY3QtZG9tQDE4LjIuMCtyZWFjdEAxOC4yLjBcXFxcbm9kZV9tb2R1bGVzXFxcXG5leHRcXFxcZGlzdFxcXFxjbGllbnRcXFxcY29tcG9uZW50c1xcXFxhcHAtcm91dGVyLmpzXCIpO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCJDOlxcXFxjY2l1LTIwMjMtaWNcXFxcbm9kZV9tb2R1bGVzXFxcXC5wbnBtXFxcXG5leHRAMTMuMS41X3JlYWN0LWRvbUAxOC4yLjArcmVhY3RAMTguMi4wXFxcXG5vZGVfbW9kdWxlc1xcXFxuZXh0XFxcXGRpc3RcXFxcY2xpZW50XFxcXGNvbXBvbmVudHNcXFxcZXJyb3ItYm91bmRhcnkuanNcIikiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5Ccciu-2023-ic%5Cnode_modules%5C.pnpm%5Cnext%4013.1.5_react-dom%4018.2.0%2Breact%4018.2.0%5Cnode_modules%5Cnext%5Cdist%5Cclient%5Ccomponents%5Clayout-router.js&modules=C%3A%5Ccciu-2023-ic%5Cnode_modules%5C.pnpm%5Cnext%4013.1.5_react-dom%4018.2.0%2Breact%4018.2.0%5Cnode_modules%5Cnext%5Cdist%5Cclient%5Ccomponents%5Crender-from-template-context.js&modules=C%3A%5Ccciu-2023-ic%5Cnode_modules%5C.pnpm%5Cnext%4013.1.5_react-dom%4018.2.0%2Breact%4018.2.0%5Cnode_modules%5Cnext%5Cdist%5Cclient%5Ccomponents%5Capp-router.js&modules=C%3A%5Ccciu-2023-ic%5Cnode_modules%5C.pnpm%5Cnext%4013.1.5_react-dom%4018.2.0%2Breact%4018.2.0%5Cnode_modules%5Cnext%5Cdist%5Cclient%5Ccomponents%5Cerror-boundary.js&server=false!\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/app-router-headers.js":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/app-router-headers.js ***!
  \*************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.FLIGHT_PARAMETERS = exports.RSC_VARY_HEADER = exports.FETCH_CACHE_HEADER = exports.NEXT_ROUTER_PREFETCH = exports.NEXT_ROUTER_STATE_TREE = exports.RSC = void 0;\nconst RSC = \"RSC\";\nexports.RSC = RSC;\nconst NEXT_ROUTER_STATE_TREE = \"Next-Router-State-Tree\";\nexports.NEXT_ROUTER_STATE_TREE = NEXT_ROUTER_STATE_TREE;\nconst NEXT_ROUTER_PREFETCH = \"Next-Router-Prefetch\";\nexports.NEXT_ROUTER_PREFETCH = NEXT_ROUTER_PREFETCH;\nconst FETCH_CACHE_HEADER = \"x-vercel-sc-headers\";\nexports.FETCH_CACHE_HEADER = FETCH_CACHE_HEADER;\nconst RSC_VARY_HEADER = \"\".concat(RSC, \", \").concat(NEXT_ROUTER_STATE_TREE, \", \").concat(NEXT_ROUTER_PREFETCH);\nexports.RSC_VARY_HEADER = RSC_VARY_HEADER;\nconst FLIGHT_PARAMETERS = [\n    [\n        RSC\n    ],\n    [\n        NEXT_ROUTER_STATE_TREE\n    ],\n    [\n        NEXT_ROUTER_PREFETCH\n    ]\n];\nexports.FLIGHT_PARAMETERS = FLIGHT_PARAMETERS;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-router-headers.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTMuMS41X3JlYWN0LWRvbUAxOC4yLjArcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvYXBwLXJvdXRlci1oZWFkZXJzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELHlCQUF5QixHQUFHQSx1QkFBdUIsR0FBR0EsMEJBQTBCLEdBQUdBLDRCQUE0QixHQUFHQSw4QkFBOEIsR0FBR0EsV0FBVyxHQUFHLEtBQUs7QUFDdEssTUFBTU8sTUFBTTtBQUNaUCxXQUFXLEdBQUdPO0FBQ2QsTUFBTUQseUJBQXlCO0FBQy9CTiw4QkFBOEIsR0FBR007QUFDakMsTUFBTUQsdUJBQXVCO0FBQzdCTCw0QkFBNEIsR0FBR0s7QUFDL0IsTUFBTUQscUJBQXFCO0FBQzNCSiwwQkFBMEIsR0FBR0k7QUFDN0IsTUFBTUQsa0JBQWtCLEdBQVdHLE9BQVJDLEtBQUksTUFBK0JGLE9BQTNCQyx3QkFBdUIsTUFBeUIsT0FBckJEO0FBQzlETCx1QkFBdUIsR0FBR0c7QUFDMUIsTUFBTUQsb0JBQW9CO0lBQ3RCO1FBQ0lLO0tBQ0g7SUFDRDtRQUNJRDtLQUNIO0lBQ0Q7UUFDSUQ7S0FDSDtDQUNKO0FBQ0RMLHlCQUF5QixHQUFHRTtBQUU1QixJQUFJLENBQUMsT0FBT0YsUUFBUVEsT0FBTyxLQUFLLGNBQWUsT0FBT1IsUUFBUVEsT0FBTyxLQUFLLFlBQVlSLFFBQVFRLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT1IsUUFBUVEsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS1gsT0FBT0MsY0FBYyxDQUFDQyxRQUFRUSxPQUFPLEVBQUUsY0FBYztRQUFFUCxPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT1ksTUFBTSxDQUFDVixRQUFRUSxPQUFPLEVBQUVSO0lBQy9CVyxPQUFPWCxPQUFPLEdBQUdBLFFBQVFRLE9BQU87QUFDbEMsQ0FBQyxDQUVELDhDQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxMy4xLjVfcmVhY3QtZG9tQDE4LjIuMCtyZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9hcHAtcm91dGVyLWhlYWRlcnMuanM/NGY4MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuRkxJR0hUX1BBUkFNRVRFUlMgPSBleHBvcnRzLlJTQ19WQVJZX0hFQURFUiA9IGV4cG9ydHMuRkVUQ0hfQ0FDSEVfSEVBREVSID0gZXhwb3J0cy5ORVhUX1JPVVRFUl9QUkVGRVRDSCA9IGV4cG9ydHMuTkVYVF9ST1VURVJfU1RBVEVfVFJFRSA9IGV4cG9ydHMuUlNDID0gdm9pZCAwO1xuY29uc3QgUlNDID0gJ1JTQyc7XG5leHBvcnRzLlJTQyA9IFJTQztcbmNvbnN0IE5FWFRfUk9VVEVSX1NUQVRFX1RSRUUgPSAnTmV4dC1Sb3V0ZXItU3RhdGUtVHJlZSc7XG5leHBvcnRzLk5FWFRfUk9VVEVSX1NUQVRFX1RSRUUgPSBORVhUX1JPVVRFUl9TVEFURV9UUkVFO1xuY29uc3QgTkVYVF9ST1VURVJfUFJFRkVUQ0ggPSAnTmV4dC1Sb3V0ZXItUHJlZmV0Y2gnO1xuZXhwb3J0cy5ORVhUX1JPVVRFUl9QUkVGRVRDSCA9IE5FWFRfUk9VVEVSX1BSRUZFVENIO1xuY29uc3QgRkVUQ0hfQ0FDSEVfSEVBREVSID0gJ3gtdmVyY2VsLXNjLWhlYWRlcnMnO1xuZXhwb3J0cy5GRVRDSF9DQUNIRV9IRUFERVIgPSBGRVRDSF9DQUNIRV9IRUFERVI7XG5jb25zdCBSU0NfVkFSWV9IRUFERVIgPSBgJHtSU0N9LCAke05FWFRfUk9VVEVSX1NUQVRFX1RSRUV9LCAke05FWFRfUk9VVEVSX1BSRUZFVENIfWA7XG5leHBvcnRzLlJTQ19WQVJZX0hFQURFUiA9IFJTQ19WQVJZX0hFQURFUjtcbmNvbnN0IEZMSUdIVF9QQVJBTUVURVJTID0gW1xuICAgIFtcbiAgICAgICAgUlNDXG4gICAgXSxcbiAgICBbXG4gICAgICAgIE5FWFRfUk9VVEVSX1NUQVRFX1RSRUVcbiAgICBdLFxuICAgIFtcbiAgICAgICAgTkVYVF9ST1VURVJfUFJFRkVUQ0hcbiAgICBdLCBcbl07XG5leHBvcnRzLkZMSUdIVF9QQVJBTUVURVJTID0gRkxJR0hUX1BBUkFNRVRFUlM7XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcC1yb3V0ZXItaGVhZGVycy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJGTElHSFRfUEFSQU1FVEVSUyIsIlJTQ19WQVJZX0hFQURFUiIsIkZFVENIX0NBQ0hFX0hFQURFUiIsIk5FWFRfUk9VVEVSX1BSRUZFVENIIiwiTkVYVF9ST1VURVJfU1RBVEVfVFJFRSIsIlJTQyIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/app-router-headers.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/app-router.js":
/*!*****************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/app-router.js ***!
  \*****************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = AppRouter;\nexports.fetchServerResponse = fetchServerResponse;\nvar _async_to_generator = (__webpack_require__(/*! @swc/helpers/lib/_async_to_generator.js */ \"(app-client)/./node_modules/.pnpm/@swc+helpers@0.4.14/node_modules/@swc/helpers/lib/_async_to_generator.js\")[\"default\"]);\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"(app-client)/./node_modules/.pnpm/@swc+helpers@0.4.14/node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar _object_without_properties_loose = (__webpack_require__(/*! @swc/helpers/lib/_object_without_properties_loose.js */ \"(app-client)/./node_modules/.pnpm/@swc+helpers@0.4.14/node_modules/@swc/helpers/lib/_object_without_properties_loose.js\")[\"default\"]);\nvar _react = _interop_require_wildcard(__webpack_require__(/*! react */ \"(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/compiled/react/index.js\"));\nvar _client = __webpack_require__(/*! next/dist/compiled/react-server-dom-webpack/client */ \"(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/compiled/react-server-dom-webpack/client.js\");\nvar _appRouterContext = __webpack_require__(/*! ../../shared/lib/app-router-context */ \"(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/shared/lib/app-router-context.js\");\nvar _reducer = __webpack_require__(/*! ./reducer */ \"(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/reducer.js\");\nvar _hooksClientContext = __webpack_require__(/*! ../../shared/lib/hooks-client-context */ \"(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/shared/lib/hooks-client-context.js\");\nvar _useReducerWithDevtools = __webpack_require__(/*! ./use-reducer-with-devtools */ \"(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/use-reducer-with-devtools.js\");\nvar _errorBoundary = __webpack_require__(/*! ./error-boundary */ \"(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/error-boundary.js\");\nvar _appRouterHeaders = __webpack_require__(/*! ./app-router-headers */ \"(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/app-router-headers.js\");\nfunction AppRouter(props) {\n    const { globalErrorComponent  } = props, rest = _object_without_properties_loose(props, [\n        \"globalErrorComponent\"\n    ]);\n    return /*#__PURE__*/ _react.default.createElement(_errorBoundary.ErrorBoundary, {\n        errorComponent: globalErrorComponent\n    }, /*#__PURE__*/ _react.default.createElement(Router, Object.assign({}, rest)));\n}\n_c = AppRouter;\nfunction urlToUrlWithoutFlightMarker(url) {\n    const urlWithoutFlightParameters = new URL(url, location.origin);\n    // TODO-APP: handle .rsc for static export case\n    return urlWithoutFlightParameters;\n}\nconst HotReloader =  false ? 0 : (__webpack_require__(/*! ./react-dev-overlay/hot-reloader-client */ \"(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/react-dev-overlay/hot-reloader-client.js\")[\"default\"]);\nfunction fetchServerResponse(url, flightRouterState, prefetch) {\n    return _fetchServerResponse.apply(this, arguments);\n}\nfunction _fetchServerResponse() {\n    _fetchServerResponse = _async_to_generator(function*(url, flightRouterState, prefetch) {\n        const headers = {\n            // Enable flight response\n            [_appRouterHeaders.RSC]: \"1\",\n            // Provide the current router state\n            [_appRouterHeaders.NEXT_ROUTER_STATE_TREE]: JSON.stringify(flightRouterState)\n        };\n        if (prefetch) {\n            // Enable prefetch response\n            headers[_appRouterHeaders.NEXT_ROUTER_PREFETCH] = \"1\";\n        }\n        const res = yield fetch(url.toString(), {\n            headers\n        });\n        const canonicalUrl = res.redirected ? urlToUrlWithoutFlightMarker(res.url) : undefined;\n        const isFlightResponse = res.headers.get(\"content-type\") === \"application/octet-stream\";\n        // If fetch returns something different than flight response handle it like a mpa navigation\n        if (!isFlightResponse) {\n            return [\n                res.url,\n                undefined\n            ];\n        }\n        // Handle the `fetch` readable stream that can be unwrapped by `React.use`.\n        const flightData = yield (0, _client).createFromFetch(Promise.resolve(res));\n        return [\n            flightData,\n            canonicalUrl\n        ];\n    });\n    return _fetchServerResponse.apply(this, arguments);\n}\n// Ensure the initialParallelRoutes are not combined because of double-rendering in the browser with Strict Mode.\nlet initialParallelRoutes =  false ? 0 : new Map();\nconst prefetched = new Set();\nfunction findHeadInCache(cache, parallelRoutes) {\n    const isLastItem = Object.keys(parallelRoutes).length === 0;\n    if (isLastItem) {\n        return cache.head;\n    }\n    for(const key in parallelRoutes){\n        const [segment, childParallelRoutes] = parallelRoutes[key];\n        const childSegmentMap = cache.parallelRoutes.get(key);\n        if (!childSegmentMap) {\n            continue;\n        }\n        const cacheKey = Array.isArray(segment) ? segment[1] : segment;\n        const cacheNode = childSegmentMap.get(cacheKey);\n        if (!cacheNode) {\n            continue;\n        }\n        const item = findHeadInCache(cacheNode, childParallelRoutes);\n        if (item) {\n            return item;\n        }\n    }\n    return undefined;\n}\n/**\n * The global router that wraps the application components.\n */ function Router(param) {\n    let { initialHead , initialTree , initialCanonicalUrl , children , assetPrefix  } = param;\n    _s();\n    const initialState = (0, _react).useMemo(()=>{\n        return {\n            tree: initialTree,\n            cache: {\n                status: _appRouterContext.CacheStates.READY,\n                data: null,\n                subTreeData: children,\n                parallelRoutes:  false ? 0 : initialParallelRoutes\n            },\n            prefetchCache: new Map(),\n            pushRef: {\n                pendingPush: false,\n                mpaNavigation: false\n            },\n            focusAndScrollRef: {\n                apply: false\n            },\n            canonicalUrl: // This is safe to do as canonicalUrl can't be rendered, it's only used to control the history updates in the useEffect further down in this file.\n             true ? (0, _reducer).createHrefFromUrl(window.location) : 0\n        };\n    }, [\n        children,\n        initialCanonicalUrl,\n        initialTree\n    ]);\n    const [{ tree , cache , prefetchCache , pushRef , focusAndScrollRef , canonicalUrl  }, dispatch, sync] = (0, _useReducerWithDevtools).useReducerWithReduxDevtools(_reducer.reducer, initialState);\n    const head = (0, _react).useMemo(()=>{\n        return findHeadInCache(cache, tree[1]);\n    }, [\n        cache,\n        tree\n    ]);\n    (0, _react).useEffect(()=>{\n        // Ensure initialParallelRoutes is cleaned up from memory once it's used.\n        initialParallelRoutes = null;\n    }, []);\n    // Add memoized pathname/query for useSearchParams and usePathname.\n    const { searchParams , pathname  } = (0, _react).useMemo(()=>{\n        const url = new URL(canonicalUrl,  false ? 0 : window.location.href);\n        return {\n            // This is turned into a readonly class in `useSearchParams`\n            searchParams: url.searchParams,\n            pathname: url.pathname\n        };\n    }, [\n        canonicalUrl\n    ]);\n    /**\n   * Server response that only patches the cache and tree.\n   */ const changeByServerResponse = (0, _react).useCallback((previousTree, flightData, overrideCanonicalUrl)=>{\n        dispatch({\n            type: _reducer.ACTION_SERVER_PATCH,\n            flightData,\n            previousTree,\n            overrideCanonicalUrl,\n            cache: {\n                status: _appRouterContext.CacheStates.LAZY_INITIALIZED,\n                data: null,\n                subTreeData: null,\n                parallelRoutes: new Map()\n            },\n            mutable: {}\n        });\n    }, [\n        dispatch\n    ]);\n    /**\n   * The app router that is exposed through `useRouter`. It's only concerned with dispatching actions to the reducer, does not hold state.\n   */ const appRouter = (0, _react).useMemo(()=>{\n        const navigate = (href, navigateType, forceOptimisticNavigation)=>{\n            return dispatch({\n                type: _reducer.ACTION_NAVIGATE,\n                url: new URL(href, location.origin),\n                forceOptimisticNavigation,\n                navigateType,\n                cache: {\n                    status: _appRouterContext.CacheStates.LAZY_INITIALIZED,\n                    data: null,\n                    subTreeData: null,\n                    parallelRoutes: new Map()\n                },\n                mutable: {}\n            });\n        };\n        const routerInstance = {\n            back: ()=>window.history.back(),\n            forward: ()=>window.history.forward(),\n            prefetch: _async_to_generator(function*(href) {\n                // If prefetch has already been triggered, don't trigger it again.\n                if (prefetched.has(href)) {\n                    return;\n                }\n                prefetched.add(href);\n                const url = new URL(href, location.origin);\n                try {\n                    var ref;\n                    const routerTree = ((ref = window.history.state) == null ? void 0 : ref.tree) || initialTree;\n                    const serverResponse = yield fetchServerResponse(url, routerTree, true);\n                    // @ts-ignore startTransition exists\n                    _react.default.startTransition(()=>{\n                        dispatch({\n                            type: _reducer.ACTION_PREFETCH,\n                            url,\n                            tree: routerTree,\n                            serverResponse\n                        });\n                    });\n                } catch (err) {\n                    console.error(\"PREFETCH ERROR\", err);\n                }\n            }),\n            replace: function(href) {\n                let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                // @ts-ignore startTransition exists\n                _react.default.startTransition(()=>{\n                    navigate(href, \"replace\", Boolean(options.forceOptimisticNavigation));\n                });\n            },\n            push: function(href) {\n                let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                // @ts-ignore startTransition exists\n                _react.default.startTransition(()=>{\n                    navigate(href, \"push\", Boolean(options.forceOptimisticNavigation));\n                });\n            },\n            refresh: ()=>{\n                // @ts-ignore startTransition exists\n                _react.default.startTransition(()=>{\n                    dispatch({\n                        type: _reducer.ACTION_REFRESH,\n                        cache: {\n                            status: _appRouterContext.CacheStates.LAZY_INITIALIZED,\n                            data: null,\n                            subTreeData: null,\n                            parallelRoutes: new Map()\n                        },\n                        mutable: {}\n                    });\n                });\n            }\n        };\n        return routerInstance;\n    }, [\n        dispatch,\n        initialTree\n    ]);\n    (0, _react).useEffect(()=>{\n        // When mpaNavigation flag is set do a hard navigation to the new url.\n        if (pushRef.mpaNavigation) {\n            window.location.href = canonicalUrl;\n            return;\n        }\n        // Identifier is shortened intentionally.\n        // __NA is used to identify if the history entry can be handled by the app-router.\n        // __N is used to identify if the history entry can be handled by the old router.\n        const historyState = {\n            __NA: true,\n            tree\n        };\n        if (pushRef.pendingPush && (0, _reducer).createHrefFromUrl(new URL(window.location.href)) !== canonicalUrl) {\n            // This intentionally mutates React state, pushRef is overwritten to ensure additional push/replace calls do not trigger an additional history entry.\n            pushRef.pendingPush = false;\n            window.history.pushState(historyState, \"\", canonicalUrl);\n        } else {\n            window.history.replaceState(historyState, \"\", canonicalUrl);\n        }\n        sync();\n    }, [\n        tree,\n        pushRef,\n        canonicalUrl,\n        sync\n    ]);\n    // Add `window.nd` for debugging purposes.\n    // This is not meant for use in applications as concurrent rendering will affect the cache/tree/router.\n    if (true) {\n        // @ts-ignore this is for debugging\n        window.nd = {\n            router: appRouter,\n            cache,\n            prefetchCache,\n            tree\n        };\n    }\n    /**\n   * Handle popstate event, this is used to handle back/forward in the browser.\n   * By default dispatches ACTION_RESTORE, however if the history entry was not pushed/replaced by app-router it will reload the page.\n   * That case can happen when the old router injected the history entry.\n   */ const onPopState = (0, _react).useCallback((param)=>{\n        let { state  } = param;\n        if (!state) {\n            // TODO-APP: this case only happens when pushState/replaceState was called outside of Next.js. It should probably reload the page in this case.\n            return;\n        }\n        // This case happens when the history entry was pushed by the `pages` router.\n        if (!state.__NA) {\n            window.location.reload();\n            return;\n        }\n        // @ts-ignore useTransition exists\n        // TODO-APP: Ideally the back button should not use startTransition as it should apply the updates synchronously\n        // Without startTransition works if the cache is there for this path\n        _react.default.startTransition(()=>{\n            dispatch({\n                type: _reducer.ACTION_RESTORE,\n                url: new URL(window.location.href),\n                tree: state.tree\n            });\n        });\n    }, [\n        dispatch\n    ]);\n    // Register popstate event to call onPopstate.\n    (0, _react).useEffect(()=>{\n        window.addEventListener(\"popstate\", onPopState);\n        return ()=>{\n            window.removeEventListener(\"popstate\", onPopState);\n        };\n    }, [\n        onPopState\n    ]);\n    const content = /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, head || initialHead, cache.subTreeData);\n    return /*#__PURE__*/ _react.default.createElement(_hooksClientContext.PathnameContext.Provider, {\n        value: pathname\n    }, /*#__PURE__*/ _react.default.createElement(_hooksClientContext.SearchParamsContext.Provider, {\n        value: searchParams\n    }, /*#__PURE__*/ _react.default.createElement(_appRouterContext.GlobalLayoutRouterContext.Provider, {\n        value: {\n            changeByServerResponse,\n            tree,\n            focusAndScrollRef\n        }\n    }, /*#__PURE__*/ _react.default.createElement(_appRouterContext.AppRouterContext.Provider, {\n        value: appRouter\n    }, /*#__PURE__*/ _react.default.createElement(_appRouterContext.LayoutRouterContext.Provider, {\n        value: {\n            childNodes: cache.parallelRoutes,\n            tree: tree,\n            // Root node always has `url`\n            // Provided in AppTreeContext to ensure it can be overwritten in layout-router\n            url: canonicalUrl\n        }\n    }, HotReloader ? /*#__PURE__*/ _react.default.createElement(HotReloader, {\n        assetPrefix: assetPrefix\n    }, content) : content)))));\n}\n_s(Router, \"E4Qd1Kk83CxC+YgSLfkcNAcoSWY=\");\n_c1 = Router;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-router.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"AppRouter\");\n$RefreshReg$(_c1, \"Router\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTMuMS41X3JlYWN0LWRvbUAxOC4yLjArcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvYXBwLXJvdXRlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFDYTs7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsa0JBQWUsR0FBR0c7QUFDbEJILDJCQUEyQixHQUFHSTtBQUM5QixJQUFJQyxzQkFBc0JDLDZMQUEwRDtBQUNwRixJQUFJQyw0QkFBNEJELHlNQUFnRTtBQUNoRyxJQUFJRSxtQ0FBbUNGLHVOQUF1RTtBQUM5RyxJQUFJRyxTQUFTRiwwQkFBMEJELG1CQUFPQSxDQUFDLHlJQUFPO0FBQ3RELElBQUlJLFVBQVVKLG1CQUFPQSxDQUFDLDBNQUFvRDtBQUMxRSxJQUFJSyxvQkFBb0JMLG1CQUFPQSxDQUFDLGdMQUFxQztBQUNyRSxJQUFJTSxXQUFXTixtQkFBT0EsQ0FBQyxrSkFBVztBQUNsQyxJQUFJTyxzQkFBc0JQLG1CQUFPQSxDQUFDLG9MQUF1QztBQUN6RSxJQUFJUSwwQkFBMEJSLG1CQUFPQSxDQUFDLHNMQUE2QjtBQUNuRSxJQUFJUyxpQkFBaUJULG1CQUFPQSxDQUFDLGdLQUFrQjtBQUMvQyxJQUFJVSxvQkFBb0JWLG1CQUFPQSxDQUFDLHdLQUFzQjtBQUN0RCxTQUFTSCxVQUFVYyxLQUFLLEVBQUU7SUFDdEIsTUFBTSxFQUFFQyxxQkFBb0IsRUFBRyxHQUFHRCxPQUFPRSxPQUFPWCxpQ0FBaUNTLE9BQU87UUFDcEY7S0FDSDtJQUNELE9BQU8sV0FBVyxHQUFHUixPQUFPUCxPQUFPLENBQUNrQixhQUFhLENBQUNMLGVBQWVNLGFBQWEsRUFBRTtRQUM1RUMsZ0JBQWdCSjtJQUNwQixHQUFHLFdBQVcsR0FBR1QsT0FBT1AsT0FBTyxDQUFDa0IsYUFBYSxDQUFDRyxRQUFRekIsT0FBTzBCLE1BQU0s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LGNBQWM7UUFBRUQsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU8wQixNQUFNLENBQUN4QixRQUFRRSxPQUFPLEVBQUVGO0lBQy9CK0osT0FBTy9KLE9BQU8sR0FBR0EsUUFBUUUsT0FBTztBQUNsQyxDQUFDLENBRUQsc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDEzLjEuNV9yZWFjdC1kb21AMTguMi4wK3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2FwcC1yb3V0ZXIuanM/ZGJmNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gQXBwUm91dGVyO1xuZXhwb3J0cy5mZXRjaFNlcnZlclJlc3BvbnNlID0gZmV0Y2hTZXJ2ZXJSZXNwb25zZTtcbnZhciBfYXN5bmNfdG9fZ2VuZXJhdG9yID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2FzeW5jX3RvX2dlbmVyYXRvci5qc1wiKS5kZWZhdWx0O1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLmpzXCIpLmRlZmF1bHQ7XG52YXIgX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2UgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9fb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZS5qc1wiKS5kZWZhdWx0O1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfY2xpZW50ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2svY2xpZW50XCIpO1xudmFyIF9hcHBSb3V0ZXJDb250ZXh0ID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0XCIpO1xudmFyIF9yZWR1Y2VyID0gcmVxdWlyZShcIi4vcmVkdWNlclwiKTtcbnZhciBfaG9va3NDbGllbnRDb250ZXh0ID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9saWIvaG9va3MtY2xpZW50LWNvbnRleHRcIik7XG52YXIgX3VzZVJlZHVjZXJXaXRoRGV2dG9vbHMgPSByZXF1aXJlKFwiLi91c2UtcmVkdWNlci13aXRoLWRldnRvb2xzXCIpO1xudmFyIF9lcnJvckJvdW5kYXJ5ID0gcmVxdWlyZShcIi4vZXJyb3ItYm91bmRhcnlcIik7XG52YXIgX2FwcFJvdXRlckhlYWRlcnMgPSByZXF1aXJlKFwiLi9hcHAtcm91dGVyLWhlYWRlcnNcIik7XG5mdW5jdGlvbiBBcHBSb3V0ZXIocHJvcHMpIHtcbiAgICBjb25zdCB7IGdsb2JhbEVycm9yQ29tcG9uZW50ICB9ID0gcHJvcHMsIHJlc3QgPSBfb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZShwcm9wcywgW1xuICAgICAgICBcImdsb2JhbEVycm9yQ29tcG9uZW50XCJcbiAgICBdKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9lcnJvckJvdW5kYXJ5LkVycm9yQm91bmRhcnksIHtcbiAgICAgICAgZXJyb3JDb21wb25lbnQ6IGdsb2JhbEVycm9yQ29tcG9uZW50XG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJvdXRlciwgT2JqZWN0LmFzc2lnbih7fSwgcmVzdCkpKTtcbn1cblxuZnVuY3Rpb24gdXJsVG9VcmxXaXRob3V0RmxpZ2h0TWFya2VyKHVybCkge1xuICAgIGNvbnN0IHVybFdpdGhvdXRGbGlnaHRQYXJhbWV0ZXJzID0gbmV3IFVSTCh1cmwsIGxvY2F0aW9uLm9yaWdpbik7XG4gICAgLy8gVE9ETy1BUFA6IGhhbmRsZSAucnNjIGZvciBzdGF0aWMgZXhwb3J0IGNhc2VcbiAgICByZXR1cm4gdXJsV2l0aG91dEZsaWdodFBhcmFtZXRlcnM7XG59XG5jb25zdCBIb3RSZWxvYWRlciA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgPyBudWxsIDogcmVxdWlyZSgnLi9yZWFjdC1kZXYtb3ZlcmxheS9ob3QtcmVsb2FkZXItY2xpZW50JykuZGVmYXVsdDtcbmZ1bmN0aW9uIGZldGNoU2VydmVyUmVzcG9uc2UodXJsLCBmbGlnaHRSb3V0ZXJTdGF0ZSwgcHJlZmV0Y2gpIHtcbiAgICByZXR1cm4gX2ZldGNoU2VydmVyUmVzcG9uc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF9mZXRjaFNlcnZlclJlc3BvbnNlKCkge1xuICAgIF9mZXRjaFNlcnZlclJlc3BvbnNlID0gX2FzeW5jX3RvX2dlbmVyYXRvcihmdW5jdGlvbioodXJsLCBmbGlnaHRSb3V0ZXJTdGF0ZSwgcHJlZmV0Y2gpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgIC8vIEVuYWJsZSBmbGlnaHQgcmVzcG9uc2VcbiAgICAgICAgICAgIFtfYXBwUm91dGVySGVhZGVycy5SU0NdOiAnMScsXG4gICAgICAgICAgICAvLyBQcm92aWRlIHRoZSBjdXJyZW50IHJvdXRlciBzdGF0ZVxuICAgICAgICAgICAgW19hcHBSb3V0ZXJIZWFkZXJzLk5FWFRfUk9VVEVSX1NUQVRFX1RSRUVdOiBKU09OLnN0cmluZ2lmeShmbGlnaHRSb3V0ZXJTdGF0ZSlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHByZWZldGNoKSB7XG4gICAgICAgICAgICAvLyBFbmFibGUgcHJlZmV0Y2ggcmVzcG9uc2VcbiAgICAgICAgICAgIGhlYWRlcnNbX2FwcFJvdXRlckhlYWRlcnMuTkVYVF9ST1VURVJfUFJFRkVUQ0hdID0gJzEnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcyA9IHlpZWxkIGZldGNoKHVybC50b1N0cmluZygpLCB7XG4gICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjYW5vbmljYWxVcmwgPSByZXMucmVkaXJlY3RlZCA/IHVybFRvVXJsV2l0aG91dEZsaWdodE1hcmtlcihyZXMudXJsKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgaXNGbGlnaHRSZXNwb25zZSA9IHJlcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykgPT09ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nO1xuICAgICAgICAvLyBJZiBmZXRjaCByZXR1cm5zIHNvbWV0aGluZyBkaWZmZXJlbnQgdGhhbiBmbGlnaHQgcmVzcG9uc2UgaGFuZGxlIGl0IGxpa2UgYSBtcGEgbmF2aWdhdGlvblxuICAgICAgICBpZiAoIWlzRmxpZ2h0UmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgcmVzLnVybCxcbiAgICAgICAgICAgICAgICB1bmRlZmluZWRcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIHRoZSBgZmV0Y2hgIHJlYWRhYmxlIHN0cmVhbSB0aGF0IGNhbiBiZSB1bndyYXBwZWQgYnkgYFJlYWN0LnVzZWAuXG4gICAgICAgIGNvbnN0IGZsaWdodERhdGEgPSB5aWVsZCAoMCwgX2NsaWVudCkuY3JlYXRlRnJvbUZldGNoKFByb21pc2UucmVzb2x2ZShyZXMpKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGZsaWdodERhdGEsXG4gICAgICAgICAgICBjYW5vbmljYWxVcmxcbiAgICAgICAgXTtcbiAgICB9KTtcbiAgICByZXR1cm4gX2ZldGNoU2VydmVyUmVzcG9uc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbi8vIEVuc3VyZSB0aGUgaW5pdGlhbFBhcmFsbGVsUm91dGVzIGFyZSBub3QgY29tYmluZWQgYmVjYXVzZSBvZiBkb3VibGUtcmVuZGVyaW5nIGluIHRoZSBicm93c2VyIHdpdGggU3RyaWN0IE1vZGUuXG5sZXQgaW5pdGlhbFBhcmFsbGVsUm91dGVzID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogbmV3IE1hcCgpO1xuY29uc3QgcHJlZmV0Y2hlZCA9IG5ldyBTZXQoKTtcbmZ1bmN0aW9uIGZpbmRIZWFkSW5DYWNoZShjYWNoZSwgcGFyYWxsZWxSb3V0ZXMpIHtcbiAgICBjb25zdCBpc0xhc3RJdGVtID0gT2JqZWN0LmtleXMocGFyYWxsZWxSb3V0ZXMpLmxlbmd0aCA9PT0gMDtcbiAgICBpZiAoaXNMYXN0SXRlbSkge1xuICAgICAgICByZXR1cm4gY2FjaGUuaGVhZDtcbiAgICB9XG4gICAgZm9yKGNvbnN0IGtleSBpbiBwYXJhbGxlbFJvdXRlcyl7XG4gICAgICAgIGNvbnN0IFtzZWdtZW50LCBjaGlsZFBhcmFsbGVsUm91dGVzXSA9IHBhcmFsbGVsUm91dGVzW2tleV07XG4gICAgICAgIGNvbnN0IGNoaWxkU2VnbWVudE1hcCA9IGNhY2hlLnBhcmFsbGVsUm91dGVzLmdldChrZXkpO1xuICAgICAgICBpZiAoIWNoaWxkU2VnbWVudE1hcCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBBcnJheS5pc0FycmF5KHNlZ21lbnQpID8gc2VnbWVudFsxXSA6IHNlZ21lbnQ7XG4gICAgICAgIGNvbnN0IGNhY2hlTm9kZSA9IGNoaWxkU2VnbWVudE1hcC5nZXQoY2FjaGVLZXkpO1xuICAgICAgICBpZiAoIWNhY2hlTm9kZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXRlbSA9IGZpbmRIZWFkSW5DYWNoZShjYWNoZU5vZGUsIGNoaWxkUGFyYWxsZWxSb3V0ZXMpO1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8qKlxuICogVGhlIGdsb2JhbCByb3V0ZXIgdGhhdCB3cmFwcyB0aGUgYXBwbGljYXRpb24gY29tcG9uZW50cy5cbiAqLyBmdW5jdGlvbiBSb3V0ZXIoeyBpbml0aWFsSGVhZCAsIGluaXRpYWxUcmVlICwgaW5pdGlhbENhbm9uaWNhbFVybCAsIGNoaWxkcmVuICwgYXNzZXRQcmVmaXggIH0pIHtcbiAgICBjb25zdCBpbml0aWFsU3RhdGUgPSAoMCwgX3JlYWN0KS51c2VNZW1vKCgpPT57XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0cmVlOiBpbml0aWFsVHJlZSxcbiAgICAgICAgICAgIGNhY2hlOiB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5SRUFEWSxcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIHN1YlRyZWVEYXRhOiBjaGlsZHJlbixcbiAgICAgICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBuZXcgTWFwKCkgOiBpbml0aWFsUGFyYWxsZWxSb3V0ZXNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmVmZXRjaENhY2hlOiBuZXcgTWFwKCksXG4gICAgICAgICAgICBwdXNoUmVmOiB7XG4gICAgICAgICAgICAgICAgcGVuZGluZ1B1c2g6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1wYU5hdmlnYXRpb246IGZhbHNlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWY6IHtcbiAgICAgICAgICAgICAgICBhcHBseTogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYW5vbmljYWxVcmw6IC8vIGxvY2F0aW9uLmhyZWYgaXMgcmVhZCBhcyB0aGUgaW5pdGlhbCB2YWx1ZSBmb3IgY2Fub25pY2FsVXJsIGluIHRoZSBicm93c2VyXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHNhZmUgdG8gZG8gYXMgY2Fub25pY2FsVXJsIGNhbid0IGJlIHJlbmRlcmVkLCBpdCdzIG9ubHkgdXNlZCB0byBjb250cm9sIHRoZSBoaXN0b3J5IHVwZGF0ZXMgaW4gdGhlIHVzZUVmZmVjdCBmdXJ0aGVyIGRvd24gaW4gdGhpcyBmaWxlLlxuICAgICAgICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyAoMCwgX3JlZHVjZXIpLmNyZWF0ZUhyZWZGcm9tVXJsKHdpbmRvdy5sb2NhdGlvbikgOiBpbml0aWFsQ2Fub25pY2FsVXJsXG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgaW5pdGlhbENhbm9uaWNhbFVybCxcbiAgICAgICAgaW5pdGlhbFRyZWVcbiAgICBdKTtcbiAgICBjb25zdCBbeyB0cmVlICwgY2FjaGUgLCBwcmVmZXRjaENhY2hlICwgcHVzaFJlZiAsIGZvY3VzQW5kU2Nyb2xsUmVmICwgY2Fub25pY2FsVXJsICB9LCBkaXNwYXRjaCwgc3luYywgXSA9ICgwLCBfdXNlUmVkdWNlcldpdGhEZXZ0b29scykudXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzKF9yZWR1Y2VyLnJlZHVjZXIsIGluaXRpYWxTdGF0ZSk7XG4gICAgY29uc3QgaGVhZCA9ICgwLCBfcmVhY3QpLnVzZU1lbW8oKCk9PntcbiAgICAgICAgcmV0dXJuIGZpbmRIZWFkSW5DYWNoZShjYWNoZSwgdHJlZVsxXSk7XG4gICAgfSwgW1xuICAgICAgICBjYWNoZSxcbiAgICAgICAgdHJlZVxuICAgIF0pO1xuICAgICgwLCBfcmVhY3QpLnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICAvLyBFbnN1cmUgaW5pdGlhbFBhcmFsbGVsUm91dGVzIGlzIGNsZWFuZWQgdXAgZnJvbSBtZW1vcnkgb25jZSBpdCdzIHVzZWQuXG4gICAgICAgIGluaXRpYWxQYXJhbGxlbFJvdXRlcyA9IG51bGw7XG4gICAgfSwgW10pO1xuICAgIC8vIEFkZCBtZW1vaXplZCBwYXRobmFtZS9xdWVyeSBmb3IgdXNlU2VhcmNoUGFyYW1zIGFuZCB1c2VQYXRobmFtZS5cbiAgICBjb25zdCB7IHNlYXJjaFBhcmFtcyAsIHBhdGhuYW1lICB9ID0gKDAsIF9yZWFjdCkudXNlTWVtbygoKT0+e1xuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGNhbm9uaWNhbFVybCwgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyAnaHR0cDovL24nIDogd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0dXJuZWQgaW50byBhIHJlYWRvbmx5IGNsYXNzIGluIGB1c2VTZWFyY2hQYXJhbXNgXG4gICAgICAgICAgICBzZWFyY2hQYXJhbXM6IHVybC5zZWFyY2hQYXJhbXMsXG4gICAgICAgICAgICBwYXRobmFtZTogdXJsLnBhdGhuYW1lXG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBjYW5vbmljYWxVcmxcbiAgICBdKTtcbiAgICAvKipcbiAgICogU2VydmVyIHJlc3BvbnNlIHRoYXQgb25seSBwYXRjaGVzIHRoZSBjYWNoZSBhbmQgdHJlZS5cbiAgICovIGNvbnN0IGNoYW5nZUJ5U2VydmVyUmVzcG9uc2UgPSAoMCwgX3JlYWN0KS51c2VDYWxsYmFjaygocHJldmlvdXNUcmVlLCBmbGlnaHREYXRhLCBvdmVycmlkZUNhbm9uaWNhbFVybCk9PntcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogX3JlZHVjZXIuQUNUSU9OX1NFUlZFUl9QQVRDSCxcbiAgICAgICAgICAgIGZsaWdodERhdGEsXG4gICAgICAgICAgICBwcmV2aW91c1RyZWUsXG4gICAgICAgICAgICBvdmVycmlkZUNhbm9uaWNhbFVybCxcbiAgICAgICAgICAgIGNhY2hlOiB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5MQVpZX0lOSVRJQUxJWkVELFxuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgc3ViVHJlZURhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG11dGFibGU6IHt9XG4gICAgICAgIH0pO1xuICAgIH0sIFtcbiAgICAgICAgZGlzcGF0Y2hcbiAgICBdKTtcbiAgICAvKipcbiAgICogVGhlIGFwcCByb3V0ZXIgdGhhdCBpcyBleHBvc2VkIHRocm91Z2ggYHVzZVJvdXRlcmAuIEl0J3Mgb25seSBjb25jZXJuZWQgd2l0aCBkaXNwYXRjaGluZyBhY3Rpb25zIHRvIHRoZSByZWR1Y2VyLCBkb2VzIG5vdCBob2xkIHN0YXRlLlxuICAgKi8gY29uc3QgYXBwUm91dGVyID0gKDAsIF9yZWFjdCkudXNlTWVtbygoKT0+e1xuICAgICAgICBjb25zdCBuYXZpZ2F0ZSA9IChocmVmLCBuYXZpZ2F0ZVR5cGUsIGZvcmNlT3B0aW1pc3RpY05hdmlnYXRpb24pPT57XG4gICAgICAgICAgICByZXR1cm4gZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IF9yZWR1Y2VyLkFDVElPTl9OQVZJR0FURSxcbiAgICAgICAgICAgICAgICB1cmw6IG5ldyBVUkwoaHJlZiwgbG9jYXRpb24ub3JpZ2luKSxcbiAgICAgICAgICAgICAgICBmb3JjZU9wdGltaXN0aWNOYXZpZ2F0aW9uLFxuICAgICAgICAgICAgICAgIG5hdmlnYXRlVHlwZSxcbiAgICAgICAgICAgICAgICBjYWNoZToge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLkxBWllfSU5JVElBTElaRUQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHN1YlRyZWVEYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcCgpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtdXRhYmxlOiB7fVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJvdXRlckluc3RhbmNlID0ge1xuICAgICAgICAgICAgYmFjazogKCk9PndpbmRvdy5oaXN0b3J5LmJhY2soKSxcbiAgICAgICAgICAgIGZvcndhcmQ6ICgpPT53aW5kb3cuaGlzdG9yeS5mb3J3YXJkKCksXG4gICAgICAgICAgICBwcmVmZXRjaDogX2FzeW5jX3RvX2dlbmVyYXRvcihmdW5jdGlvbiooaHJlZikge1xuICAgICAgICAgICAgICAgIC8vIElmIHByZWZldGNoIGhhcyBhbHJlYWR5IGJlZW4gdHJpZ2dlcmVkLCBkb24ndCB0cmlnZ2VyIGl0IGFnYWluLlxuICAgICAgICAgICAgICAgIGlmIChwcmVmZXRjaGVkLmhhcyhocmVmKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZWZldGNoZWQuYWRkKGhyZWYpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoaHJlZiwgbG9jYXRpb24ub3JpZ2luKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByb3V0ZXJUcmVlID0gKChyZWYgPSB3aW5kb3cuaGlzdG9yeS5zdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IHJlZi50cmVlKSB8fCBpbml0aWFsVHJlZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VydmVyUmVzcG9uc2UgPSB5aWVsZCBmZXRjaFNlcnZlclJlc3BvbnNlKHVybCwgLy8gaW5pdGlhbFRyZWUgaXMgdXNlZCB3aGVuIGhpc3Rvcnkuc3RhdGUudHJlZSBpcyBtaXNzaW5nIGJlY2F1c2UgdGhlIGhpc3Rvcnkgc3RhdGUgaXMgc2V0IGluIGB1c2VFZmZlY3RgIGJlbG93LCBpdCBiZWluZyBtaXNzaW5nIG1lYW5zIHRoaXMgaXMgdGhlIGh5ZHJhdGlvbiBjYXNlLlxuICAgICAgICAgICAgICAgICAgICByb3V0ZXJUcmVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBzdGFydFRyYW5zaXRpb24gZXhpc3RzXG4gICAgICAgICAgICAgICAgICAgIF9yZWFjdC5kZWZhdWx0LnN0YXJ0VHJhbnNpdGlvbigoKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IF9yZWR1Y2VyLkFDVElPTl9QUkVGRVRDSCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJlZTogcm91dGVyVHJlZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJSZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdQUkVGRVRDSCBFUlJPUicsIGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICByZXBsYWNlOiAoaHJlZiwgb3B0aW9ucyA9IHt9KT0+e1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgc3RhcnRUcmFuc2l0aW9uIGV4aXN0c1xuICAgICAgICAgICAgICAgIF9yZWFjdC5kZWZhdWx0LnN0YXJ0VHJhbnNpdGlvbigoKT0+e1xuICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZShocmVmLCAncmVwbGFjZScsIEJvb2xlYW4ob3B0aW9ucy5mb3JjZU9wdGltaXN0aWNOYXZpZ2F0aW9uKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHVzaDogKGhyZWYsIG9wdGlvbnMgPSB7fSk9PntcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIHN0YXJ0VHJhbnNpdGlvbiBleGlzdHNcbiAgICAgICAgICAgICAgICBfcmVhY3QuZGVmYXVsdC5zdGFydFRyYW5zaXRpb24oKCk9PntcbiAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGUoaHJlZiwgJ3B1c2gnLCBCb29sZWFuKG9wdGlvbnMuZm9yY2VPcHRpbWlzdGljTmF2aWdhdGlvbikpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlZnJlc2g6ICgpPT57XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBzdGFydFRyYW5zaXRpb24gZXhpc3RzXG4gICAgICAgICAgICAgICAgX3JlYWN0LmRlZmF1bHQuc3RhcnRUcmFuc2l0aW9uKCgpPT57XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IF9yZWR1Y2VyLkFDVElPTl9SRUZSRVNILFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLkxBWllfSU5JVElBTElaRUQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJUcmVlRGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcCgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YWJsZToge31cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByb3V0ZXJJbnN0YW5jZTtcbiAgICB9LCBbXG4gICAgICAgIGRpc3BhdGNoLFxuICAgICAgICBpbml0aWFsVHJlZVxuICAgIF0pO1xuICAgICgwLCBfcmVhY3QpLnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICAvLyBXaGVuIG1wYU5hdmlnYXRpb24gZmxhZyBpcyBzZXQgZG8gYSBoYXJkIG5hdmlnYXRpb24gdG8gdGhlIG5ldyB1cmwuXG4gICAgICAgIGlmIChwdXNoUmVmLm1wYU5hdmlnYXRpb24pIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gY2Fub25pY2FsVXJsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElkZW50aWZpZXIgaXMgc2hvcnRlbmVkIGludGVudGlvbmFsbHkuXG4gICAgICAgIC8vIF9fTkEgaXMgdXNlZCB0byBpZGVudGlmeSBpZiB0aGUgaGlzdG9yeSBlbnRyeSBjYW4gYmUgaGFuZGxlZCBieSB0aGUgYXBwLXJvdXRlci5cbiAgICAgICAgLy8gX19OIGlzIHVzZWQgdG8gaWRlbnRpZnkgaWYgdGhlIGhpc3RvcnkgZW50cnkgY2FuIGJlIGhhbmRsZWQgYnkgdGhlIG9sZCByb3V0ZXIuXG4gICAgICAgIGNvbnN0IGhpc3RvcnlTdGF0ZSA9IHtcbiAgICAgICAgICAgIF9fTkE6IHRydWUsXG4gICAgICAgICAgICB0cmVlXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwdXNoUmVmLnBlbmRpbmdQdXNoICYmICgwLCBfcmVkdWNlcikuY3JlYXRlSHJlZkZyb21VcmwobmV3IFVSTCh3aW5kb3cubG9jYXRpb24uaHJlZikpICE9PSBjYW5vbmljYWxVcmwpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaW50ZW50aW9uYWxseSBtdXRhdGVzIFJlYWN0IHN0YXRlLCBwdXNoUmVmIGlzIG92ZXJ3cml0dGVuIHRvIGVuc3VyZSBhZGRpdGlvbmFsIHB1c2gvcmVwbGFjZSBjYWxscyBkbyBub3QgdHJpZ2dlciBhbiBhZGRpdGlvbmFsIGhpc3RvcnkgZW50cnkuXG4gICAgICAgICAgICBwdXNoUmVmLnBlbmRpbmdQdXNoID0gZmFsc2U7XG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoaGlzdG9yeVN0YXRlLCAnJywgY2Fub25pY2FsVXJsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShoaXN0b3J5U3RhdGUsICcnLCBjYW5vbmljYWxVcmwpO1xuICAgICAgICB9XG4gICAgICAgIHN5bmMoKTtcbiAgICB9LCBbXG4gICAgICAgIHRyZWUsXG4gICAgICAgIHB1c2hSZWYsXG4gICAgICAgIGNhbm9uaWNhbFVybCxcbiAgICAgICAgc3luY1xuICAgIF0pO1xuICAgIC8vIEFkZCBgd2luZG93Lm5kYCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxuICAgIC8vIFRoaXMgaXMgbm90IG1lYW50IGZvciB1c2UgaW4gYXBwbGljYXRpb25zIGFzIGNvbmN1cnJlbnQgcmVuZGVyaW5nIHdpbGwgYWZmZWN0IHRoZSBjYWNoZS90cmVlL3JvdXRlci5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZSB0aGlzIGlzIGZvciBkZWJ1Z2dpbmdcbiAgICAgICAgd2luZG93Lm5kID0ge1xuICAgICAgICAgICAgcm91dGVyOiBhcHBSb3V0ZXIsXG4gICAgICAgICAgICBjYWNoZSxcbiAgICAgICAgICAgIHByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICB0cmVlXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgKiBIYW5kbGUgcG9wc3RhdGUgZXZlbnQsIHRoaXMgaXMgdXNlZCB0byBoYW5kbGUgYmFjay9mb3J3YXJkIGluIHRoZSBicm93c2VyLlxuICAgKiBCeSBkZWZhdWx0IGRpc3BhdGNoZXMgQUNUSU9OX1JFU1RPUkUsIGhvd2V2ZXIgaWYgdGhlIGhpc3RvcnkgZW50cnkgd2FzIG5vdCBwdXNoZWQvcmVwbGFjZWQgYnkgYXBwLXJvdXRlciBpdCB3aWxsIHJlbG9hZCB0aGUgcGFnZS5cbiAgICogVGhhdCBjYXNlIGNhbiBoYXBwZW4gd2hlbiB0aGUgb2xkIHJvdXRlciBpbmplY3RlZCB0aGUgaGlzdG9yeSBlbnRyeS5cbiAgICovIGNvbnN0IG9uUG9wU3RhdGUgPSAoMCwgX3JlYWN0KS51c2VDYWxsYmFjaygoeyBzdGF0ZSAgfSk9PntcbiAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgLy8gVE9ETy1BUFA6IHRoaXMgY2FzZSBvbmx5IGhhcHBlbnMgd2hlbiBwdXNoU3RhdGUvcmVwbGFjZVN0YXRlIHdhcyBjYWxsZWQgb3V0c2lkZSBvZiBOZXh0LmpzLiBJdCBzaG91bGQgcHJvYmFibHkgcmVsb2FkIHRoZSBwYWdlIGluIHRoaXMgY2FzZS5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIGNhc2UgaGFwcGVucyB3aGVuIHRoZSBoaXN0b3J5IGVudHJ5IHdhcyBwdXNoZWQgYnkgdGhlIGBwYWdlc2Agcm91dGVyLlxuICAgICAgICBpZiAoIXN0YXRlLl9fTkEpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBAdHMtaWdub3JlIHVzZVRyYW5zaXRpb24gZXhpc3RzXG4gICAgICAgIC8vIFRPRE8tQVBQOiBJZGVhbGx5IHRoZSBiYWNrIGJ1dHRvbiBzaG91bGQgbm90IHVzZSBzdGFydFRyYW5zaXRpb24gYXMgaXQgc2hvdWxkIGFwcGx5IHRoZSB1cGRhdGVzIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gV2l0aG91dCBzdGFydFRyYW5zaXRpb24gd29ya3MgaWYgdGhlIGNhY2hlIGlzIHRoZXJlIGZvciB0aGlzIHBhdGhcbiAgICAgICAgX3JlYWN0LmRlZmF1bHQuc3RhcnRUcmFuc2l0aW9uKCgpPT57XG4gICAgICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogX3JlZHVjZXIuQUNUSU9OX1JFU1RPUkUsXG4gICAgICAgICAgICAgICAgdXJsOiBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKSxcbiAgICAgICAgICAgICAgICB0cmVlOiBzdGF0ZS50cmVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSwgW1xuICAgICAgICBkaXNwYXRjaFxuICAgIF0pO1xuICAgIC8vIFJlZ2lzdGVyIHBvcHN0YXRlIGV2ZW50IHRvIGNhbGwgb25Qb3BzdGF0ZS5cbiAgICAoMCwgX3JlYWN0KS51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgb25Qb3BTdGF0ZSk7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgb25Qb3BTdGF0ZSk7XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBvblBvcFN0YXRlXG4gICAgXSk7XG4gICAgY29uc3QgY29udGVudCA9IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgaGVhZCB8fCBpbml0aWFsSGVhZCwgY2FjaGUuc3ViVHJlZURhdGEpO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2hvb2tzQ2xpZW50Q29udGV4dC5QYXRobmFtZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHBhdGhuYW1lXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9ob29rc0NsaWVudENvbnRleHQuU2VhcmNoUGFyYW1zQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogc2VhcmNoUGFyYW1zXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9hcHBSb3V0ZXJDb250ZXh0Lkdsb2JhbExheW91dFJvdXRlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIGNoYW5nZUJ5U2VydmVyUmVzcG9uc2UsXG4gICAgICAgICAgICB0cmVlLFxuICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWZcbiAgICAgICAgfVxuICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfYXBwUm91dGVyQ29udGV4dC5BcHBSb3V0ZXJDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBhcHBSb3V0ZXJcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2FwcFJvdXRlckNvbnRleHQuTGF5b3V0Um91dGVyQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgY2hpbGROb2RlczogY2FjaGUucGFyYWxsZWxSb3V0ZXMsXG4gICAgICAgICAgICB0cmVlOiB0cmVlLFxuICAgICAgICAgICAgLy8gUm9vdCBub2RlIGFsd2F5cyBoYXMgYHVybGBcbiAgICAgICAgICAgIC8vIFByb3ZpZGVkIGluIEFwcFRyZWVDb250ZXh0IHRvIGVuc3VyZSBpdCBjYW4gYmUgb3ZlcndyaXR0ZW4gaW4gbGF5b3V0LXJvdXRlclxuICAgICAgICAgICAgdXJsOiBjYW5vbmljYWxVcmxcbiAgICAgICAgfVxuICAgIH0sIEhvdFJlbG9hZGVyID8gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEhvdFJlbG9hZGVyLCB7XG4gICAgICAgIGFzc2V0UHJlZml4OiBhc3NldFByZWZpeFxuICAgIH0sIGNvbnRlbnQpIDogY29udGVudCkpKSkpO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHAtcm91dGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlZmF1bHQiLCJBcHBSb3V0ZXIiLCJmZXRjaFNlcnZlclJlc3BvbnNlIiwiX2FzeW5jX3RvX2dlbmVyYXRvciIsInJlcXVpcmUiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwiX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2UiLCJfcmVhY3QiLCJfY2xpZW50IiwiX2FwcFJvdXRlckNvbnRleHQiLCJfcmVkdWNlciIsIl9ob29rc0NsaWVudENvbnRleHQiLCJfdXNlUmVkdWNlcldpdGhEZXZ0b29scyIsIl9lcnJvckJvdW5kYXJ5IiwiX2FwcFJvdXRlckhlYWRlcnMiLCJwcm9wcyIsImdsb2JhbEVycm9yQ29tcG9uZW50IiwicmVzdCIsImNyZWF0ZUVsZW1lbnQiLCJFcnJvckJvdW5kYXJ5IiwiZXJyb3JDb21wb25lbnQiLCJSb3V0ZXIiLCJhc3NpZ24iLCJ1cmxUb1VybFdpdGhvdXRGbGlnaHRNYXJrZXIiLCJ1cmwiLCJ1cmxXaXRob3V0RmxpZ2h0UGFyYW1ldGVycyIsIlVSTCIsImxvY2F0aW9uIiwib3JpZ2luIiwiSG90UmVsb2FkZXIiLCJwcm9jZXNzIiwiZmxpZ2h0Um91dGVyU3RhdGUiLCJwcmVmZXRjaCIsIl9mZXRjaFNlcnZlclJlc3BvbnNlIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJoZWFkZXJzIiwiUlNDIiwiTkVYVF9ST1VURVJfU1RBVEVfVFJFRSIsIkpTT04iLCJzdHJpbmdpZnkiLCJORVhUX1JPVVRFUl9QUkVGRVRDSCIsInJlcyIsImZldGNoIiwidG9TdHJpbmciLCJjYW5vbmljYWxVcmwiLCJyZWRpcmVjdGVkIiwidW5kZWZpbmVkIiwiaXNGbGlnaHRSZXNwb25zZSIsImdldCIsImZsaWdodERhdGEiLCJjcmVhdGVGcm9tRmV0Y2giLCJQcm9taXNlIiwicmVzb2x2ZSIsImluaXRpYWxQYXJhbGxlbFJvdXRlcyIsIk1hcCIsInByZWZldGNoZWQiLCJTZXQiLCJmaW5kSGVhZEluQ2FjaGUiLCJjYWNoZSIsInBhcmFsbGVsUm91dGVzIiwiaXNMYXN0SXRlbSIsImtleXMiLCJsZW5ndGgiLCJoZWFkIiwia2V5Iiwic2VnbWVudCIsImNoaWxkUGFyYWxsZWxSb3V0ZXMiLCJjaGlsZFNlZ21lbnRNYXAiLCJjYWNoZUtleSIsIkFycmF5IiwiaXNBcnJheSIsImNhY2hlTm9kZSIsIml0ZW0iLCJpbml0aWFsSGVhZCIsImluaXRpYWxUcmVlIiwiaW5pdGlhbENhbm9uaWNhbFVybCIsImNoaWxkcmVuIiwiYXNzZXRQcmVmaXgiLCJpbml0aWFsU3RhdGUiLCJ1c2VNZW1vIiwidHJlZSIsInN0YXR1cyIsIkNhY2hlU3RhdGVzIiwiUkVBRFkiLCJkYXRhIiwic3ViVHJlZURhdGEiLCJwcmVmZXRjaENhY2hlIiwicHVzaFJlZiIsInBlbmRpbmdQdXNoIiwibXBhTmF2aWdhdGlvbiIsImZvY3VzQW5kU2Nyb2xsUmVmIiwiY3JlYXRlSHJlZkZyb21VcmwiLCJ3aW5kb3ciLCJkaXNwYXRjaCIsInN5bmMiLCJ1c2VSZWR1Y2VyV2l0aFJlZHV4RGV2dG9vbHMiLCJyZWR1Y2VyIiwidXNlRWZmZWN0Iiwic2VhcmNoUGFyYW1zIiwicGF0aG5hbWUiLCJocmVmIiwiY2hhbmdlQnlTZXJ2ZXJSZXNwb25zZSIsInVzZUNhbGxiYWNrIiwicHJldmlvdXNUcmVlIiwib3ZlcnJpZGVDYW5vbmljYWxVcmwiLCJ0eXBlIiwiQUNUSU9OX1NFUlZFUl9QQVRDSCIsIkxBWllfSU5JVElBTElaRUQiLCJtdXRhYmxlIiwiYXBwUm91dGVyIiwibmF2aWdhdGUiLCJuYXZpZ2F0ZVR5cGUiLCJmb3JjZU9wdGltaXN0aWNOYXZpZ2F0aW9uIiwiQUNUSU9OX05BVklHQVRFIiwicm91dGVySW5zdGFuY2UiLCJiYWNrIiwiaGlzdG9yeSIsImZvcndhcmQiLCJoYXMiLCJhZGQiLCJyZWYiLCJyb3V0ZXJUcmVlIiwic3RhdGUiLCJzZXJ2ZXJSZXNwb25zZSIsInN0YXJ0VHJhbnNpdGlvbiIsIkFDVElPTl9QUkVGRVRDSCIsImVyciIsImNvbnNvbGUiLCJlcnJvciIsInJlcGxhY2UiLCJvcHRpb25zIiwiQm9vbGVhbiIsInB1c2giLCJyZWZyZXNoIiwiQUNUSU9OX1JFRlJFU0giLCJoaXN0b3J5U3RhdGUiLCJfX05BIiwicHVzaFN0YXRlIiwicmVwbGFjZVN0YXRlIiwibmQiLCJyb3V0ZXIiLCJvblBvcFN0YXRlIiwicmVsb2FkIiwiQUNUSU9OX1JFU1RPUkUiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNvbnRlbnQiLCJGcmFnbWVudCIsIlBhdGhuYW1lQ29udGV4dCIsIlByb3ZpZGVyIiwiU2VhcmNoUGFyYW1zQ29udGV4dCIsIkdsb2JhbExheW91dFJvdXRlckNvbnRleHQiLCJBcHBSb3V0ZXJDb250ZXh0IiwiTGF5b3V0Um91dGVyQ29udGV4dCIsImNoaWxkTm9kZXMiLCJfX2VzTW9kdWxlIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/app-router.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/error-boundary.js":
/*!*********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/error-boundary.js ***!
  \*********************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = GlobalError;\nexports.ErrorBoundary = ErrorBoundary;\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"(app-client)/./node_modules/.pnpm/@swc+helpers@0.4.14/node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/compiled/react/index.js\"));\nfunction GlobalError(param) {\n    let { error  } = param;\n    return /*#__PURE__*/ _react.default.createElement(\"html\", null, /*#__PURE__*/ _react.default.createElement(\"head\", null), /*#__PURE__*/ _react.default.createElement(\"body\", null, /*#__PURE__*/ _react.default.createElement(\"div\", {\n        style: styles.error\n    }, /*#__PURE__*/ _react.default.createElement(\"div\", {\n        style: styles.desc\n    }, /*#__PURE__*/ _react.default.createElement(\"h2\", {\n        style: styles.text\n    }, \"Application error: a client-side exception has occurred (see the browser console for more information).\"), (error == null ? void 0 : error.digest) && /*#__PURE__*/ _react.default.createElement(\"p\", {\n        style: styles.text\n    }, \"Digest: \".concat(error.digest))))));\n}\n_c = GlobalError;\nconst styles = {\n    error: {\n        fontFamily: '-apple-system, BlinkMacSystemFont, Roboto, \"Segoe UI\", \"Fira Sans\", Avenir, \"Helvetica Neue\", \"Lucida Grande\", sans-serif',\n        height: \"100vh\",\n        textAlign: \"center\",\n        display: \"flex\",\n        flexDirection: \"column\",\n        alignItems: \"center\",\n        justifyContent: \"center\"\n    },\n    desc: {\n        display: \"inline-block\",\n        textAlign: \"left\",\n        lineHeight: \"49px\",\n        height: \"49px\",\n        verticalAlign: \"middle\"\n    },\n    text: {\n        fontSize: \"14px\",\n        fontWeight: \"normal\",\n        lineHeight: \"49px\",\n        margin: 0,\n        padding: 0\n    }\n};\nclass ErrorBoundaryHandler extends _react.default.Component {\n    static getDerivedStateFromError(error) {\n        return {\n            error\n        };\n    }\n    render() {\n        if (this.state.error) {\n            return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, this.props.errorStyles, /*#__PURE__*/ _react.default.createElement(this.props.errorComponent, {\n                error: this.state.error,\n                reset: this.reset\n            }));\n        }\n        return this.props.children;\n    }\n    constructor(props){\n        super(props);\n        this.reset = ()=>{\n            this.setState({\n                error: null\n            });\n        };\n        this.state = {\n            error: null\n        };\n    }\n}\nexports.ErrorBoundaryHandler = ErrorBoundaryHandler;\nfunction ErrorBoundary(param) {\n    let { errorComponent , errorStyles , children  } = param;\n    if (errorComponent) {\n        return /*#__PURE__*/ _react.default.createElement(ErrorBoundaryHandler, {\n            errorComponent: errorComponent,\n            errorStyles: errorStyles\n        }, children);\n    }\n    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, children);\n}\n_c1 = ErrorBoundary;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=error-boundary.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"GlobalError\");\n$RefreshReg$(_c1, \"ErrorBoundary\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTMuMS41X3JlYWN0LWRvbUAxOC4yLjArcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvZXJyb3ItYm91bmRhcnkuanMuanMiLCJtYXBwaW5ncyI6IkFBQ2E7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsa0JBQWUsR0FBR0c7QUFDbEJILHFCQUFxQixHQUFHSTtBQUN4QixJQUFJQywyQkFBMkJDLHVNQUErRDtBQUM5RixJQUFJQyxTQUFTRix5QkFBeUJDLG1CQUFPQSxDQUFDLHlJQUFPO0FBQ3JELFNBQVNILFlBQVksS0FBVSxFQUFFO1FBQVosRUFBRUssTUFBSyxFQUFHLEdBQVY7SUFDakIsT0FBTyxXQUFXLEdBQUdELE9BQU9MLE9BQU8sQ0FBQ08sYUFBYSxDQUFDLFFBQVEsSUFBSSxFQUFFLFdBQVcsR0FBR0YsT0FBT0wsT0FBTyxDQUFDTyxhQUFhLENBQUMsUUFBUSxJQUFJLEdBQUcsV0FBVyxHQUFHRixPQUFPTCxPQUFPLENBQUNPLGFBQWEsQ0FBQyxRQUFRLElBQUksRUFBRSxXQUFXLEdBQUdGLE9BQU9MLE9BQU8sQ0FBQ08sYUFBYSxDQUFDLE9BQU87UUFDak9DLE9BQU9DLE9BQU9ILEtBQUs7SUFDdkIsR0FBRyxXQUFXLEdBQUdELE9BQU9MLE9BQU8sQ0FBQ08sYUFBYSxDQUFDLE9BQU87UUFDakRDLE9BQU9DLE9BQU9DLElBQUk7SUFDdEIsR0FBRyxXQUFXLEdBQUdMLE9BQU9MLE9BQU8sQ0FBQ08sYUFBYSxDQUFDLE1BQU07UUFDaERDLE9BQU9DLE9BQU9FLElBQUk7SUFDdEIsR0FBRyw0R0FBNEcsQ0FBQ0wsU0FBUyxJQUFJLEdBQUcsS0FBSyxJQUFJQSxNQUFNTSxNQUFNLEtBQUssV0FBVyxHQUFHUCxPQUFPTCxPQUFPLENBQUNPLGFBQWEsQ0FBQyxLQUFLO1FBQ3RNQyxPQUFPQyxPQUFPRSxJQUFJO0lBQ3RCLEdBQUcsV0FBd0IsT0FBYkwsTUFBTU0sTUFBTTtBQUM5QjtLQVZTWDtBQVlULE1BQU1RLFNBQVM7SUFDWEgsT0FBTztRQUNITyxZQUFZO1FBQ1pDLFFBQVE7UUFDUkMsV0FBVztRQUNYQyxTQUFTO1FBQ1RDLGVBQWU7UUFDZkMsWUFBWTtRQUNaQyxnQkFBZ0I7SUFDcEI7SUFDQVQsTUFBTTtRQUNGTSxTQUFTO1FBQ1RELFdBQVc7UUFDWEssWUFBWTtRQUNaTixRQUFRO1FBQ1JPLGVBQWU7SUFDbkI7SUFDQVYsTUFBTTtRQUNGVyxVQUFVO1FBQ1ZDLFlBQVk7UUFDWkgsWUFBWTtRQUNaSSxRQUFRO1FBQ1JDLFNBQVM7SUFDYjtBQUNKO0FBQ0EsTUFBTUMsNkJBQTZCckIsT0FBT0wsT0FBTyxDQUFDMkIsU0FBUztJQUN2RCxPQUFPQyx5QkFBeUJ0QixLQUFLLEVBQUU7UUFDbkMsT0FBTztZQUNIQTtRQUNKO0lBQ0o7SUFDQXVCLFNBQVM7UUFDTCxJQUFJLElBQUksQ0FBQ0MsS0FBSyxDQUFDeEIsS0FBSyxFQUFFO1lBQ2xCLE9BQU8sV0FBVyxHQUFHRCxPQUFPTCxPQUFPLENBQUNPLGFBQWEsQ0FBQ0YsT0FBT0wsT0FBTyxDQUFDK0IsUUFBUSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUNDLEtBQUssQ0FBQ0MsV0FBVyxFQUFFLFdBQVcsR0FBRzVCLE9BQU9MLE9BQU8sQ0FBQ08sYUFBYSxDQUFDLElBQUksQ0FBQ3lCLEtBQUssQ0FBQ0UsY0FBYyxFQUFFO2dCQUMzSzVCLE9BQU8sSUFBSSxDQUFDd0IsS0FBSyxDQUFDeEIsS0FBSztnQkFDdkI2QixPQUFPLElBQUksQ0FBQ0EsS0FBSztZQUNyQjtRQUNKLENBQUM7UUFDRCxPQUFPLElBQUksQ0FBQ0gsS0FBSyxDQUFDSSxRQUFRO0lBQzlCO0lBQ0FDLFlBQVlMLEtBQUssQ0FBQztRQUNkLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNHLEtBQUssR0FBRyxJQUFJO1lBQ2IsSUFBSSxDQUFDRyxRQUFRLENBQUM7Z0JBQ1ZoQyxPQUFPLElBQUk7WUFDZjtRQUNKO1FBQ0EsSUFBSSxDQUFDd0IsS0FBSyxHQUFHO1lBQ1R4QixPQUFPLElBQUk7UUFDZjtJQUNKO0FBQ0o7QUFDQVIsNEJBQTRCLEdBQUc0QjtBQUMvQixTQUFTeEIsY0FBYyxLQUE0QyxFQUFFO1FBQTlDLEVBQUVnQyxlQUFjLEVBQUdELFlBQVcsRUFBR0csU0FBUSxFQUFHLEdBQTVDO0lBQ25CLElBQUlGLGdCQUFnQjtRQUNoQixPQUFPLFdBQVcsR0FBRzdCLE9BQU9MLE9BQU8sQ0FBQ08sYUFBYSxDQUFDbUIsc0JBQXNCO1lBQ3BFUSxnQkFBZ0JBO1lBQ2hCRCxhQUFhQTtRQUNqQixHQUFHRztJQUNQLENBQUM7SUFDRCxPQUFPLFdBQVcsR0FBRy9CLE9BQU9MLE9BQU8sQ0FBQ08sYUFBYSxDQUFDRixPQUFPTCxPQUFPLENBQUMrQixRQUFRLEVBQUUsSUFBSSxFQUFFSztBQUNyRjtNQVJTbEM7QUFVVCxJQUFJLENBQUMsT0FBT0osUUFBUUUsT0FBTyxLQUFLLGNBQWUsT0FBT0YsUUFBUUUsT0FBTyxLQUFLLFlBQVlGLFFBQVFFLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT0YsUUFBUUUsT0FBTyxDQUFDdUMsVUFBVSxLQUFLLGFBQWE7SUFDckszQyxPQUFPQyxjQUFjLENBQUNDLFFBQVFFLE9BQU8sRUFBRSxjQUFjO1FBQUVELE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPNEMsTUFBTSxDQUFDMUMsUUFBUUUsT0FBTyxFQUFFRjtJQUMvQjJDLE9BQU8zQyxPQUFPLEdBQUdBLFFBQVFFLE9BQU87QUFDbEMsQ0FBQyxDQUVELDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxMy4xLjVfcmVhY3QtZG9tQDE4LjIuMCtyZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9lcnJvci1ib3VuZGFyeS5qcz82YzVhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBHbG9iYWxFcnJvcjtcbmV4cG9ydHMuRXJyb3JCb3VuZGFyeSA9IEVycm9yQm91bmRhcnk7XG52YXIgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0LmpzXCIpLmRlZmF1bHQ7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5mdW5jdGlvbiBHbG9iYWxFcnJvcih7IGVycm9yICB9KSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImh0bWxcIiwgbnVsbCwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaGVhZFwiLCBudWxsKSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiYm9keVwiLCBudWxsLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBzdHlsZTogc3R5bGVzLmVycm9yXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgc3R5bGU6IHN0eWxlcy5kZXNjXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaDJcIiwge1xuICAgICAgICBzdHlsZTogc3R5bGVzLnRleHRcbiAgICB9LCBcIkFwcGxpY2F0aW9uIGVycm9yOiBhIGNsaWVudC1zaWRlIGV4Y2VwdGlvbiBoYXMgb2NjdXJyZWQgKHNlZSB0aGUgYnJvd3NlciBjb25zb2xlIGZvciBtb3JlIGluZm9ybWF0aW9uKS5cIiksIChlcnJvciA9PSBudWxsID8gdm9pZCAwIDogZXJyb3IuZGlnZXN0KSAmJiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJwXCIsIHtcbiAgICAgICAgc3R5bGU6IHN0eWxlcy50ZXh0XG4gICAgfSwgYERpZ2VzdDogJHtlcnJvci5kaWdlc3R9YCkpKSkpO1xufVxuXG5jb25zdCBzdHlsZXMgPSB7XG4gICAgZXJyb3I6IHtcbiAgICAgICAgZm9udEZhbWlseTogJy1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgUm9ib3RvLCBcIlNlZ29lIFVJXCIsIFwiRmlyYSBTYW5zXCIsIEF2ZW5pciwgXCJIZWx2ZXRpY2EgTmV1ZVwiLCBcIkx1Y2lkYSBHcmFuZGVcIiwgc2Fucy1zZXJpZicsXG4gICAgICAgIGhlaWdodDogJzEwMHZoJyxcbiAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICBmbGV4RGlyZWN0aW9uOiAnY29sdW1uJyxcbiAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAgIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJ1xuICAgIH0sXG4gICAgZGVzYzoge1xuICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgICAgdGV4dEFsaWduOiAnbGVmdCcsXG4gICAgICAgIGxpbmVIZWlnaHQ6ICc0OXB4JyxcbiAgICAgICAgaGVpZ2h0OiAnNDlweCcsXG4gICAgICAgIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnXG4gICAgfSxcbiAgICB0ZXh0OiB7XG4gICAgICAgIGZvbnRTaXplOiAnMTRweCcsXG4gICAgICAgIGZvbnRXZWlnaHQ6ICdub3JtYWwnLFxuICAgICAgICBsaW5lSGVpZ2h0OiAnNDlweCcsXG4gICAgICAgIG1hcmdpbjogMCxcbiAgICAgICAgcGFkZGluZzogMFxuICAgIH1cbn07XG5jbGFzcyBFcnJvckJvdW5kYXJ5SGFuZGxlciBleHRlbmRzIF9yZWFjdC5kZWZhdWx0LkNvbXBvbmVudCB7XG4gICAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5lcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgdGhpcy5wcm9wcy5lcnJvclN0eWxlcywgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KHRoaXMucHJvcHMuZXJyb3JDb21wb25lbnQsIHtcbiAgICAgICAgICAgICAgICBlcnJvcjogdGhpcy5zdGF0ZS5lcnJvcixcbiAgICAgICAgICAgICAgICByZXNldDogdGhpcy5yZXNldFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcyl7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgdGhpcy5yZXNldCA9ICgpPT57XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuRXJyb3JCb3VuZGFyeUhhbmRsZXIgPSBFcnJvckJvdW5kYXJ5SGFuZGxlcjtcbmZ1bmN0aW9uIEVycm9yQm91bmRhcnkoeyBlcnJvckNvbXBvbmVudCAsIGVycm9yU3R5bGVzICwgY2hpbGRyZW4gIH0pIHtcbiAgICBpZiAoZXJyb3JDb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChFcnJvckJvdW5kYXJ5SGFuZGxlciwge1xuICAgICAgICAgICAgZXJyb3JDb21wb25lbnQ6IGVycm9yQ29tcG9uZW50LFxuICAgICAgICAgICAgZXJyb3JTdHlsZXM6IGVycm9yU3R5bGVzXG4gICAgICAgIH0sIGNoaWxkcmVuKTtcbiAgICB9XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvci1ib3VuZGFyeS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0IiwiR2xvYmFsRXJyb3IiLCJFcnJvckJvdW5kYXJ5IiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsIl9yZWFjdCIsImVycm9yIiwiY3JlYXRlRWxlbWVudCIsInN0eWxlIiwic3R5bGVzIiwiZGVzYyIsInRleHQiLCJkaWdlc3QiLCJmb250RmFtaWx5IiwiaGVpZ2h0IiwidGV4dEFsaWduIiwiZGlzcGxheSIsImZsZXhEaXJlY3Rpb24iLCJhbGlnbkl0ZW1zIiwianVzdGlmeUNvbnRlbnQiLCJsaW5lSGVpZ2h0IiwidmVydGljYWxBbGlnbiIsImZvbnRTaXplIiwiZm9udFdlaWdodCIsIm1hcmdpbiIsInBhZGRpbmciLCJFcnJvckJvdW5kYXJ5SGFuZGxlciIsIkNvbXBvbmVudCIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsInJlbmRlciIsInN0YXRlIiwiRnJhZ21lbnQiLCJwcm9wcyIsImVycm9yU3R5bGVzIiwiZXJyb3JDb21wb25lbnQiLCJyZXNldCIsImNoaWxkcmVuIiwiY29uc3RydWN0b3IiLCJzZXRTdGF0ZSIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/error-boundary.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/infinite-promise.js":
/*!***********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/infinite-promise.js ***!
  \***********************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createInfinitePromise = createInfinitePromise;\n/**\n * Used to cache in createInfinitePromise\n */ let infinitePromise;\nfunction createInfinitePromise() {\n    if (!infinitePromise) {\n        // Only create the Promise once\n        infinitePromise = new Promise(()=>{\n        // This is used to debug when the rendering is never updated.\n        // setTimeout(() => {\n        //   infinitePromise = new Error('Infinite promise')\n        //   resolve()\n        // }, 5000)\n        });\n    }\n    return infinitePromise;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=infinite-promise.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTMuMS41X3JlYWN0LWRvbUAxOC4yLjArcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvaW5maW5pdGUtcHJvbWlzZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCw2QkFBNkIsR0FBR0U7QUFDaEM7O0NBRUMsR0FBRyxJQUFJQztBQUNSLFNBQVNELHdCQUF3QjtJQUM3QixJQUFJLENBQUNDLGlCQUFpQjtRQUNsQiwrQkFBK0I7UUFDL0JBLGtCQUFrQixJQUFJQyxRQUFRLElBQUk7UUFDbEMsNkRBQTZEO1FBQzdELHFCQUFxQjtRQUNyQixvREFBb0Q7UUFDcEQsY0FBYztRQUNkLFdBQVc7UUFDWDtJQUNKLENBQUM7SUFDRCxPQUFPRDtBQUNYO0FBRUEsSUFBSSxDQUFDLE9BQU9ILFFBQVFLLE9BQU8sS0FBSyxjQUFlLE9BQU9MLFFBQVFLLE9BQU8sS0FBSyxZQUFZTCxRQUFRSyxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9MLFFBQVFLLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktSLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUUssT0FBTyxFQUFFLGNBQWM7UUFBRUosT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9TLE1BQU0sQ0FBQ1AsUUFBUUssT0FBTyxFQUFFTDtJQUMvQlEsT0FBT1IsT0FBTyxHQUFHQSxRQUFRSyxPQUFPO0FBQ2xDLENBQUMsQ0FFRCw0Q0FBNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTMuMS41X3JlYWN0LWRvbUAxOC4yLjArcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvaW5maW5pdGUtcHJvbWlzZS5qcz9hNDQ1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jcmVhdGVJbmZpbml0ZVByb21pc2UgPSBjcmVhdGVJbmZpbml0ZVByb21pc2U7XG4vKipcbiAqIFVzZWQgdG8gY2FjaGUgaW4gY3JlYXRlSW5maW5pdGVQcm9taXNlXG4gKi8gbGV0IGluZmluaXRlUHJvbWlzZTtcbmZ1bmN0aW9uIGNyZWF0ZUluZmluaXRlUHJvbWlzZSgpIHtcbiAgICBpZiAoIWluZmluaXRlUHJvbWlzZSkge1xuICAgICAgICAvLyBPbmx5IGNyZWF0ZSB0aGUgUHJvbWlzZSBvbmNlXG4gICAgICAgIGluZmluaXRlUHJvbWlzZSA9IG5ldyBQcm9taXNlKCgpPT57XG4gICAgICAgIC8vIFRoaXMgaXMgdXNlZCB0byBkZWJ1ZyB3aGVuIHRoZSByZW5kZXJpbmcgaXMgbmV2ZXIgdXBkYXRlZC5cbiAgICAgICAgLy8gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIC8vICAgaW5maW5pdGVQcm9taXNlID0gbmV3IEVycm9yKCdJbmZpbml0ZSBwcm9taXNlJylcbiAgICAgICAgLy8gICByZXNvbHZlKClcbiAgICAgICAgLy8gfSwgNTAwMClcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBpbmZpbml0ZVByb21pc2U7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZmluaXRlLXByb21pc2UuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiY3JlYXRlSW5maW5pdGVQcm9taXNlIiwiaW5maW5pdGVQcm9taXNlIiwiUHJvbWlzZSIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/infinite-promise.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/layout-router.js":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/layout-router.js ***!
  \********************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$(), _s3 = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = OuterLayoutRouter;\nexports.InnerLayoutRouter = InnerLayoutRouter;\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"(app-client)/./node_modules/.pnpm/@swc+helpers@0.4.14/node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"(app-client)/./node_modules/.pnpm/@swc+helpers@0.4.14/node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"(app-client)/./node_modules/.pnpm/@swc+helpers@0.4.14/node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar _react = _interop_require_wildcard(__webpack_require__(/*! react */ \"(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/compiled/react/index.js\"));\nvar _reactDom = _interop_require_default(__webpack_require__(/*! react-dom */ \"(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/compiled/react-dom/index.js\"));\nvar _appRouterContext = __webpack_require__(/*! ../../shared/lib/app-router-context */ \"(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/shared/lib/app-router-context.js\");\nvar _appRouter = __webpack_require__(/*! ./app-router */ \"(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/app-router.js\");\nvar _infinitePromise = __webpack_require__(/*! ./infinite-promise */ \"(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/infinite-promise.js\");\nvar _errorBoundary = __webpack_require__(/*! ./error-boundary */ \"(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/error-boundary.js\");\nvar _matchSegments = __webpack_require__(/*! ./match-segments */ \"(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/match-segments.js\");\nvar _navigation = __webpack_require__(/*! ./navigation */ \"(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/navigation.js\");\nfunction OuterLayoutRouter(param) {\n    let { parallelRouterKey , segmentPath , childProp , error , errorStyles , templateStyles , loading , loadingStyles , hasLoading , template , notFound , notFoundStyles  } = param;\n    _s();\n    const context = (0, _react).useContext(_appRouterContext.LayoutRouterContext);\n    if (!context) {\n        throw new Error(\"invariant expected layout router to be mounted\");\n    }\n    const { childNodes , tree , url  } = context;\n    // Get the current parallelRouter cache node\n    let childNodesForParallelRouter = childNodes.get(parallelRouterKey);\n    // If the parallel router cache node does not exist yet, create it.\n    // This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.\n    if (!childNodesForParallelRouter) {\n        childNodes.set(parallelRouterKey, new Map());\n        childNodesForParallelRouter = childNodes.get(parallelRouterKey);\n    }\n    // Get the active segment in the tree\n    // The reason arrays are used in the data format is that these are transferred from the server to the browser so it's optimized to save bytes.\n    const treeSegment = tree[1][parallelRouterKey][0];\n    const childPropSegment = Array.isArray(childProp.segment) ? childProp.segment[1] : childProp.segment;\n    // If segment is an array it's a dynamic route and we want to read the dynamic route value as the segment to get from the cache.\n    const currentChildSegment = Array.isArray(treeSegment) ? treeSegment[1] : treeSegment;\n    /**\n   * Decides which segments to keep rendering, all segments that are not active will be wrapped in `<Offscreen>`.\n   */ // TODO-APP: Add handling of `<Offscreen>` when it's available.\n    const preservedSegments = [\n        currentChildSegment\n    ];\n    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, preservedSegments.map((preservedSegment)=>{\n        return(/*\n            - Error boundary\n              - Only renders error boundary if error component is provided.\n              - Rendered for each segment to ensure they have their own error state.\n            - Loading boundary\n              - Only renders suspense boundary if loading components is provided.\n              - Rendered for each segment to ensure they have their own loading state.\n              - Passed to the router during rendering to ensure it can be immediately rendered when suspending on a Flight fetch.\n          */ /*#__PURE__*/ _react.default.createElement(_appRouterContext.TemplateContext.Provider, {\n            key: preservedSegment,\n            value: /*#__PURE__*/ _react.default.createElement(_errorBoundary.ErrorBoundary, {\n                errorComponent: error,\n                errorStyles: errorStyles\n            }, /*#__PURE__*/ _react.default.createElement(LoadingBoundary, {\n                hasLoading: hasLoading,\n                loading: loading,\n                loadingStyles: loadingStyles\n            }, /*#__PURE__*/ _react.default.createElement(NotFoundBoundary, {\n                notFound: notFound,\n                notFoundStyles: notFoundStyles\n            }, /*#__PURE__*/ _react.default.createElement(RedirectBoundary, null, /*#__PURE__*/ _react.default.createElement(InnerLayoutRouter, {\n                parallelRouterKey: parallelRouterKey,\n                url: url,\n                tree: tree,\n                childNodes: childNodesForParallelRouter,\n                childProp: childPropSegment === preservedSegment ? childProp : null,\n                segmentPath: segmentPath,\n                path: preservedSegment,\n                isActive: currentChildSegment === preservedSegment\n            })))))\n        }, /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, templateStyles, template)));\n    }));\n}\n_s(OuterLayoutRouter, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\n_c = OuterLayoutRouter;\n/**\n * Add refetch marker to router state at the point of the current layout segment.\n * This ensures the response returned is not further down than the current layout segment.\n */ function walkAddRefetch(segmentPathToWalk, treeToRecreate) {\n    if (segmentPathToWalk) {\n        const [segment, parallelRouteKey] = segmentPathToWalk;\n        const isLast = segmentPathToWalk.length === 2;\n        if ((0, _matchSegments).matchSegment(treeToRecreate[0], segment)) {\n            if (treeToRecreate[1].hasOwnProperty(parallelRouteKey)) {\n                if (isLast) {\n                    const subTree = walkAddRefetch(undefined, treeToRecreate[1][parallelRouteKey]);\n                    return [\n                        treeToRecreate[0],\n                        _extends({}, treeToRecreate[1], {\n                            [parallelRouteKey]: [\n                                subTree[0],\n                                subTree[1],\n                                subTree[2],\n                                \"refetch\"\n                            ]\n                        })\n                    ];\n                }\n                return [\n                    treeToRecreate[0],\n                    _extends({}, treeToRecreate[1], {\n                        [parallelRouteKey]: walkAddRefetch(segmentPathToWalk.slice(2), treeToRecreate[1][parallelRouteKey])\n                    })\n                ];\n            }\n        }\n    }\n    return treeToRecreate;\n}\n// TODO-APP: Replace with new React API for finding dom nodes without a `ref` when available\n/**\n * Wraps ReactDOM.findDOMNode with additional logic to hide React Strict Mode warning\n */ function findDOMNode(instance) {\n    // Tree-shake for server bundle\n    if (false) {}\n    // Only apply strict mode warning when not in production\n    if (true) {\n        const originalConsoleError = console.error;\n        try {\n            console.error = function() {\n                for(var _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++){\n                    messages[_key] = arguments[_key];\n                }\n                // Ignore strict mode warning for the findDomNode call below\n                if (!messages[0].includes(\"Warning: %s is deprecated in StrictMode.\")) {\n                    originalConsoleError(...messages);\n                }\n            };\n            return _reactDom.default.findDOMNode(instance);\n        } finally{\n            console.error = originalConsoleError;\n        }\n    }\n    return _reactDom.default.findDOMNode(instance);\n}\n/**\n * Check if the top of the HTMLElement is in the viewport.\n */ function topOfElementInViewport(element) {\n    const rect = element.getBoundingClientRect();\n    return rect.top >= 0;\n}\nclass ScrollAndFocusHandler extends _react.default.Component {\n    componentDidMount() {\n        // Handle scroll and focus, it's only applied once in the first useEffect that triggers that changed.\n        const { focusAndScrollRef  } = this.props;\n        const domNode = findDOMNode(this);\n        if (focusAndScrollRef.apply && domNode instanceof HTMLElement) {\n            // State is mutated to ensure that the focus and scroll is applied only once.\n            focusAndScrollRef.apply = false;\n            // Set focus on the element\n            domNode.focus();\n            // Only scroll into viewport when the layout is not visible currently.\n            if (!topOfElementInViewport(domNode)) {\n                const htmlElement = document.documentElement;\n                const existing = htmlElement.style.scrollBehavior;\n                htmlElement.style.scrollBehavior = \"auto\";\n                // In Chrome-based browsers we need to force reflow before calling `scrollTo`.\n                // Otherwise it will not pickup the change in scrollBehavior\n                // More info here: https://github.com/vercel/next.js/issues/40719#issuecomment-1336248042\n                htmlElement.getClientRects();\n                domNode.scrollIntoView();\n                htmlElement.style.scrollBehavior = existing;\n            }\n        }\n    }\n    render() {\n        return this.props.children;\n    }\n}\nfunction InnerLayoutRouter(param) {\n    let { parallelRouterKey , url , childNodes , childProp , segmentPath , tree , // isActive,\n    path  } = param;\n    _s1();\n    const context = (0, _react).useContext(_appRouterContext.GlobalLayoutRouterContext);\n    if (!context) {\n        throw new Error(\"invariant global layout router not mounted\");\n    }\n    const { changeByServerResponse , tree: fullTree , focusAndScrollRef  } = context;\n    // Read segment path from the parallel router cache node.\n    let childNode = childNodes.get(path);\n    // If childProp is available this means it's the Flight / SSR case.\n    if (childProp && // TODO-APP: verify if this can be null based on user code\n    childProp.current !== null) {\n        if (childNode && childNode.status === _appRouterContext.CacheStates.LAZY_INITIALIZED) {\n            // @ts-expect-error TODO-APP: handle changing of the type\n            childNode.status = _appRouterContext.CacheStates.READY;\n            // @ts-expect-error TODO-APP: handle changing of the type\n            childNode.subTreeData = childProp.current;\n            // Mutates the prop in order to clean up the memory associated with the subTreeData as it is now part of the cache.\n            childProp.current = null;\n        } else {\n            // Add the segment's subTreeData to the cache.\n            // This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.\n            childNodes.set(path, {\n                status: _appRouterContext.CacheStates.READY,\n                data: null,\n                subTreeData: childProp.current,\n                parallelRoutes: new Map()\n            });\n            // Mutates the prop in order to clean up the memory associated with the subTreeData as it is now part of the cache.\n            childProp.current = null;\n            // In the above case childNode was set on childNodes, so we have to get it from the cacheNodes again.\n            childNode = childNodes.get(path);\n        }\n    }\n    // When childNode is not available during rendering client-side we need to fetch it from the server.\n    if (!childNode || childNode.status === _appRouterContext.CacheStates.LAZY_INITIALIZED) {\n        /**\n     * Router state with refetch marker added\n     */ // TODO-APP: remove ''\n        const refetchTree = walkAddRefetch([\n            \"\",\n            ...segmentPath\n        ], fullTree);\n        /**\n     * Flight data fetch kicked off during render and put into the cache.\n     */ childNodes.set(path, {\n            status: _appRouterContext.CacheStates.DATA_FETCH,\n            data: (0, _appRouter).fetchServerResponse(new URL(url, location.origin), refetchTree),\n            subTreeData: null,\n            head: childNode && childNode.status === _appRouterContext.CacheStates.LAZY_INITIALIZED ? childNode.head : undefined,\n            parallelRoutes: childNode && childNode.status === _appRouterContext.CacheStates.LAZY_INITIALIZED ? childNode.parallelRoutes : new Map()\n        });\n        // In the above case childNode was set on childNodes, so we have to get it from the cacheNodes again.\n        childNode = childNodes.get(path);\n    }\n    // This case should never happen so it throws an error. It indicates there's a bug in the Next.js.\n    if (!childNode) {\n        throw new Error(\"Child node should always exist\");\n    }\n    // This case should never happen so it throws an error. It indicates there's a bug in the Next.js.\n    if (childNode.subTreeData && childNode.data) {\n        throw new Error(\"Child node should not have both subTreeData and data\");\n    }\n    // If cache node has a data request we have to unwrap response by `use` and update the cache.\n    if (childNode.data) {\n        /**\n     * Flight response data\n     */ // When the data has not resolved yet `use` will suspend here.\n        const [flightData, overrideCanonicalUrl] = (0, _react).use(childNode.data);\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === \"string\") {\n            window.location.href = url;\n            return null;\n        }\n        // segmentPath from the server does not match the layout's segmentPath\n        childNode.data = null;\n        // setTimeout is used to start a new transition during render, this is an intentional hack around React.\n        setTimeout(()=>{\n            // @ts-ignore startTransition exists\n            _react.default.startTransition(()=>{\n                changeByServerResponse(fullTree, flightData, overrideCanonicalUrl);\n            });\n        });\n        // Suspend infinitely as `changeByServerResponse` will cause a different part of the tree to be rendered.\n        (0, _react).use((0, _infinitePromise).createInfinitePromise());\n    }\n    // If cache node has no subTreeData and no data request we have to infinitely suspend as the data will likely flow in from another place.\n    // TODO-APP: double check users can't return null in a component that will kick in here.\n    if (!childNode.subTreeData) {\n        (0, _react).use((0, _infinitePromise).createInfinitePromise());\n    }\n    const subtree = /*#__PURE__*/ _react.default.createElement(_appRouterContext.LayoutRouterContext.Provider, {\n        value: {\n            tree: tree[1][parallelRouterKey],\n            childNodes: childNode.parallelRoutes,\n            // TODO-APP: overriding of url for parallel routes\n            url: url\n        }\n    }, childNode.subTreeData);\n    // Ensure root layout is not wrapped in a div as the root layout renders `<html>`\n    return /*#__PURE__*/ _react.default.createElement(ScrollAndFocusHandler, {\n        focusAndScrollRef: focusAndScrollRef\n    }, subtree);\n}\n_s1(InnerLayoutRouter, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\n_c1 = InnerLayoutRouter;\n/**\n * Renders suspense boundary with the provided \"loading\" property as the fallback.\n * If no loading property is provided it renders the children without a suspense boundary.\n */ function LoadingBoundary(param) {\n    let { children , loading , loadingStyles , hasLoading  } = param;\n    if (hasLoading) {\n        return /*#__PURE__*/ _react.default.createElement(_react.default.Suspense, {\n            fallback: /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, loadingStyles, loading)\n        }, children);\n    }\n    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, children);\n}\n_c2 = LoadingBoundary;\nfunction HandleRedirect(param) {\n    let { redirect  } = param;\n    _s2();\n    const router = (0, _navigation).useRouter();\n    (0, _react).useEffect(()=>{\n        router.replace(redirect, {});\n    }, [\n        redirect,\n        router\n    ]);\n    return null;\n}\n_s2(HandleRedirect, \"vQduR7x+OPXj6PSmJyFnf+hU7bg=\");\n_c3 = HandleRedirect;\nclass RedirectErrorBoundary extends _react.default.Component {\n    static getDerivedStateFromError(error) {\n        var ref;\n        if (error == null ? void 0 : (ref = error.digest) == null ? void 0 : ref.startsWith(\"NEXT_REDIRECT\")) {\n            const url = error.digest.split(\";\")[1];\n            return {\n                redirect: url\n            };\n        }\n        // Re-throw if error is not for redirect\n        throw error;\n    }\n    render() {\n        const redirect = this.state.redirect;\n        if (redirect !== null) {\n            return /*#__PURE__*/ _react.default.createElement(HandleRedirect, {\n                redirect: redirect\n            });\n        }\n        return this.props.children;\n    }\n    constructor(props){\n        super(props);\n        this.state = {\n            redirect: null\n        };\n    }\n}\nfunction RedirectBoundary(param) {\n    let { children  } = param;\n    _s3();\n    const router = (0, _navigation).useRouter();\n    return /*#__PURE__*/ _react.default.createElement(RedirectErrorBoundary, {\n        router: router\n    }, children);\n}\n_s3(RedirectBoundary, \"fN7XvhJ+p5oE6+Xlo0NJmXpxjC8=\");\n_c4 = RedirectBoundary;\nclass NotFoundErrorBoundary extends _react.default.Component {\n    static getDerivedStateFromError(error) {\n        if ((error == null ? void 0 : error.digest) === \"NEXT_NOT_FOUND\") {\n            return {\n                notFoundTriggered: true\n            };\n        }\n        // Re-throw if error is not for 404\n        throw error;\n    }\n    render() {\n        if (this.state.notFoundTriggered) {\n            return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement(\"meta\", {\n                name: \"robots\",\n                content: \"noindex\"\n            }), this.props.notFoundStyles, this.props.notFound);\n        }\n        return this.props.children;\n    }\n    constructor(props){\n        super(props);\n        this.state = {\n            notFoundTriggered: false\n        };\n    }\n}\nfunction NotFoundBoundary(param) {\n    let { notFound , notFoundStyles , children  } = param;\n    return notFound ? /*#__PURE__*/ _react.default.createElement(NotFoundErrorBoundary, {\n        notFound: notFound,\n        notFoundStyles: notFoundStyles\n    }, children) : /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, children);\n}\n_c5 = NotFoundBoundary;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=layout-router.js.map\nvar _c, _c1, _c2, _c3, _c4, _c5;\n$RefreshReg$(_c, \"OuterLayoutRouter\");\n$RefreshReg$(_c1, \"InnerLayoutRouter\");\n$RefreshReg$(_c2, \"LoadingBoundary\");\n$RefreshReg$(_c3, \"HandleRedirect\");\n$RefreshReg$(_c4, \"RedirectBoundary\");\n$RefreshReg$(_c5, \"NotFoundBoundary\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTMuMS41X3JlYWN0LWRvbUAxOC4yLjArcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvbGF5b3V0LXJvdXRlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFDYTs7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsa0JBQWUsR0FBR0c7QUFDbEJILHlCQUF5QixHQUFHSTtBQUM1QixJQUFJQyxXQUFXQyx1S0FBK0M7QUFDOUQsSUFBSUMsMkJBQTJCRCx1TUFBK0Q7QUFDOUYsSUFBSUUsNEJBQTRCRix5TUFBZ0U7QUFDaEcsSUFBSUcsU0FBU0QsMEJBQTBCRixtQkFBT0EsQ0FBQyx5SUFBTztBQUN0RCxJQUFJSSxZQUFZSCx5QkFBeUJELG1CQUFPQSxDQUFDLGlKQUFXO0FBQzVELElBQUlLLG9CQUFvQkwsbUJBQU9BLENBQUMsZ0xBQXFDO0FBQ3JFLElBQUlNLGFBQWFOLG1CQUFPQSxDQUFDLHdKQUFjO0FBQ3ZDLElBQUlPLG1CQUFtQlAsbUJBQU9BLENBQUMsb0tBQW9CO0FBQ25ELElBQUlRLGlCQUFpQlIsbUJBQU9BLENBQUMsZ0tBQWtCO0FBQy9DLElBQUlTLGlCQUFpQlQsbUJBQU9BLENBQUMsZ0tBQWtCO0FBQy9DLElBQUlVLGNBQWNWLG1CQUFPQSxDQUFDLHdKQUFjO0FBQ3hDLFNBQVNILGtCQUFrQixLQUFxSyxFQUFFO1FBQXZLLEVBQUVjLGtCQUFpQixFQUFHQyxZQUFXLEVBQUdDLFVBQVMsRUFBR0MsTUFBSyxFQUFHQyxZQUFXLEVBQUdDLGVBQWMsRUFBR0MsUUFBTyxFQUFHQyxjQUFhLEVBQUdDLFdBQVUsRUFBR0MsU0FBUSxFQUFHQyxTQUFRLEVBQUdDLGVBQWMsRUFBRyxHQUFySzs7SUFDdkIsTUFBTUMsVUFBVSxDQUFDLEdBQUdwQixNQUFNLEVBQUVxQixVQUFVLENBQUNuQixrQkFBa0JvQixt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QUFPLEdBQUdBLFFBQVFFLE9BQU87QUFDbEMsQ0FBQyxDQUVELHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxMy4xLjVfcmVhY3QtZG9tQDE4LjIuMCtyZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9sYXlvdXQtcm91dGVyLmpzP2RmMGQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IE91dGVyTGF5b3V0Um91dGVyO1xuZXhwb3J0cy5Jbm5lckxheW91dFJvdXRlciA9IElubmVyTGF5b3V0Um91dGVyO1xudmFyIF9leHRlbmRzID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2V4dGVuZHMuanNcIikuZGVmYXVsdDtcbnZhciBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuanNcIikuZGVmYXVsdDtcbnZhciBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZC5qc1wiKS5kZWZhdWx0O1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfcmVhY3REb20gPSBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcInJlYWN0LWRvbVwiKSk7XG52YXIgX2FwcFJvdXRlckNvbnRleHQgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHRcIik7XG52YXIgX2FwcFJvdXRlciA9IHJlcXVpcmUoXCIuL2FwcC1yb3V0ZXJcIik7XG52YXIgX2luZmluaXRlUHJvbWlzZSA9IHJlcXVpcmUoXCIuL2luZmluaXRlLXByb21pc2VcIik7XG52YXIgX2Vycm9yQm91bmRhcnkgPSByZXF1aXJlKFwiLi9lcnJvci1ib3VuZGFyeVwiKTtcbnZhciBfbWF0Y2hTZWdtZW50cyA9IHJlcXVpcmUoXCIuL21hdGNoLXNlZ21lbnRzXCIpO1xudmFyIF9uYXZpZ2F0aW9uID0gcmVxdWlyZShcIi4vbmF2aWdhdGlvblwiKTtcbmZ1bmN0aW9uIE91dGVyTGF5b3V0Um91dGVyKHsgcGFyYWxsZWxSb3V0ZXJLZXkgLCBzZWdtZW50UGF0aCAsIGNoaWxkUHJvcCAsIGVycm9yICwgZXJyb3JTdHlsZXMgLCB0ZW1wbGF0ZVN0eWxlcyAsIGxvYWRpbmcgLCBsb2FkaW5nU3R5bGVzICwgaGFzTG9hZGluZyAsIHRlbXBsYXRlICwgbm90Rm91bmQgLCBub3RGb3VuZFN0eWxlcyAgfSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSAoMCwgX3JlYWN0KS51c2VDb250ZXh0KF9hcHBSb3V0ZXJDb250ZXh0LkxheW91dFJvdXRlckNvbnRleHQpO1xuICAgIGlmICghY29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCBleHBlY3RlZCBsYXlvdXQgcm91dGVyIHRvIGJlIG1vdW50ZWQnKTtcbiAgICB9XG4gICAgY29uc3QgeyBjaGlsZE5vZGVzICwgdHJlZSAsIHVybCAgfSA9IGNvbnRleHQ7XG4gICAgLy8gR2V0IHRoZSBjdXJyZW50IHBhcmFsbGVsUm91dGVyIGNhY2hlIG5vZGVcbiAgICBsZXQgY2hpbGROb2Rlc0ZvclBhcmFsbGVsUm91dGVyID0gY2hpbGROb2Rlcy5nZXQocGFyYWxsZWxSb3V0ZXJLZXkpO1xuICAgIC8vIElmIHRoZSBwYXJhbGxlbCByb3V0ZXIgY2FjaGUgbm9kZSBkb2VzIG5vdCBleGlzdCB5ZXQsIGNyZWF0ZSBpdC5cbiAgICAvLyBUaGlzIHdyaXRlcyB0byB0aGUgY2FjaGUgd2hlbiB0aGVyZSBpcyBubyBpdGVtIGluIHRoZSBjYWNoZSB5ZXQuIEl0IG5ldmVyICpvdmVyd3JpdGVzKiBleGlzdGluZyBjYWNoZSBpdGVtcyB3aGljaCBpcyB3aHkgaXQncyBzYWZlIGluIGNvbmN1cnJlbnQgbW9kZS5cbiAgICBpZiAoIWNoaWxkTm9kZXNGb3JQYXJhbGxlbFJvdXRlcikge1xuICAgICAgICBjaGlsZE5vZGVzLnNldChwYXJhbGxlbFJvdXRlcktleSwgbmV3IE1hcCgpKTtcbiAgICAgICAgY2hpbGROb2Rlc0ZvclBhcmFsbGVsUm91dGVyID0gY2hpbGROb2Rlcy5nZXQocGFyYWxsZWxSb3V0ZXJLZXkpO1xuICAgIH1cbiAgICAvLyBHZXQgdGhlIGFjdGl2ZSBzZWdtZW50IGluIHRoZSB0cmVlXG4gICAgLy8gVGhlIHJlYXNvbiBhcnJheXMgYXJlIHVzZWQgaW4gdGhlIGRhdGEgZm9ybWF0IGlzIHRoYXQgdGhlc2UgYXJlIHRyYW5zZmVycmVkIGZyb20gdGhlIHNlcnZlciB0byB0aGUgYnJvd3NlciBzbyBpdCdzIG9wdGltaXplZCB0byBzYXZlIGJ5dGVzLlxuICAgIGNvbnN0IHRyZWVTZWdtZW50ID0gdHJlZVsxXVtwYXJhbGxlbFJvdXRlcktleV1bMF07XG4gICAgY29uc3QgY2hpbGRQcm9wU2VnbWVudCA9IEFycmF5LmlzQXJyYXkoY2hpbGRQcm9wLnNlZ21lbnQpID8gY2hpbGRQcm9wLnNlZ21lbnRbMV0gOiBjaGlsZFByb3Auc2VnbWVudDtcbiAgICAvLyBJZiBzZWdtZW50IGlzIGFuIGFycmF5IGl0J3MgYSBkeW5hbWljIHJvdXRlIGFuZCB3ZSB3YW50IHRvIHJlYWQgdGhlIGR5bmFtaWMgcm91dGUgdmFsdWUgYXMgdGhlIHNlZ21lbnQgdG8gZ2V0IGZyb20gdGhlIGNhY2hlLlxuICAgIGNvbnN0IGN1cnJlbnRDaGlsZFNlZ21lbnQgPSBBcnJheS5pc0FycmF5KHRyZWVTZWdtZW50KSA/IHRyZWVTZWdtZW50WzFdIDogdHJlZVNlZ21lbnQ7XG4gICAgLyoqXG4gICAqIERlY2lkZXMgd2hpY2ggc2VnbWVudHMgdG8ga2VlcCByZW5kZXJpbmcsIGFsbCBzZWdtZW50cyB0aGF0IGFyZSBub3QgYWN0aXZlIHdpbGwgYmUgd3JhcHBlZCBpbiBgPE9mZnNjcmVlbj5gLlxuICAgKi8gLy8gVE9ETy1BUFA6IEFkZCBoYW5kbGluZyBvZiBgPE9mZnNjcmVlbj5gIHdoZW4gaXQncyBhdmFpbGFibGUuXG4gICAgY29uc3QgcHJlc2VydmVkU2VnbWVudHMgPSBbXG4gICAgICAgIGN1cnJlbnRDaGlsZFNlZ21lbnRcbiAgICBdO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIHByZXNlcnZlZFNlZ21lbnRzLm1hcCgocHJlc2VydmVkU2VnbWVudCk9PntcbiAgICAgICAgcmV0dXJuKC8qXG4gICAgICAgICAgICAtIEVycm9yIGJvdW5kYXJ5XG4gICAgICAgICAgICAgIC0gT25seSByZW5kZXJzIGVycm9yIGJvdW5kYXJ5IGlmIGVycm9yIGNvbXBvbmVudCBpcyBwcm92aWRlZC5cbiAgICAgICAgICAgICAgLSBSZW5kZXJlZCBmb3IgZWFjaCBzZWdtZW50IHRvIGVuc3VyZSB0aGV5IGhhdmUgdGhlaXIgb3duIGVycm9yIHN0YXRlLlxuICAgICAgICAgICAgLSBMb2FkaW5nIGJvdW5kYXJ5XG4gICAgICAgICAgICAgIC0gT25seSByZW5kZXJzIHN1c3BlbnNlIGJvdW5kYXJ5IGlmIGxvYWRpbmcgY29tcG9uZW50cyBpcyBwcm92aWRlZC5cbiAgICAgICAgICAgICAgLSBSZW5kZXJlZCBmb3IgZWFjaCBzZWdtZW50IHRvIGVuc3VyZSB0aGV5IGhhdmUgdGhlaXIgb3duIGxvYWRpbmcgc3RhdGUuXG4gICAgICAgICAgICAgIC0gUGFzc2VkIHRvIHRoZSByb3V0ZXIgZHVyaW5nIHJlbmRlcmluZyB0byBlbnN1cmUgaXQgY2FuIGJlIGltbWVkaWF0ZWx5IHJlbmRlcmVkIHdoZW4gc3VzcGVuZGluZyBvbiBhIEZsaWdodCBmZXRjaC5cbiAgICAgICAgICAqLyAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2FwcFJvdXRlckNvbnRleHQuVGVtcGxhdGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgICAgICBrZXk6IHByZXNlcnZlZFNlZ21lbnQsXG4gICAgICAgICAgICB2YWx1ZTogLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9lcnJvckJvdW5kYXJ5LkVycm9yQm91bmRhcnksIHtcbiAgICAgICAgICAgICAgICBlcnJvckNvbXBvbmVudDogZXJyb3IsXG4gICAgICAgICAgICAgICAgZXJyb3JTdHlsZXM6IGVycm9yU3R5bGVzXG4gICAgICAgICAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoTG9hZGluZ0JvdW5kYXJ5LCB7XG4gICAgICAgICAgICAgICAgaGFzTG9hZGluZzogaGFzTG9hZGluZyxcbiAgICAgICAgICAgICAgICBsb2FkaW5nOiBsb2FkaW5nLFxuICAgICAgICAgICAgICAgIGxvYWRpbmdTdHlsZXM6IGxvYWRpbmdTdHlsZXNcbiAgICAgICAgICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChOb3RGb3VuZEJvdW5kYXJ5LCB7XG4gICAgICAgICAgICAgICAgbm90Rm91bmQ6IG5vdEZvdW5kLFxuICAgICAgICAgICAgICAgIG5vdEZvdW5kU3R5bGVzOiBub3RGb3VuZFN0eWxlc1xuICAgICAgICAgICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJlZGlyZWN0Qm91bmRhcnksIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChJbm5lckxheW91dFJvdXRlciwge1xuICAgICAgICAgICAgICAgIHBhcmFsbGVsUm91dGVyS2V5OiBwYXJhbGxlbFJvdXRlcktleSxcbiAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICB0cmVlOiB0cmVlLFxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXM6IGNoaWxkTm9kZXNGb3JQYXJhbGxlbFJvdXRlcixcbiAgICAgICAgICAgICAgICBjaGlsZFByb3A6IGNoaWxkUHJvcFNlZ21lbnQgPT09IHByZXNlcnZlZFNlZ21lbnQgPyBjaGlsZFByb3AgOiBudWxsLFxuICAgICAgICAgICAgICAgIHNlZ21lbnRQYXRoOiBzZWdtZW50UGF0aCxcbiAgICAgICAgICAgICAgICBwYXRoOiBwcmVzZXJ2ZWRTZWdtZW50LFxuICAgICAgICAgICAgICAgIGlzQWN0aXZlOiBjdXJyZW50Q2hpbGRTZWdtZW50ID09PSBwcmVzZXJ2ZWRTZWdtZW50XG4gICAgICAgICAgICB9KSkpKSlcbiAgICAgICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCB0ZW1wbGF0ZVN0eWxlcywgdGVtcGxhdGUpKSk7XG4gICAgfSkpO1xufVxuXG4vKipcbiAqIEFkZCByZWZldGNoIG1hcmtlciB0byByb3V0ZXIgc3RhdGUgYXQgdGhlIHBvaW50IG9mIHRoZSBjdXJyZW50IGxheW91dCBzZWdtZW50LlxuICogVGhpcyBlbnN1cmVzIHRoZSByZXNwb25zZSByZXR1cm5lZCBpcyBub3QgZnVydGhlciBkb3duIHRoYW4gdGhlIGN1cnJlbnQgbGF5b3V0IHNlZ21lbnQuXG4gKi8gZnVuY3Rpb24gd2Fsa0FkZFJlZmV0Y2goc2VnbWVudFBhdGhUb1dhbGssIHRyZWVUb1JlY3JlYXRlKSB7XG4gICAgaWYgKHNlZ21lbnRQYXRoVG9XYWxrKSB7XG4gICAgICAgIGNvbnN0IFtzZWdtZW50LCBwYXJhbGxlbFJvdXRlS2V5XSA9IHNlZ21lbnRQYXRoVG9XYWxrO1xuICAgICAgICBjb25zdCBpc0xhc3QgPSBzZWdtZW50UGF0aFRvV2Fsay5sZW5ndGggPT09IDI7XG4gICAgICAgIGlmICgoMCwgX21hdGNoU2VnbWVudHMpLm1hdGNoU2VnbWVudCh0cmVlVG9SZWNyZWF0ZVswXSwgc2VnbWVudCkpIHtcbiAgICAgICAgICAgIGlmICh0cmVlVG9SZWNyZWF0ZVsxXS5oYXNPd25Qcm9wZXJ0eShwYXJhbGxlbFJvdXRlS2V5KSkge1xuICAgICAgICAgICAgICAgIGlmIChpc0xhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ViVHJlZSA9IHdhbGtBZGRSZWZldGNoKHVuZGVmaW5lZCwgdHJlZVRvUmVjcmVhdGVbMV1bcGFyYWxsZWxSb3V0ZUtleV0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJlZVRvUmVjcmVhdGVbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBfZXh0ZW5kcyh7fSwgdHJlZVRvUmVjcmVhdGVbMV0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbcGFyYWxsZWxSb3V0ZUtleV06IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViVHJlZVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViVHJlZVsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViVHJlZVsyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JlZmV0Y2gnLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHRyZWVUb1JlY3JlYXRlWzBdLFxuICAgICAgICAgICAgICAgICAgICBfZXh0ZW5kcyh7fSwgdHJlZVRvUmVjcmVhdGVbMV0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtwYXJhbGxlbFJvdXRlS2V5XTogd2Fsa0FkZFJlZmV0Y2goc2VnbWVudFBhdGhUb1dhbGsuc2xpY2UoMiksIHRyZWVUb1JlY3JlYXRlWzFdW3BhcmFsbGVsUm91dGVLZXldKVxuICAgICAgICAgICAgICAgICAgICB9KSwgXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJlZVRvUmVjcmVhdGU7XG59XG4vLyBUT0RPLUFQUDogUmVwbGFjZSB3aXRoIG5ldyBSZWFjdCBBUEkgZm9yIGZpbmRpbmcgZG9tIG5vZGVzIHdpdGhvdXQgYSBgcmVmYCB3aGVuIGF2YWlsYWJsZVxuLyoqXG4gKiBXcmFwcyBSZWFjdERPTS5maW5kRE9NTm9kZSB3aXRoIGFkZGl0aW9uYWwgbG9naWMgdG8gaGlkZSBSZWFjdCBTdHJpY3QgTW9kZSB3YXJuaW5nXG4gKi8gZnVuY3Rpb24gZmluZERPTU5vZGUoaW5zdGFuY2UpIHtcbiAgICAvLyBUcmVlLXNoYWtlIGZvciBzZXJ2ZXIgYnVuZGxlXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZCkgcmV0dXJuIG51bGw7XG4gICAgLy8gT25seSBhcHBseSBzdHJpY3QgbW9kZSB3YXJuaW5nIHdoZW4gbm90IGluIHByb2R1Y3Rpb25cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjb25zdCBvcmlnaW5hbENvbnNvbGVFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yID0gKC4uLm1lc3NhZ2VzKT0+e1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBzdHJpY3QgbW9kZSB3YXJuaW5nIGZvciB0aGUgZmluZERvbU5vZGUgY2FsbCBiZWxvd1xuICAgICAgICAgICAgICAgIGlmICghbWVzc2FnZXNbMF0uaW5jbHVkZXMoJ1dhcm5pbmc6ICVzIGlzIGRlcHJlY2F0ZWQgaW4gU3RyaWN0TW9kZS4nKSkge1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbENvbnNvbGVFcnJvciguLi5tZXNzYWdlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBfcmVhY3REb20uZGVmYXVsdC5maW5kRE9NTm9kZShpbnN0YW5jZSk7XG4gICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IgPSBvcmlnaW5hbENvbnNvbGVFcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX3JlYWN0RG9tLmRlZmF1bHQuZmluZERPTU5vZGUoaW5zdGFuY2UpO1xufVxuLyoqXG4gKiBDaGVjayBpZiB0aGUgdG9wIG9mIHRoZSBIVE1MRWxlbWVudCBpcyBpbiB0aGUgdmlld3BvcnQuXG4gKi8gZnVuY3Rpb24gdG9wT2ZFbGVtZW50SW5WaWV3cG9ydChlbGVtZW50KSB7XG4gICAgY29uc3QgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHJlY3QudG9wID49IDA7XG59XG5jbGFzcyBTY3JvbGxBbmRGb2N1c0hhbmRsZXIgZXh0ZW5kcyBfcmVhY3QuZGVmYXVsdC5Db21wb25lbnQge1xuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICAvLyBIYW5kbGUgc2Nyb2xsIGFuZCBmb2N1cywgaXQncyBvbmx5IGFwcGxpZWQgb25jZSBpbiB0aGUgZmlyc3QgdXNlRWZmZWN0IHRoYXQgdHJpZ2dlcnMgdGhhdCBjaGFuZ2VkLlxuICAgICAgICBjb25zdCB7IGZvY3VzQW5kU2Nyb2xsUmVmICB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgZG9tTm9kZSA9IGZpbmRET01Ob2RlKHRoaXMpO1xuICAgICAgICBpZiAoZm9jdXNBbmRTY3JvbGxSZWYuYXBwbHkgJiYgZG9tTm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICAvLyBTdGF0ZSBpcyBtdXRhdGVkIHRvIGVuc3VyZSB0aGF0IHRoZSBmb2N1cyBhbmQgc2Nyb2xsIGlzIGFwcGxpZWQgb25seSBvbmNlLlxuICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWYuYXBwbHkgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIFNldCBmb2N1cyBvbiB0aGUgZWxlbWVudFxuICAgICAgICAgICAgZG9tTm9kZS5mb2N1cygpO1xuICAgICAgICAgICAgLy8gT25seSBzY3JvbGwgaW50byB2aWV3cG9ydCB3aGVuIHRoZSBsYXlvdXQgaXMgbm90IHZpc2libGUgY3VycmVudGx5LlxuICAgICAgICAgICAgaWYgKCF0b3BPZkVsZW1lbnRJblZpZXdwb3J0KGRvbU5vZGUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaHRtbEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBodG1sRWxlbWVudC5zdHlsZS5zY3JvbGxCZWhhdmlvcjtcbiAgICAgICAgICAgICAgICBodG1sRWxlbWVudC5zdHlsZS5zY3JvbGxCZWhhdmlvciA9ICdhdXRvJztcbiAgICAgICAgICAgICAgICAvLyBJbiBDaHJvbWUtYmFzZWQgYnJvd3NlcnMgd2UgbmVlZCB0byBmb3JjZSByZWZsb3cgYmVmb3JlIGNhbGxpbmcgYHNjcm9sbFRvYC5cbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgaXQgd2lsbCBub3QgcGlja3VwIHRoZSBjaGFuZ2UgaW4gc2Nyb2xsQmVoYXZpb3JcbiAgICAgICAgICAgICAgICAvLyBNb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9uZXh0LmpzL2lzc3Vlcy80MDcxOSNpc3N1ZWNvbW1lbnQtMTMzNjI0ODA0MlxuICAgICAgICAgICAgICAgIGh0bWxFbGVtZW50LmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgICAgICAgICAgZG9tTm9kZS5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgICAgICAgIGh0bWxFbGVtZW50LnN0eWxlLnNjcm9sbEJlaGF2aW9yID0gZXhpc3Rpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICB9XG59XG5mdW5jdGlvbiBJbm5lckxheW91dFJvdXRlcih7IHBhcmFsbGVsUm91dGVyS2V5ICwgdXJsICwgY2hpbGROb2RlcyAsIGNoaWxkUHJvcCAsIHNlZ21lbnRQYXRoICwgdHJlZSAsIC8vIFRPRE8tQVBQOiBpbXBsZW1lbnQgYDxPZmZzY3JlZW4+YCB3aGVuIGF2YWlsYWJsZS5cbi8vIGlzQWN0aXZlLFxucGF0aCAgfSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSAoMCwgX3JlYWN0KS51c2VDb250ZXh0KF9hcHBSb3V0ZXJDb250ZXh0Lkdsb2JhbExheW91dFJvdXRlckNvbnRleHQpO1xuICAgIGlmICghY29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCBnbG9iYWwgbGF5b3V0IHJvdXRlciBub3QgbW91bnRlZCcpO1xuICAgIH1cbiAgICBjb25zdCB7IGNoYW5nZUJ5U2VydmVyUmVzcG9uc2UgLCB0cmVlOiBmdWxsVHJlZSAsIGZvY3VzQW5kU2Nyb2xsUmVmICB9ID0gY29udGV4dDtcbiAgICAvLyBSZWFkIHNlZ21lbnQgcGF0aCBmcm9tIHRoZSBwYXJhbGxlbCByb3V0ZXIgY2FjaGUgbm9kZS5cbiAgICBsZXQgY2hpbGROb2RlID0gY2hpbGROb2Rlcy5nZXQocGF0aCk7XG4gICAgLy8gSWYgY2hpbGRQcm9wIGlzIGF2YWlsYWJsZSB0aGlzIG1lYW5zIGl0J3MgdGhlIEZsaWdodCAvIFNTUiBjYXNlLlxuICAgIGlmIChjaGlsZFByb3AgJiYgLy8gVE9ETy1BUFA6IHZlcmlmeSBpZiB0aGlzIGNhbiBiZSBudWxsIGJhc2VkIG9uIHVzZXIgY29kZVxuICAgIGNoaWxkUHJvcC5jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChjaGlsZE5vZGUgJiYgY2hpbGROb2RlLnN0YXR1cyA9PT0gX2FwcFJvdXRlckNvbnRleHQuQ2FjaGVTdGF0ZXMuTEFaWV9JTklUSUFMSVpFRCkge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPLUFQUDogaGFuZGxlIGNoYW5naW5nIG9mIHRoZSB0eXBlXG4gICAgICAgICAgICBjaGlsZE5vZGUuc3RhdHVzID0gX2FwcFJvdXRlckNvbnRleHQuQ2FjaGVTdGF0ZXMuUkVBRFk7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE8tQVBQOiBoYW5kbGUgY2hhbmdpbmcgb2YgdGhlIHR5cGVcbiAgICAgICAgICAgIGNoaWxkTm9kZS5zdWJUcmVlRGF0YSA9IGNoaWxkUHJvcC5jdXJyZW50O1xuICAgICAgICAgICAgLy8gTXV0YXRlcyB0aGUgcHJvcCBpbiBvcmRlciB0byBjbGVhbiB1cCB0aGUgbWVtb3J5IGFzc29jaWF0ZWQgd2l0aCB0aGUgc3ViVHJlZURhdGEgYXMgaXQgaXMgbm93IHBhcnQgb2YgdGhlIGNhY2hlLlxuICAgICAgICAgICAgY2hpbGRQcm9wLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQWRkIHRoZSBzZWdtZW50J3Mgc3ViVHJlZURhdGEgdG8gdGhlIGNhY2hlLlxuICAgICAgICAgICAgLy8gVGhpcyB3cml0ZXMgdG8gdGhlIGNhY2hlIHdoZW4gdGhlcmUgaXMgbm8gaXRlbSBpbiB0aGUgY2FjaGUgeWV0LiBJdCBuZXZlciAqb3ZlcndyaXRlcyogZXhpc3RpbmcgY2FjaGUgaXRlbXMgd2hpY2ggaXMgd2h5IGl0J3Mgc2FmZSBpbiBjb25jdXJyZW50IG1vZGUuXG4gICAgICAgICAgICBjaGlsZE5vZGVzLnNldChwYXRoLCB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5SRUFEWSxcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIHN1YlRyZWVEYXRhOiBjaGlsZFByb3AuY3VycmVudCxcbiAgICAgICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcCgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIE11dGF0ZXMgdGhlIHByb3AgaW4gb3JkZXIgdG8gY2xlYW4gdXAgdGhlIG1lbW9yeSBhc3NvY2lhdGVkIHdpdGggdGhlIHN1YlRyZWVEYXRhIGFzIGl0IGlzIG5vdyBwYXJ0IG9mIHRoZSBjYWNoZS5cbiAgICAgICAgICAgIGNoaWxkUHJvcC5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIC8vIEluIHRoZSBhYm92ZSBjYXNlIGNoaWxkTm9kZSB3YXMgc2V0IG9uIGNoaWxkTm9kZXMsIHNvIHdlIGhhdmUgdG8gZ2V0IGl0IGZyb20gdGhlIGNhY2hlTm9kZXMgYWdhaW4uXG4gICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzLmdldChwYXRoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBXaGVuIGNoaWxkTm9kZSBpcyBub3QgYXZhaWxhYmxlIGR1cmluZyByZW5kZXJpbmcgY2xpZW50LXNpZGUgd2UgbmVlZCB0byBmZXRjaCBpdCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgaWYgKCFjaGlsZE5vZGUgfHwgY2hpbGROb2RlLnN0YXR1cyA9PT0gX2FwcFJvdXRlckNvbnRleHQuQ2FjaGVTdGF0ZXMuTEFaWV9JTklUSUFMSVpFRCkge1xuICAgICAgICAvKipcbiAgICAgKiBSb3V0ZXIgc3RhdGUgd2l0aCByZWZldGNoIG1hcmtlciBhZGRlZFxuICAgICAqLyAvLyBUT0RPLUFQUDogcmVtb3ZlICcnXG4gICAgICAgIGNvbnN0IHJlZmV0Y2hUcmVlID0gd2Fsa0FkZFJlZmV0Y2goW1xuICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAuLi5zZWdtZW50UGF0aFxuICAgICAgICBdLCBmdWxsVHJlZSk7XG4gICAgICAgIC8qKlxuICAgICAqIEZsaWdodCBkYXRhIGZldGNoIGtpY2tlZCBvZmYgZHVyaW5nIHJlbmRlciBhbmQgcHV0IGludG8gdGhlIGNhY2hlLlxuICAgICAqLyBjaGlsZE5vZGVzLnNldChwYXRoLCB7XG4gICAgICAgICAgICBzdGF0dXM6IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLkRBVEFfRkVUQ0gsXG4gICAgICAgICAgICBkYXRhOiAoMCwgX2FwcFJvdXRlcikuZmV0Y2hTZXJ2ZXJSZXNwb25zZShuZXcgVVJMKHVybCwgbG9jYXRpb24ub3JpZ2luKSwgcmVmZXRjaFRyZWUpLFxuICAgICAgICAgICAgc3ViVHJlZURhdGE6IG51bGwsXG4gICAgICAgICAgICBoZWFkOiBjaGlsZE5vZGUgJiYgY2hpbGROb2RlLnN0YXR1cyA9PT0gX2FwcFJvdXRlckNvbnRleHQuQ2FjaGVTdGF0ZXMuTEFaWV9JTklUSUFMSVpFRCA/IGNoaWxkTm9kZS5oZWFkIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuc3RhdHVzID09PSBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5MQVpZX0lOSVRJQUxJWkVEID8gY2hpbGROb2RlLnBhcmFsbGVsUm91dGVzIDogbmV3IE1hcCgpXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBJbiB0aGUgYWJvdmUgY2FzZSBjaGlsZE5vZGUgd2FzIHNldCBvbiBjaGlsZE5vZGVzLCBzbyB3ZSBoYXZlIHRvIGdldCBpdCBmcm9tIHRoZSBjYWNoZU5vZGVzIGFnYWluLlxuICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzLmdldChwYXRoKTtcbiAgICB9XG4gICAgLy8gVGhpcyBjYXNlIHNob3VsZCBuZXZlciBoYXBwZW4gc28gaXQgdGhyb3dzIGFuIGVycm9yLiBJdCBpbmRpY2F0ZXMgdGhlcmUncyBhIGJ1ZyBpbiB0aGUgTmV4dC5qcy5cbiAgICBpZiAoIWNoaWxkTm9kZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NoaWxkIG5vZGUgc2hvdWxkIGFsd2F5cyBleGlzdCcpO1xuICAgIH1cbiAgICAvLyBUaGlzIGNhc2Ugc2hvdWxkIG5ldmVyIGhhcHBlbiBzbyBpdCB0aHJvd3MgYW4gZXJyb3IuIEl0IGluZGljYXRlcyB0aGVyZSdzIGEgYnVnIGluIHRoZSBOZXh0LmpzLlxuICAgIGlmIChjaGlsZE5vZGUuc3ViVHJlZURhdGEgJiYgY2hpbGROb2RlLmRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGlsZCBub2RlIHNob3VsZCBub3QgaGF2ZSBib3RoIHN1YlRyZWVEYXRhIGFuZCBkYXRhJyk7XG4gICAgfVxuICAgIC8vIElmIGNhY2hlIG5vZGUgaGFzIGEgZGF0YSByZXF1ZXN0IHdlIGhhdmUgdG8gdW53cmFwIHJlc3BvbnNlIGJ5IGB1c2VgIGFuZCB1cGRhdGUgdGhlIGNhY2hlLlxuICAgIGlmIChjaGlsZE5vZGUuZGF0YSkge1xuICAgICAgICAvKipcbiAgICAgKiBGbGlnaHQgcmVzcG9uc2UgZGF0YVxuICAgICAqLyAvLyBXaGVuIHRoZSBkYXRhIGhhcyBub3QgcmVzb2x2ZWQgeWV0IGB1c2VgIHdpbGwgc3VzcGVuZCBoZXJlLlxuICAgICAgICBjb25zdCBbZmxpZ2h0RGF0YSwgb3ZlcnJpZGVDYW5vbmljYWxVcmxdID0gKDAsIF9yZWFjdCkudXNlKGNoaWxkTm9kZS5kYXRhKTtcbiAgICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiBuYXZpZ2F0aW5nIHRvIHBhZ2UgaW4gYHBhZ2VzYCBmcm9tIGBhcHBgXG4gICAgICAgIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2VnbWVudFBhdGggZnJvbSB0aGUgc2VydmVyIGRvZXMgbm90IG1hdGNoIHRoZSBsYXlvdXQncyBzZWdtZW50UGF0aFxuICAgICAgICBjaGlsZE5vZGUuZGF0YSA9IG51bGw7XG4gICAgICAgIC8vIHNldFRpbWVvdXQgaXMgdXNlZCB0byBzdGFydCBhIG5ldyB0cmFuc2l0aW9uIGR1cmluZyByZW5kZXIsIHRoaXMgaXMgYW4gaW50ZW50aW9uYWwgaGFjayBhcm91bmQgUmVhY3QuXG4gICAgICAgIHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgc3RhcnRUcmFuc2l0aW9uIGV4aXN0c1xuICAgICAgICAgICAgX3JlYWN0LmRlZmF1bHQuc3RhcnRUcmFuc2l0aW9uKCgpPT57XG4gICAgICAgICAgICAgICAgY2hhbmdlQnlTZXJ2ZXJSZXNwb25zZShmdWxsVHJlZSwgZmxpZ2h0RGF0YSwgb3ZlcnJpZGVDYW5vbmljYWxVcmwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTdXNwZW5kIGluZmluaXRlbHkgYXMgYGNoYW5nZUJ5U2VydmVyUmVzcG9uc2VgIHdpbGwgY2F1c2UgYSBkaWZmZXJlbnQgcGFydCBvZiB0aGUgdHJlZSB0byBiZSByZW5kZXJlZC5cbiAgICAgICAgKDAsIF9yZWFjdCkudXNlKCgwLCBfaW5maW5pdGVQcm9taXNlKS5jcmVhdGVJbmZpbml0ZVByb21pc2UoKSk7XG4gICAgfVxuICAgIC8vIElmIGNhY2hlIG5vZGUgaGFzIG5vIHN1YlRyZWVEYXRhIGFuZCBubyBkYXRhIHJlcXVlc3Qgd2UgaGF2ZSB0byBpbmZpbml0ZWx5IHN1c3BlbmQgYXMgdGhlIGRhdGEgd2lsbCBsaWtlbHkgZmxvdyBpbiBmcm9tIGFub3RoZXIgcGxhY2UuXG4gICAgLy8gVE9ETy1BUFA6IGRvdWJsZSBjaGVjayB1c2VycyBjYW4ndCByZXR1cm4gbnVsbCBpbiBhIGNvbXBvbmVudCB0aGF0IHdpbGwga2ljayBpbiBoZXJlLlxuICAgIGlmICghY2hpbGROb2RlLnN1YlRyZWVEYXRhKSB7XG4gICAgICAgICgwLCBfcmVhY3QpLnVzZSgoMCwgX2luZmluaXRlUHJvbWlzZSkuY3JlYXRlSW5maW5pdGVQcm9taXNlKCkpO1xuICAgIH1cbiAgICBjb25zdCBzdWJ0cmVlID0gLy8gVGhlIGxheW91dCByb3V0ZXIgY29udGV4dCBuYXJyb3dzIGRvd24gdHJlZSBhbmQgY2hpbGROb2RlcyBhdCBlYWNoIGxldmVsLlxuICAgIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfYXBwUm91dGVyQ29udGV4dC5MYXlvdXRSb3V0ZXJDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0cmVlOiB0cmVlWzFdW3BhcmFsbGVsUm91dGVyS2V5XSxcbiAgICAgICAgICAgIGNoaWxkTm9kZXM6IGNoaWxkTm9kZS5wYXJhbGxlbFJvdXRlcyxcbiAgICAgICAgICAgIC8vIFRPRE8tQVBQOiBvdmVycmlkaW5nIG9mIHVybCBmb3IgcGFyYWxsZWwgcm91dGVzXG4gICAgICAgICAgICB1cmw6IHVybFxuICAgICAgICB9XG4gICAgfSwgY2hpbGROb2RlLnN1YlRyZWVEYXRhKTtcbiAgICAvLyBFbnN1cmUgcm9vdCBsYXlvdXQgaXMgbm90IHdyYXBwZWQgaW4gYSBkaXYgYXMgdGhlIHJvb3QgbGF5b3V0IHJlbmRlcnMgYDxodG1sPmBcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFNjcm9sbEFuZEZvY3VzSGFuZGxlciwge1xuICAgICAgICBmb2N1c0FuZFNjcm9sbFJlZjogZm9jdXNBbmRTY3JvbGxSZWZcbiAgICB9LCBzdWJ0cmVlKTtcbn1cbi8qKlxuICogUmVuZGVycyBzdXNwZW5zZSBib3VuZGFyeSB3aXRoIHRoZSBwcm92aWRlZCBcImxvYWRpbmdcIiBwcm9wZXJ0eSBhcyB0aGUgZmFsbGJhY2suXG4gKiBJZiBubyBsb2FkaW5nIHByb3BlcnR5IGlzIHByb3ZpZGVkIGl0IHJlbmRlcnMgdGhlIGNoaWxkcmVuIHdpdGhvdXQgYSBzdXNwZW5zZSBib3VuZGFyeS5cbiAqLyBmdW5jdGlvbiBMb2FkaW5nQm91bmRhcnkoeyBjaGlsZHJlbiAsIGxvYWRpbmcgLCBsb2FkaW5nU3R5bGVzICwgaGFzTG9hZGluZyAgfSkge1xuICAgIGlmIChoYXNMb2FkaW5nKSB7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuU3VzcGVuc2UsIHtcbiAgICAgICAgICAgIGZhbGxiYWNrOiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIGxvYWRpbmdTdHlsZXMsIGxvYWRpbmcpXG4gICAgICAgIH0sIGNoaWxkcmVuKTtcbiAgICB9XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pO1xufVxuZnVuY3Rpb24gSGFuZGxlUmVkaXJlY3QoeyByZWRpcmVjdCAgfSkge1xuICAgIGNvbnN0IHJvdXRlciA9ICgwLCBfbmF2aWdhdGlvbikudXNlUm91dGVyKCk7XG4gICAgKDAsIF9yZWFjdCkudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIHJvdXRlci5yZXBsYWNlKHJlZGlyZWN0LCB7fSk7XG4gICAgfSwgW1xuICAgICAgICByZWRpcmVjdCxcbiAgICAgICAgcm91dGVyXG4gICAgXSk7XG4gICAgcmV0dXJuIG51bGw7XG59XG5jbGFzcyBSZWRpcmVjdEVycm9yQm91bmRhcnkgZXh0ZW5kcyBfcmVhY3QuZGVmYXVsdC5Db21wb25lbnQge1xuICAgIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgaWYgKGVycm9yID09IG51bGwgPyB2b2lkIDAgOiAocmVmID0gZXJyb3IuZGlnZXN0KSA9PSBudWxsID8gdm9pZCAwIDogcmVmLnN0YXJ0c1dpdGgoJ05FWFRfUkVESVJFQ1QnKSkge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gZXJyb3IuZGlnZXN0LnNwbGl0KCc7JylbMV07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlZGlyZWN0OiB1cmxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmUtdGhyb3cgaWYgZXJyb3IgaXMgbm90IGZvciByZWRpcmVjdFxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCByZWRpcmVjdCA9IHRoaXMuc3RhdGUucmVkaXJlY3Q7XG4gICAgICAgIGlmIChyZWRpcmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChIYW5kbGVSZWRpcmVjdCwge1xuICAgICAgICAgICAgICAgIHJlZGlyZWN0OiByZWRpcmVjdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHByb3BzKXtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgcmVkaXJlY3Q6IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBSZWRpcmVjdEJvdW5kYXJ5KHsgY2hpbGRyZW4gIH0pIHtcbiAgICBjb25zdCByb3V0ZXIgPSAoMCwgX25hdmlnYXRpb24pLnVzZVJvdXRlcigpO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUmVkaXJlY3RFcnJvckJvdW5kYXJ5LCB7XG4gICAgICAgIHJvdXRlcjogcm91dGVyXG4gICAgfSwgY2hpbGRyZW4pO1xufVxuY2xhc3MgTm90Rm91bmRFcnJvckJvdW5kYXJ5IGV4dGVuZHMgX3JlYWN0LmRlZmF1bHQuQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKSB7XG4gICAgICAgIGlmICgoZXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IGVycm9yLmRpZ2VzdCkgPT09ICdORVhUX05PVF9GT1VORCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbm90Rm91bmRUcmlnZ2VyZWQ6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmUtdGhyb3cgaWYgZXJyb3IgaXMgbm90IGZvciA0MDRcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUubm90Rm91bmRUcmlnZ2VyZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcIm1ldGFcIiwge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwicm9ib3RzXCIsXG4gICAgICAgICAgICAgICAgY29udGVudDogXCJub2luZGV4XCJcbiAgICAgICAgICAgIH0pLCB0aGlzLnByb3BzLm5vdEZvdW5kU3R5bGVzLCB0aGlzLnByb3BzLm5vdEZvdW5kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IocHJvcHMpe1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBub3RGb3VuZFRyaWdnZXJlZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBOb3RGb3VuZEJvdW5kYXJ5KHsgbm90Rm91bmQgLCBub3RGb3VuZFN0eWxlcyAsIGNoaWxkcmVuICB9KSB7XG4gICAgcmV0dXJuIG5vdEZvdW5kID8gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KE5vdEZvdW5kRXJyb3JCb3VuZGFyeSwge1xuICAgICAgICBub3RGb3VuZDogbm90Rm91bmQsXG4gICAgICAgIG5vdEZvdW5kU3R5bGVzOiBub3RGb3VuZFN0eWxlc1xuICAgIH0sIGNoaWxkcmVuKSA6IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYXlvdXQtcm91dGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlZmF1bHQiLCJPdXRlckxheW91dFJvdXRlciIsIklubmVyTGF5b3V0Um91dGVyIiwiX2V4dGVuZHMiLCJyZXF1aXJlIiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwiX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCIsIl9yZWFjdCIsIl9yZWFjdERvbSIsIl9hcHBSb3V0ZXJDb250ZXh0IiwiX2FwcFJvdXRlciIsIl9pbmZpbml0ZVByb21pc2UiLCJfZXJyb3JCb3VuZGFyeSIsIl9tYXRjaFNlZ21lbnRzIiwiX25hdmlnYXRpb24iLCJwYXJhbGxlbFJvdXRlcktleSIsInNlZ21lbnRQYXRoIiwiY2hpbGRQcm9wIiwiZXJyb3IiLCJlcnJvclN0eWxlcyIsInRlbXBsYXRlU3R5bGVzIiwibG9hZGluZyIsImxvYWRpbmdTdHlsZXMiLCJoYXNMb2FkaW5nIiwidGVtcGxhdGUiLCJub3RGb3VuZCIsIm5vdEZvdW5kU3R5bGVzIiwiY29udGV4dCIsInVzZUNvbnRleHQiLCJMYXlvdXRSb3V0ZXJDb250ZXh0IiwiRXJyb3IiLCJjaGlsZE5vZGVzIiwidHJlZSIsInVybCIsImNoaWxkTm9kZXNGb3JQYXJhbGxlbFJvdXRlciIsImdldCIsInNldCIsIk1hcCIsInRyZWVTZWdtZW50IiwiY2hpbGRQcm9wU2VnbWVudCIsIkFycmF5IiwiaXNBcnJheSIsInNlZ21lbnQiLCJjdXJyZW50Q2hpbGRTZWdtZW50IiwicHJlc2VydmVkU2VnbWVudHMiLCJjcmVhdGVFbGVtZW50IiwiRnJhZ21lbnQiLCJtYXAiLCJwcmVzZXJ2ZWRTZWdtZW50IiwiVGVtcGxhdGVDb250ZXh0IiwiUHJvdmlkZXIiLCJrZXkiLCJFcnJvckJvdW5kYXJ5IiwiZXJyb3JDb21wb25lbnQiLCJMb2FkaW5nQm91bmRhcnkiLCJOb3RGb3VuZEJvdW5kYXJ5IiwiUmVkaXJlY3RCb3VuZGFyeSIsInBhdGgiLCJpc0FjdGl2ZSIsIndhbGtBZGRSZWZldGNoIiwic2VnbWVudFBhdGhUb1dhbGsiLCJ0cmVlVG9SZWNyZWF0ZSIsInBhcmFsbGVsUm91dGVLZXkiLCJpc0xhc3QiLCJsZW5ndGgiLCJtYXRjaFNlZ21lbnQiLCJoYXNPd25Qcm9wZXJ0eSIsInN1YlRyZWUiLCJ1bmRlZmluZWQiLCJzbGljZSIsImZpbmRET01Ob2RlIiwiaW5zdGFuY2UiLCJwcm9jZXNzIiwib3JpZ2luYWxDb25zb2xlRXJyb3IiLCJjb25zb2xlIiwibWVzc2FnZXMiLCJpbmNsdWRlcyIsInRvcE9mRWxlbWVudEluVmlld3BvcnQiLCJlbGVtZW50IiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInRvcCIsIlNjcm9sbEFuZEZvY3VzSGFuZGxlciIsIkNvbXBvbmVudCIsImNvbXBvbmVudERpZE1vdW50IiwiZm9jdXNBbmRTY3JvbGxSZWYiLCJwcm9wcyIsImRvbU5vZGUiLCJhcHBseSIsIkhUTUxFbGVtZW50IiwiZm9jdXMiLCJodG1sRWxlbWVudCIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiZXhpc3RpbmciLCJzdHlsZSIsInNjcm9sbEJlaGF2aW9yIiwiZ2V0Q2xpZW50UmVjdHMiLCJzY3JvbGxJbnRvVmlldyIsInJlbmRlciIsImNoaWxkcmVuIiwiR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dCIsImNoYW5nZUJ5U2VydmVyUmVzcG9uc2UiLCJmdWxsVHJlZSIsImNoaWxkTm9kZSIsImN1cnJlbnQiLCJzdGF0dXMiLCJDYWNoZVN0YXRlcyIsIkxBWllfSU5JVElBTElaRUQiLCJSRUFEWSIsInN1YlRyZWVEYXRhIiwiZGF0YSIsInBhcmFsbGVsUm91dGVzIiwicmVmZXRjaFRyZWUiLCJEQVRBX0ZFVENIIiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsIlVSTCIsImxvY2F0aW9uIiwib3JpZ2luIiwiaGVhZCIsImZsaWdodERhdGEiLCJvdmVycmlkZUNhbm9uaWNhbFVybCIsInVzZSIsIndpbmRvdyIsImhyZWYiLCJzZXRUaW1lb3V0Iiwic3RhcnRUcmFuc2l0aW9uIiwiY3JlYXRlSW5maW5pdGVQcm9taXNlIiwic3VidHJlZSIsIlN1c3BlbnNlIiwiZmFsbGJhY2siLCJIYW5kbGVSZWRpcmVjdCIsInJlZGlyZWN0Iiwicm91dGVyIiwidXNlUm91dGVyIiwidXNlRWZmZWN0IiwicmVwbGFjZSIsIlJlZGlyZWN0RXJyb3JCb3VuZGFyeSIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsInJlZiIsImRpZ2VzdCIsInN0YXJ0c1dpdGgiLCJzcGxpdCIsInN0YXRlIiwiY29uc3RydWN0b3IiLCJOb3RGb3VuZEVycm9yQm91bmRhcnkiLCJub3RGb3VuZFRyaWdnZXJlZCIsIm5hbWUiLCJjb250ZW50IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/layout-router.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/match-segments.js":
/*!*********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/match-segments.js ***!
  \*********************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.matchSegment = void 0;\nconst matchSegment = (existingSegment, segment)=>{\n    // Common case: segment is just a string\n    if (typeof existingSegment === \"string\" && typeof segment === \"string\") {\n        return existingSegment === segment;\n    }\n    // Dynamic parameter case: segment is an array with param/value. Both param and value are compared.\n    if (Array.isArray(existingSegment) && Array.isArray(segment)) {\n        return existingSegment[0] === segment[0] && existingSegment[1] === segment[1];\n    }\n    return false;\n};\nexports.matchSegment = matchSegment;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=match-segments.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTMuMS41X3JlYWN0LWRvbUAxOC4yLjArcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvbWF0Y2gtc2VnbWVudHMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsb0JBQW9CLEdBQUcsS0FBSztBQUM1QixNQUFNRSxlQUFlLENBQUNDLGlCQUFpQkMsVUFBVTtJQUM3Qyx3Q0FBd0M7SUFDeEMsSUFBSSxPQUFPRCxvQkFBb0IsWUFBWSxPQUFPQyxZQUFZLFVBQVU7UUFDcEUsT0FBT0Qsb0JBQW9CQztJQUMvQixDQUFDO0lBQ0QsbUdBQW1HO0lBQ25HLElBQUlDLE1BQU1DLE9BQU8sQ0FBQ0gsb0JBQW9CRSxNQUFNQyxPQUFPLENBQUNGLFVBQVU7UUFDMUQsT0FBT0QsZUFBZSxDQUFDLEVBQUUsS0FBS0MsT0FBTyxDQUFDLEVBQUUsSUFBSUQsZUFBZSxDQUFDLEVBQUUsS0FBS0MsT0FBTyxDQUFDLEVBQUU7SUFDakYsQ0FBQztJQUNELE9BQU8sS0FBSztBQUNoQjtBQUNBSixvQkFBb0IsR0FBR0U7QUFFdkIsSUFBSSxDQUFDLE9BQU9GLFFBQVFPLE9BQU8sS0FBSyxjQUFlLE9BQU9QLFFBQVFPLE9BQU8sS0FBSyxZQUFZUCxRQUFRTyxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9QLFFBQVFPLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktWLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUU8sT0FBTyxFQUFFLGNBQWM7UUFBRU4sT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9XLE1BQU0sQ0FBQ1QsUUFBUU8sT0FBTyxFQUFFUDtJQUMvQlUsT0FBT1YsT0FBTyxHQUFHQSxRQUFRTyxPQUFPO0FBQ2xDLENBQUMsQ0FFRCwwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTMuMS41X3JlYWN0LWRvbUAxOC4yLjArcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvbWF0Y2gtc2VnbWVudHMuanM/ZGQ2NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMubWF0Y2hTZWdtZW50ID0gdm9pZCAwO1xuY29uc3QgbWF0Y2hTZWdtZW50ID0gKGV4aXN0aW5nU2VnbWVudCwgc2VnbWVudCk9PntcbiAgICAvLyBDb21tb24gY2FzZTogc2VnbWVudCBpcyBqdXN0IGEgc3RyaW5nXG4gICAgaWYgKHR5cGVvZiBleGlzdGluZ1NlZ21lbnQgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBzZWdtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZXhpc3RpbmdTZWdtZW50ID09PSBzZWdtZW50O1xuICAgIH1cbiAgICAvLyBEeW5hbWljIHBhcmFtZXRlciBjYXNlOiBzZWdtZW50IGlzIGFuIGFycmF5IHdpdGggcGFyYW0vdmFsdWUuIEJvdGggcGFyYW0gYW5kIHZhbHVlIGFyZSBjb21wYXJlZC5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShleGlzdGluZ1NlZ21lbnQpICYmIEFycmF5LmlzQXJyYXkoc2VnbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nU2VnbWVudFswXSA9PT0gc2VnbWVudFswXSAmJiBleGlzdGluZ1NlZ21lbnRbMV0gPT09IHNlZ21lbnRbMV07XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5leHBvcnRzLm1hdGNoU2VnbWVudCA9IG1hdGNoU2VnbWVudDtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF0Y2gtc2VnbWVudHMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibWF0Y2hTZWdtZW50IiwiZXhpc3RpbmdTZWdtZW50Iiwic2VnbWVudCIsIkFycmF5IiwiaXNBcnJheSIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/match-segments.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/reducer.js":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/reducer.js ***!
  \**************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createHrefFromUrl = createHrefFromUrl;\nexports.reducer = exports.ACTION_PREFETCH = exports.ACTION_SERVER_PATCH = exports.ACTION_RESTORE = exports.ACTION_NAVIGATE = exports.ACTION_REFRESH = void 0;\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"(app-client)/./node_modules/.pnpm/@swc+helpers@0.4.14/node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\nvar _appRouterContext = __webpack_require__(/*! ../../shared/lib/app-router-context */ \"(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/shared/lib/app-router-context.js\");\nvar _matchSegments = __webpack_require__(/*! ./match-segments */ \"(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/match-segments.js\");\nvar _appRouter = __webpack_require__(/*! ./app-router */ \"(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/app-router.js\");\n/**\n * Create data fetching record for Promise.\n */ // TODO-APP: change `any` to type inference.\nfunction createRecordFromThenable(thenable) {\n    thenable.status = \"pending\";\n    thenable.then((value)=>{\n        if (thenable.status === \"pending\") {\n            thenable.status = \"fulfilled\";\n            thenable.value = value;\n        }\n    }, (err)=>{\n        if (thenable.status === \"pending\") {\n            thenable.status = \"rejected\";\n            thenable.value = err;\n        }\n    });\n    return thenable;\n}\n/**\n * Read record value or throw Promise if it's not resolved yet.\n */ function readRecordValue(thenable) {\n    // @ts-expect-error TODO: fix type\n    if (thenable.status === \"fulfilled\") {\n        // @ts-expect-error TODO: fix type\n        return thenable.value;\n    } else {\n        throw thenable;\n    }\n}\nfunction createHrefFromUrl(url) {\n    return url.pathname + url.search + url.hash;\n}\n/**\n * Invalidate cache one level down from the router state.\n */ function invalidateCacheByRouterState(newCache, existingCache, routerState) {\n    // Remove segment that we got data for so that it is filled in during rendering of subTreeData.\n    for(const key in routerState[1]){\n        const segmentForParallelRoute = routerState[1][key][0];\n        const cacheKey = Array.isArray(segmentForParallelRoute) ? segmentForParallelRoute[1] : segmentForParallelRoute;\n        const existingParallelRoutesCacheNode = existingCache.parallelRoutes.get(key);\n        if (existingParallelRoutesCacheNode) {\n            let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode);\n            parallelRouteCacheNode.delete(cacheKey);\n            newCache.parallelRoutes.set(key, parallelRouteCacheNode);\n        }\n    }\n}\nfunction fillLazyItemsTillLeafWithHead(newCache, existingCache, routerState, head) {\n    const isLastSegment = Object.keys(routerState[1]).length === 0;\n    if (isLastSegment) {\n        newCache.head = head;\n        return;\n    }\n    // Remove segment that we got data for so that it is filled in during rendering of subTreeData.\n    for(const key in routerState[1]){\n        const parallelRouteState = routerState[1][key];\n        const segmentForParallelRoute = parallelRouteState[0];\n        const cacheKey = Array.isArray(segmentForParallelRoute) ? segmentForParallelRoute[1] : segmentForParallelRoute;\n        if (existingCache) {\n            const existingParallelRoutesCacheNode = existingCache.parallelRoutes.get(key);\n            if (existingParallelRoutesCacheNode) {\n                let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode);\n                parallelRouteCacheNode.delete(cacheKey);\n                const newCacheNode = {\n                    status: _appRouterContext.CacheStates.LAZY_INITIALIZED,\n                    data: null,\n                    subTreeData: null,\n                    parallelRoutes: new Map()\n                };\n                parallelRouteCacheNode.set(cacheKey, newCacheNode);\n                fillLazyItemsTillLeafWithHead(newCacheNode, undefined, parallelRouteState, head);\n                newCache.parallelRoutes.set(key, parallelRouteCacheNode);\n                continue;\n            }\n        }\n        const newCacheNode = {\n            status: _appRouterContext.CacheStates.LAZY_INITIALIZED,\n            data: null,\n            subTreeData: null,\n            parallelRoutes: new Map()\n        };\n        newCache.parallelRoutes.set(key, new Map([\n            [\n                cacheKey,\n                newCacheNode\n            ]\n        ]));\n        fillLazyItemsTillLeafWithHead(newCacheNode, undefined, parallelRouteState, head);\n    }\n}\n/**\n * Fill cache with subTreeData based on flightDataPath\n */ function fillCacheWithNewSubTreeData(newCache, existingCache, flightDataPath) {\n    const isLastEntry = flightDataPath.length <= 5;\n    const [parallelRouteKey, segment] = flightDataPath;\n    const segmentForCache = Array.isArray(segment) ? segment[1] : segment;\n    const existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);\n    if (!existingChildSegmentMap) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        // Will trigger lazy fetch in layout-router because of missing segment\n        return;\n    }\n    let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);\n    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n        childSegmentMap = new Map(existingChildSegmentMap);\n        newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);\n    }\n    const existingChildCacheNode = existingChildSegmentMap.get(segmentForCache);\n    let childCacheNode = childSegmentMap.get(segmentForCache);\n    if (isLastEntry) {\n        if (!childCacheNode || !childCacheNode.data || childCacheNode === existingChildCacheNode) {\n            childCacheNode = {\n                status: _appRouterContext.CacheStates.READY,\n                data: null,\n                subTreeData: flightDataPath[3],\n                // Ensure segments other than the one we got data for are preserved.\n                parallelRoutes: existingChildCacheNode ? new Map(existingChildCacheNode.parallelRoutes) : new Map()\n            };\n            if (existingChildCacheNode) {\n                invalidateCacheByRouterState(childCacheNode, existingChildCacheNode, flightDataPath[2]);\n            }\n            fillLazyItemsTillLeafWithHead(childCacheNode, existingChildCacheNode, flightDataPath[2], flightDataPath[4]);\n            childSegmentMap.set(segmentForCache, childCacheNode);\n        }\n        return;\n    }\n    if (!childCacheNode || !existingChildCacheNode) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        // Will trigger lazy fetch in layout-router because of missing segment\n        return;\n    }\n    if (childCacheNode === existingChildCacheNode) {\n        childCacheNode = {\n            status: childCacheNode.status,\n            data: childCacheNode.data,\n            subTreeData: childCacheNode.subTreeData,\n            parallelRoutes: new Map(childCacheNode.parallelRoutes)\n        };\n        childSegmentMap.set(segmentForCache, childCacheNode);\n    }\n    fillCacheWithNewSubTreeData(childCacheNode, existingChildCacheNode, flightDataPath.slice(2));\n}\n/**\n * Fill cache up to the end of the flightSegmentPath, invalidating anything below it.\n */ function invalidateCacheBelowFlightSegmentPath(newCache, existingCache, flightSegmentPath) {\n    const isLastEntry = flightSegmentPath.length <= 2;\n    const [parallelRouteKey, segment] = flightSegmentPath;\n    const segmentForCache = Array.isArray(segment) ? segment[1] : segment;\n    const existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);\n    if (!existingChildSegmentMap) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        // Will trigger lazy fetch in layout-router because of missing segment\n        return;\n    }\n    let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);\n    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n        childSegmentMap = new Map(existingChildSegmentMap);\n        newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);\n    }\n    // In case of last entry don't copy further down.\n    if (isLastEntry) {\n        childSegmentMap.delete(segmentForCache);\n        return;\n    }\n    const existingChildCacheNode = existingChildSegmentMap.get(segmentForCache);\n    let childCacheNode = childSegmentMap.get(segmentForCache);\n    if (!childCacheNode || !existingChildCacheNode) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        // Will trigger lazy fetch in layout-router because of missing segment\n        return;\n    }\n    if (childCacheNode === existingChildCacheNode) {\n        childCacheNode = {\n            status: childCacheNode.status,\n            data: childCacheNode.data,\n            subTreeData: childCacheNode.subTreeData,\n            parallelRoutes: new Map(childCacheNode.parallelRoutes)\n        };\n        childSegmentMap.set(segmentForCache, childCacheNode);\n    }\n    invalidateCacheBelowFlightSegmentPath(childCacheNode, existingChildCacheNode, flightSegmentPath.slice(2));\n}\n/**\n * Kick off fetch based on the common layout between two routes. Fill cache with data property holding the in-progress fetch.\n */ function fillCacheWithDataProperty(newCache, existingCache, segments, fetchResponse) {\n    const isLastEntry = segments.length === 1;\n    const parallelRouteKey = \"children\";\n    const [segment] = segments;\n    const existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);\n    if (!existingChildSegmentMap) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        // Will trigger lazy fetch in layout-router because of missing segment\n        return {\n            bailOptimistic: true\n        };\n    }\n    let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);\n    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n        childSegmentMap = new Map(existingChildSegmentMap);\n        newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);\n    }\n    const existingChildCacheNode = existingChildSegmentMap.get(segment);\n    let childCacheNode = childSegmentMap.get(segment);\n    // In case of last segment start off the fetch at this level and don't copy further down.\n    if (isLastEntry) {\n        if (!childCacheNode || !childCacheNode.data || childCacheNode === existingChildCacheNode) {\n            childSegmentMap.set(segment, {\n                status: _appRouterContext.CacheStates.DATA_FETCH,\n                data: fetchResponse(),\n                subTreeData: null,\n                parallelRoutes: new Map()\n            });\n        }\n        return;\n    }\n    if (!childCacheNode || !existingChildCacheNode) {\n        // Start fetch in the place where the existing cache doesn't have the data yet.\n        if (!childCacheNode) {\n            childSegmentMap.set(segment, {\n                status: _appRouterContext.CacheStates.DATA_FETCH,\n                data: fetchResponse(),\n                subTreeData: null,\n                parallelRoutes: new Map()\n            });\n        }\n        return;\n    }\n    if (childCacheNode === existingChildCacheNode) {\n        childCacheNode = {\n            status: childCacheNode.status,\n            data: childCacheNode.data,\n            subTreeData: childCacheNode.subTreeData,\n            parallelRoutes: new Map(childCacheNode.parallelRoutes)\n        };\n        childSegmentMap.set(segment, childCacheNode);\n    }\n    return fillCacheWithDataProperty(childCacheNode, existingChildCacheNode, segments.slice(1), fetchResponse);\n}\n/**\n * Create optimistic version of router state based on the existing router state and segments.\n * This is used to allow rendering layout-routers up till the point where data is missing.\n */ function createOptimisticTree(segments, flightRouterState, _isFirstSegment, parentRefetch, _href) {\n    const [existingSegment, existingParallelRoutes] = flightRouterState || [\n        null,\n        {}\n    ];\n    const segment = segments[0];\n    const isLastSegment = segments.length === 1;\n    const segmentMatches = existingSegment !== null && (0, _matchSegments).matchSegment(existingSegment, segment);\n    const shouldRefetchThisLevel = !flightRouterState || !segmentMatches;\n    let parallelRoutes = {};\n    if (existingSegment !== null && segmentMatches) {\n        parallelRoutes = existingParallelRoutes;\n    }\n    let childTree;\n    if (!isLastSegment) {\n        const childItem = createOptimisticTree(segments.slice(1), parallelRoutes ? parallelRoutes.children : null, false, parentRefetch || shouldRefetchThisLevel);\n        childTree = childItem;\n    }\n    const result = [\n        segment,\n        _extends({}, parallelRoutes, childTree ? {\n            children: childTree\n        } : {})\n    ];\n    if (!parentRefetch && shouldRefetchThisLevel) {\n        result[3] = \"refetch\";\n    }\n    return result;\n}\n/**\n * Apply the router state from the Flight response. Creates a new router state tree.\n */ function applyRouterStatePatchToTree(flightSegmentPath, flightRouterState, treePatch) {\n    const [segment, parallelRoutes, , , isRootLayout] = flightRouterState;\n    // Root refresh\n    if (flightSegmentPath.length === 1) {\n        const tree = [\n            ...treePatch\n        ];\n        return tree;\n    }\n    const [currentSegment, parallelRouteKey] = flightSegmentPath;\n    // Tree path returned from the server should always match up with the current tree in the browser\n    if (!(0, _matchSegments).matchSegment(currentSegment, segment)) {\n        return null;\n    }\n    const lastSegment = flightSegmentPath.length === 2;\n    let parallelRoutePatch;\n    if (lastSegment) {\n        parallelRoutePatch = treePatch;\n    } else {\n        parallelRoutePatch = applyRouterStatePatchToTree(flightSegmentPath.slice(2), parallelRoutes[parallelRouteKey], treePatch);\n        if (parallelRoutePatch === null) {\n            return null;\n        }\n    }\n    const tree = [\n        flightSegmentPath[0],\n        _extends({}, parallelRoutes, {\n            [parallelRouteKey]: parallelRoutePatch\n        })\n    ];\n    // Current segment is the root layout\n    if (isRootLayout) {\n        tree[4] = true;\n    }\n    return tree;\n}\nfunction shouldHardNavigate(flightSegmentPath, flightRouterState, treePatch) {\n    const [segment, parallelRoutes] = flightRouterState;\n    // TODO-APP: Check if `as` can be replaced.\n    const [currentSegment, parallelRouteKey] = flightSegmentPath;\n    // Check if current segment matches the existing segment.\n    if (!(0, _matchSegments).matchSegment(currentSegment, segment)) {\n        // If dynamic parameter in tree doesn't match up with segment path a hard navigation is triggered.\n        if (Array.isArray(currentSegment)) {\n            return true;\n        }\n        // If the existing segment did not match soft navigation is triggered.\n        return false;\n    }\n    const lastSegment = flightSegmentPath.length <= 2;\n    if (lastSegment) {\n        return false;\n    }\n    return shouldHardNavigate(flightSegmentPath.slice(2), parallelRoutes[parallelRouteKey], treePatch);\n}\nfunction isNavigatingToNewRootLayout(currentTree, nextTree) {\n    // Compare segments\n    const currentTreeSegment = currentTree[0];\n    const nextTreeSegment = nextTree[0];\n    // If any segment is different before we find the root layout, the root layout has changed.\n    // E.g. /same/(group1)/layout.js -> /same/(group2)/layout.js\n    // First segment is 'same' for both, keep looking. (group1) changed to (group2) before the root layout was found, it must have changed.\n    if (Array.isArray(currentTreeSegment) && Array.isArray(nextTreeSegment)) {\n        // Compare dynamic param name and type but ignore the value, different values would not affect the current root layout\n        // /[name] - /slug1 and /slug2, both values (slug1 & slug2) still has the same layout /[name]/layout.js\n        if (currentTreeSegment[0] !== nextTreeSegment[0] || currentTreeSegment[2] !== nextTreeSegment[2]) {\n            return true;\n        }\n    } else if (currentTreeSegment !== nextTreeSegment) {\n        return true;\n    }\n    // Current tree root layout found\n    if (currentTree[4]) {\n        // If the next tree doesn't have the root layout flag, it must have changed.\n        return !nextTree[4];\n    }\n    // Current tree  didn't have its root layout here, must have changed.\n    if (nextTree[4]) {\n        return true;\n    }\n    // We can't assume it's `parallelRoutes.children` here in case the root layout is `app/@something/layout.js`\n    // But it's not possible to be more than one parallelRoutes before the root layout is found\n    // TODO-APP: change to traverse all parallel routes\n    const currentTreeChild = Object.values(currentTree[1])[0];\n    const nextTreeChild = Object.values(nextTree[1])[0];\n    if (!currentTreeChild || !nextTreeChild) return true;\n    return isNavigatingToNewRootLayout(currentTreeChild, nextTreeChild);\n}\nconst ACTION_REFRESH = \"refresh\";\nexports.ACTION_REFRESH = ACTION_REFRESH;\nconst ACTION_NAVIGATE = \"navigate\";\nexports.ACTION_NAVIGATE = ACTION_NAVIGATE;\nconst ACTION_RESTORE = \"restore\";\nexports.ACTION_RESTORE = ACTION_RESTORE;\nconst ACTION_SERVER_PATCH = \"server-patch\";\nexports.ACTION_SERVER_PATCH = ACTION_SERVER_PATCH;\nconst ACTION_PREFETCH = \"prefetch\";\nexports.ACTION_PREFETCH = ACTION_PREFETCH;\n/**\n * Reducer that handles the app-router state updates.\n */ function clientReducer(state, action) {\n    switch(action.type){\n        case ACTION_NAVIGATE:\n            {\n                const { url , navigateType , cache , mutable , forceOptimisticNavigation  } = action;\n                const { pathname , search  } = url;\n                const href = createHrefFromUrl(url);\n                const pendingPush = navigateType === \"push\";\n                const isForCurrentTree = JSON.stringify(mutable.previousTree) === JSON.stringify(state.tree);\n                if (mutable.mpaNavigation && isForCurrentTree) {\n                    return {\n                        // Set href.\n                        canonicalUrl: mutable.canonicalUrlOverride ? mutable.canonicalUrlOverride : href,\n                        pushRef: {\n                            pendingPush,\n                            mpaNavigation: mutable.mpaNavigation\n                        },\n                        // All navigation requires scroll and focus management to trigger.\n                        focusAndScrollRef: {\n                            apply: false\n                        },\n                        // Apply cache.\n                        cache: state.cache,\n                        prefetchCache: state.prefetchCache,\n                        // Apply patched router state.\n                        tree: state.tree\n                    };\n                }\n                // Handle concurrent rendering / strict mode case where the cache and tree were already populated.\n                if (mutable.patchedTree && isForCurrentTree) {\n                    return {\n                        // Set href.\n                        canonicalUrl: mutable.canonicalUrlOverride ? mutable.canonicalUrlOverride : href,\n                        pushRef: {\n                            pendingPush,\n                            mpaNavigation: false\n                        },\n                        // All navigation requires scroll and focus management to trigger.\n                        focusAndScrollRef: {\n                            apply: true\n                        },\n                        // Apply cache.\n                        cache: mutable.useExistingCache ? state.cache : cache,\n                        prefetchCache: state.prefetchCache,\n                        // Apply patched router state.\n                        tree: mutable.patchedTree\n                    };\n                }\n                const prefetchValues = state.prefetchCache.get(href);\n                if (prefetchValues) {\n                    // The one before last item is the router state tree patch\n                    const { flightData , tree: newTree , canonicalUrlOverride  } = prefetchValues;\n                    // Handle case when navigating to page in `pages` from `app`\n                    if (typeof flightData === \"string\") {\n                        return {\n                            canonicalUrl: flightData,\n                            // Enable mpaNavigation\n                            pushRef: {\n                                pendingPush: true,\n                                mpaNavigation: true\n                            },\n                            // Don't apply scroll and focus management.\n                            focusAndScrollRef: {\n                                apply: false\n                            },\n                            cache: state.cache,\n                            prefetchCache: state.prefetchCache,\n                            tree: state.tree\n                        };\n                    }\n                    if (newTree !== null) {\n                        mutable.previousTree = state.tree;\n                        mutable.patchedTree = newTree;\n                        mutable.mpaNavigation = isNavigatingToNewRootLayout(state.tree, newTree);\n                        if (newTree === null) {\n                            throw new Error(\"SEGMENT MISMATCH\");\n                        }\n                        const canonicalUrlOverrideHrefVal = canonicalUrlOverride ? createHrefFromUrl(canonicalUrlOverride) : undefined;\n                        if (canonicalUrlOverrideHrefVal) {\n                            mutable.canonicalUrlOverride = canonicalUrlOverrideHrefVal;\n                        }\n                        mutable.mpaNavigation = isNavigatingToNewRootLayout(state.tree, newTree);\n                        // TODO-APP: Currently the Flight data can only have one item but in the future it can have multiple paths.\n                        const flightDataPath = flightData[0];\n                        const flightSegmentPath = flightDataPath.slice(0, -3);\n                        // The one before last item is the router state tree patch\n                        const [treePatch, subTreeData, head] = flightDataPath.slice(-3);\n                        // Handles case where prefetch only returns the router tree patch without rendered components.\n                        if (subTreeData !== null) {\n                            if (flightDataPath.length === 3) {\n                                cache.status = _appRouterContext.CacheStates.READY;\n                                cache.subTreeData = subTreeData;\n                                cache.parallelRoutes = new Map();\n                                fillLazyItemsTillLeafWithHead(cache, state.cache, treePatch, head);\n                            } else {\n                                cache.status = _appRouterContext.CacheStates.READY;\n                                // Copy subTreeData for the root node of the cache.\n                                cache.subTreeData = state.cache.subTreeData;\n                                // Create a copy of the existing cache with the subTreeData applied.\n                                fillCacheWithNewSubTreeData(cache, state.cache, flightDataPath);\n                            }\n                        }\n                        const hardNavigate = search !== location.search || shouldHardNavigate([\n                            \"\",\n                            ...flightSegmentPath\n                        ], state.tree, newTree);\n                        if (hardNavigate) {\n                            cache.status = _appRouterContext.CacheStates.READY;\n                            // Copy subTreeData for the root node of the cache.\n                            cache.subTreeData = state.cache.subTreeData;\n                            invalidateCacheBelowFlightSegmentPath(cache, state.cache, flightSegmentPath);\n                        // Ensure the existing cache value is used when the cache was not invalidated.\n                        } else if (subTreeData === null) {\n                            mutable.useExistingCache = true;\n                        }\n                        const canonicalUrlOverrideHref = canonicalUrlOverride ? createHrefFromUrl(canonicalUrlOverride) : undefined;\n                        if (canonicalUrlOverrideHref) {\n                            mutable.canonicalUrlOverride = canonicalUrlOverrideHref;\n                        }\n                        return {\n                            // Set href.\n                            canonicalUrl: canonicalUrlOverrideHref ? canonicalUrlOverrideHref : href,\n                            // Set pendingPush.\n                            pushRef: {\n                                pendingPush,\n                                mpaNavigation: false\n                            },\n                            // All navigation requires scroll and focus management to trigger.\n                            focusAndScrollRef: {\n                                apply: true\n                            },\n                            // Apply patched cache.\n                            cache: mutable.useExistingCache ? state.cache : cache,\n                            prefetchCache: state.prefetchCache,\n                            // Apply patched tree.\n                            tree: newTree\n                        };\n                    }\n                }\n                // When doing a hard push there can be two cases: with optimistic tree and without\n                // The with optimistic tree case only happens when the layouts have a loading state (loading.js)\n                // The without optimistic tree case happens when there is no loading state, in that case we suspend in this reducer\n                // forceOptimisticNavigation is used for links that have `prefetch={false}`.\n                if (forceOptimisticNavigation) {\n                    const segments = pathname.split(\"/\");\n                    // TODO-APP: figure out something better for index pages\n                    segments.push(\"\");\n                    // Optimistic tree case.\n                    // If the optimistic tree is deeper than the current state leave that deeper part out of the fetch\n                    const optimisticTree = createOptimisticTree(segments, state.tree, true, false, href);\n                    // Copy subTreeData for the root node of the cache.\n                    cache.status = _appRouterContext.CacheStates.READY;\n                    cache.subTreeData = state.cache.subTreeData;\n                    // Copy existing cache nodes as far as possible and fill in `data` property with the started data fetch.\n                    // The `data` property is used to suspend in layout-router during render if it hasn't resolved yet by the time it renders.\n                    const res = fillCacheWithDataProperty(cache, state.cache, segments.slice(1), ()=>(0, _appRouter).fetchServerResponse(url, optimisticTree));\n                    // If optimistic fetch couldn't happen it falls back to the non-optimistic case.\n                    if (!(res == null ? void 0 : res.bailOptimistic)) {\n                        mutable.previousTree = state.tree;\n                        mutable.patchedTree = optimisticTree;\n                        mutable.mpaNavigation = isNavigatingToNewRootLayout(state.tree, optimisticTree);\n                        return {\n                            // Set href.\n                            canonicalUrl: href,\n                            // Set pendingPush.\n                            pushRef: {\n                                pendingPush,\n                                mpaNavigation: false\n                            },\n                            // All navigation requires scroll and focus management to trigger.\n                            focusAndScrollRef: {\n                                apply: true\n                            },\n                            // Apply patched cache.\n                            cache: cache,\n                            prefetchCache: state.prefetchCache,\n                            // Apply optimistic tree.\n                            tree: optimisticTree\n                        };\n                    }\n                }\n                // Below is the not-optimistic case. Data is fetched at the root and suspended there without a suspense boundary.\n                // If no in-flight fetch at the top, start it.\n                if (!cache.data) {\n                    cache.data = createRecordFromThenable((0, _appRouter).fetchServerResponse(url, state.tree));\n                }\n                // Unwrap cache data with `use` to suspend here (in the reducer) until the fetch resolves.\n                const [flightData, canonicalUrlOverride] = readRecordValue(cache.data);\n                // Handle case when navigating to page in `pages` from `app`\n                if (typeof flightData === \"string\") {\n                    return {\n                        canonicalUrl: flightData,\n                        // Enable mpaNavigation\n                        pushRef: {\n                            pendingPush: true,\n                            mpaNavigation: true\n                        },\n                        // Don't apply scroll and focus management.\n                        focusAndScrollRef: {\n                            apply: false\n                        },\n                        cache: state.cache,\n                        prefetchCache: state.prefetchCache,\n                        tree: state.tree\n                    };\n                }\n                // Remove cache.data as it has been resolved at this point.\n                cache.data = null;\n                // TODO-APP: Currently the Flight data can only have one item but in the future it can have multiple paths.\n                const flightDataPath = flightData[0];\n                // The one before last item is the router state tree patch\n                const [treePatch, subTreeData, head] = flightDataPath.slice(-3);\n                // Path without the last segment, router state, and the subTreeData\n                const flightSegmentPath = flightDataPath.slice(0, -4);\n                // Create new tree based on the flightSegmentPath and router state patch\n                const newTree = applyRouterStatePatchToTree([\n                    \"\",\n                    ...flightSegmentPath\n                ], state.tree, treePatch);\n                if (newTree === null) {\n                    throw new Error(\"SEGMENT MISMATCH\");\n                }\n                const canonicalUrlOverrideHref = canonicalUrlOverride ? createHrefFromUrl(canonicalUrlOverride) : undefined;\n                if (canonicalUrlOverrideHref) {\n                    mutable.canonicalUrlOverride = canonicalUrlOverrideHref;\n                }\n                mutable.previousTree = state.tree;\n                mutable.patchedTree = newTree;\n                mutable.mpaNavigation = isNavigatingToNewRootLayout(state.tree, newTree);\n                if (flightDataPath.length === 3) {\n                    cache.status = _appRouterContext.CacheStates.READY;\n                    cache.subTreeData = subTreeData;\n                    fillLazyItemsTillLeafWithHead(cache, state.cache, treePatch, head);\n                } else {\n                    // Copy subTreeData for the root node of the cache.\n                    cache.status = _appRouterContext.CacheStates.READY;\n                    cache.subTreeData = state.cache.subTreeData;\n                    // Create a copy of the existing cache with the subTreeData applied.\n                    fillCacheWithNewSubTreeData(cache, state.cache, flightDataPath);\n                }\n                return {\n                    // Set href.\n                    canonicalUrl: canonicalUrlOverrideHref ? canonicalUrlOverrideHref : href,\n                    // Set pendingPush.\n                    pushRef: {\n                        pendingPush,\n                        mpaNavigation: false\n                    },\n                    // All navigation requires scroll and focus management to trigger.\n                    focusAndScrollRef: {\n                        apply: true\n                    },\n                    // Apply patched cache.\n                    cache: cache,\n                    prefetchCache: state.prefetchCache,\n                    // Apply patched tree.\n                    tree: newTree\n                };\n            }\n        case ACTION_SERVER_PATCH:\n            {\n                const { flightData , previousTree , overrideCanonicalUrl , cache , mutable  } = action;\n                // When a fetch is slow to resolve it could be that you navigated away while the request was happening or before the reducer runs.\n                // In that case opt-out of applying the patch given that the data could be stale.\n                if (JSON.stringify(previousTree) !== JSON.stringify(state.tree)) {\n                    // TODO-APP: Handle tree mismatch\n                    console.log(\"TREE MISMATCH\");\n                    // Keep everything as-is.\n                    return state;\n                }\n                if (mutable.mpaNavigation) {\n                    return {\n                        // Set href.\n                        canonicalUrl: mutable.canonicalUrlOverride ? mutable.canonicalUrlOverride : state.canonicalUrl,\n                        // TODO-APP: verify mpaNavigation not being set is correct here.\n                        pushRef: {\n                            pendingPush: true,\n                            mpaNavigation: mutable.mpaNavigation\n                        },\n                        // All navigation requires scroll and focus management to trigger.\n                        focusAndScrollRef: {\n                            apply: false\n                        },\n                        // Apply cache.\n                        cache: state.cache,\n                        prefetchCache: state.prefetchCache,\n                        // Apply patched router state.\n                        tree: state.tree\n                    };\n                }\n                // Handle concurrent rendering / strict mode case where the cache and tree were already populated.\n                if (mutable.patchedTree) {\n                    return {\n                        // Keep href as it was set during navigate / restore\n                        canonicalUrl: mutable.canonicalUrlOverride ? mutable.canonicalUrlOverride : state.canonicalUrl,\n                        // Keep pushRef as server-patch only causes cache/tree update.\n                        pushRef: state.pushRef,\n                        // Keep focusAndScrollRef as server-patch only causes cache/tree update.\n                        focusAndScrollRef: state.focusAndScrollRef,\n                        // Apply patched router state\n                        tree: mutable.patchedTree,\n                        prefetchCache: state.prefetchCache,\n                        // Apply patched cache\n                        cache: cache\n                    };\n                }\n                // Handle case when navigating to page in `pages` from `app`\n                if (typeof flightData === \"string\") {\n                    return {\n                        // Set href.\n                        canonicalUrl: flightData,\n                        // Enable mpaNavigation as this is a navigation that the app-router shouldn't handle.\n                        pushRef: {\n                            pendingPush: true,\n                            mpaNavigation: true\n                        },\n                        // Don't apply scroll and focus management.\n                        focusAndScrollRef: {\n                            apply: false\n                        },\n                        // Other state is kept as-is.\n                        cache: state.cache,\n                        prefetchCache: state.prefetchCache,\n                        tree: state.tree\n                    };\n                }\n                // TODO-APP: Currently the Flight data can only have one item but in the future it can have multiple paths.\n                const flightDataPath = flightData[0];\n                // Slices off the last segment (which is at -4) as it doesn't exist in the tree yet\n                const flightSegmentPath = flightDataPath.slice(0, -4);\n                const [treePatch, subTreeData, head] = flightDataPath.slice(-3);\n                const newTree = applyRouterStatePatchToTree([\n                    \"\",\n                    ...flightSegmentPath\n                ], state.tree, treePatch);\n                if (newTree === null) {\n                    throw new Error(\"SEGMENT MISMATCH\");\n                }\n                const canonicalUrlOverrideHref = overrideCanonicalUrl ? createHrefFromUrl(overrideCanonicalUrl) : undefined;\n                if (canonicalUrlOverrideHref) {\n                    mutable.canonicalUrlOverride = canonicalUrlOverrideHref;\n                }\n                mutable.patchedTree = newTree;\n                mutable.mpaNavigation = isNavigatingToNewRootLayout(state.tree, newTree);\n                // Root refresh\n                if (flightDataPath.length === 3) {\n                    cache.status = _appRouterContext.CacheStates.READY;\n                    cache.subTreeData = subTreeData;\n                    fillLazyItemsTillLeafWithHead(cache, state.cache, treePatch, head);\n                } else {\n                    // Copy subTreeData for the root node of the cache.\n                    cache.status = _appRouterContext.CacheStates.READY;\n                    cache.subTreeData = state.cache.subTreeData;\n                    fillCacheWithNewSubTreeData(cache, state.cache, flightDataPath);\n                }\n                return {\n                    // Keep href as it was set during navigate / restore\n                    canonicalUrl: canonicalUrlOverrideHref ? canonicalUrlOverrideHref : state.canonicalUrl,\n                    // Keep pushRef as server-patch only causes cache/tree update.\n                    pushRef: state.pushRef,\n                    // Keep focusAndScrollRef as server-patch only causes cache/tree update.\n                    focusAndScrollRef: state.focusAndScrollRef,\n                    // Apply patched router state\n                    tree: newTree,\n                    prefetchCache: state.prefetchCache,\n                    // Apply patched cache\n                    cache: cache\n                };\n            }\n        case ACTION_RESTORE:\n            {\n                const { url , tree  } = action;\n                const href = createHrefFromUrl(url);\n                return {\n                    // Set canonical url\n                    canonicalUrl: href,\n                    pushRef: state.pushRef,\n                    focusAndScrollRef: state.focusAndScrollRef,\n                    cache: state.cache,\n                    prefetchCache: state.prefetchCache,\n                    // Restore provided tree\n                    tree: tree\n                };\n            }\n        // TODO-APP: Add test for not scrolling to nearest layout when calling refresh.\n        // TODO-APP: Add test for startTransition(() => {router.push('/'); router.refresh();}), that case should scroll.\n        case ACTION_REFRESH:\n            {\n                const { cache , mutable  } = action;\n                const href = state.canonicalUrl;\n                const isForCurrentTree = JSON.stringify(mutable.previousTree) === JSON.stringify(state.tree);\n                if (mutable.mpaNavigation && isForCurrentTree) {\n                    return {\n                        // Set href.\n                        canonicalUrl: mutable.canonicalUrlOverride ? mutable.canonicalUrlOverride : state.canonicalUrl,\n                        // TODO-APP: verify mpaNavigation not being set is correct here.\n                        pushRef: {\n                            pendingPush: true,\n                            mpaNavigation: mutable.mpaNavigation\n                        },\n                        // All navigation requires scroll and focus management to trigger.\n                        focusAndScrollRef: {\n                            apply: false\n                        },\n                        // Apply cache.\n                        cache: state.cache,\n                        prefetchCache: state.prefetchCache,\n                        // Apply patched router state.\n                        tree: state.tree\n                    };\n                }\n                // Handle concurrent rendering / strict mode case where the cache and tree were already populated.\n                if (mutable.patchedTree && isForCurrentTree) {\n                    return {\n                        // Set href.\n                        canonicalUrl: mutable.canonicalUrlOverride ? mutable.canonicalUrlOverride : href,\n                        // set pendingPush (always false in this case).\n                        pushRef: state.pushRef,\n                        // Apply focus and scroll.\n                        // TODO-APP: might need to disable this for Fast Refresh.\n                        focusAndScrollRef: {\n                            apply: false\n                        },\n                        cache: cache,\n                        prefetchCache: state.prefetchCache,\n                        tree: mutable.patchedTree\n                    };\n                }\n                if (!cache.data) {\n                    // Fetch data from the root of the tree.\n                    cache.data = createRecordFromThenable((0, _appRouter).fetchServerResponse(new URL(href, location.origin), [\n                        state.tree[0],\n                        state.tree[1],\n                        state.tree[2],\n                        \"refetch\"\n                    ]));\n                }\n                const [flightData, canonicalUrlOverride] = readRecordValue(cache.data);\n                // Handle case when navigating to page in `pages` from `app`\n                if (typeof flightData === \"string\") {\n                    return {\n                        canonicalUrl: flightData,\n                        pushRef: {\n                            pendingPush: true,\n                            mpaNavigation: true\n                        },\n                        focusAndScrollRef: {\n                            apply: false\n                        },\n                        cache: state.cache,\n                        prefetchCache: state.prefetchCache,\n                        tree: state.tree\n                    };\n                }\n                // Remove cache.data as it has been resolved at this point.\n                cache.data = null;\n                // TODO-APP: Currently the Flight data can only have one item but in the future it can have multiple paths.\n                const flightDataPath = flightData[0];\n                // FlightDataPath with more than two items means unexpected Flight data was returned\n                if (flightDataPath.length !== 3) {\n                    // TODO-APP: handle this case better\n                    console.log(\"REFRESH FAILED\");\n                    return state;\n                }\n                // Given the path can only have two items the items are only the router state and subTreeData for the root.\n                const [treePatch, subTreeData, head] = flightDataPath;\n                const newTree = applyRouterStatePatchToTree([\n                    \"\"\n                ], state.tree, treePatch);\n                if (newTree === null) {\n                    throw new Error(\"SEGMENT MISMATCH\");\n                }\n                const canonicalUrlOverrideHref = canonicalUrlOverride ? createHrefFromUrl(canonicalUrlOverride) : undefined;\n                if (canonicalUrlOverride) {\n                    mutable.canonicalUrlOverride = canonicalUrlOverrideHref;\n                }\n                mutable.previousTree = state.tree;\n                mutable.patchedTree = newTree;\n                mutable.mpaNavigation = isNavigatingToNewRootLayout(state.tree, newTree);\n                // Set subTreeData for the root node of the cache.\n                cache.status = _appRouterContext.CacheStates.READY;\n                cache.subTreeData = subTreeData;\n                fillLazyItemsTillLeafWithHead(cache, state.cache, treePatch, head);\n                return {\n                    // Set href, this doesn't reuse the state.canonicalUrl as because of concurrent rendering the href might change between dispatching and applying.\n                    canonicalUrl: canonicalUrlOverrideHref ? canonicalUrlOverrideHref : href,\n                    // set pendingPush (always false in this case).\n                    pushRef: state.pushRef,\n                    // TODO-APP: might need to disable this for Fast Refresh.\n                    focusAndScrollRef: {\n                        apply: false\n                    },\n                    // Apply patched cache.\n                    cache: cache,\n                    prefetchCache: state.prefetchCache,\n                    // Apply patched router state.\n                    tree: newTree\n                };\n            }\n        case ACTION_PREFETCH:\n            {\n                const { url , serverResponse  } = action;\n                const [flightData, canonicalUrlOverride] = serverResponse;\n                if (typeof flightData === \"string\") {\n                    return state;\n                }\n                const href = createHrefFromUrl(url);\n                // TODO-APP: Currently the Flight data can only have one item but in the future it can have multiple paths.\n                const flightDataPath = flightData[0];\n                // The one before last item is the router state tree patch\n                const [treePatch] = flightDataPath.slice(-3);\n                const flightSegmentPath = flightDataPath.slice(0, -3);\n                const newTree = applyRouterStatePatchToTree([\n                    \"\",\n                    ...flightSegmentPath\n                ], state.tree, treePatch);\n                // Patch did not apply correctly\n                if (newTree === null) {\n                    return state;\n                }\n                // Create new tree based on the flightSegmentPath and router state patch\n                state.prefetchCache.set(href, {\n                    flightData,\n                    // Create new tree based on the flightSegmentPath and router state patch\n                    tree: newTree,\n                    canonicalUrlOverride\n                });\n                return state;\n            }\n        // This case should never be hit as dispatch is strongly typed.\n        default:\n            throw new Error(\"Unknown action\");\n    }\n}\nfunction serverReducer(state, _action) {\n    return state;\n}\nconst reducer =  false ? 0 : clientReducer;\nexports.reducer = reducer;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTMuMS41X3JlYWN0LWRvbUAxOC4yLjArcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVkdWNlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCx5QkFBeUIsR0FBR0U7QUFDNUJGLGVBQWUsR0FBR0EsdUJBQXVCLEdBQUdBLDJCQUEyQixHQUFHQSxzQkFBc0IsR0FBR0EsdUJBQXVCLEdBQUdBLHNCQUFzQixHQUFHLEtBQUs7QUFDM0osSUFBSVMsV0FBV0MsdUtBQStDO0FBQzlELElBQUlFLG9CQUFvQkYsbUJBQU9BLENBQUMsZ0xBQXFDO0FBQ3JFLElBQUlHLGlCQUFpQkgsbUJBQU9BLENBQUMsZ0tBQWtCO0FBQy9DLElBQUlJLGFBQWFKLG1CQUFPQSxDQUFDLHdKQUFjO0FBQ3ZDOztDQUVDLEdBQUcsNENBQTRDO0FBQ2hELFNBQVNLLHlCQUF5QkMsUUFBUSxFQUFFO0lBQ3hDQSxTQUFTQyxNQUFNLEdBQUc7SUFDbEJELFNBQVNFLElBQUksQ0FBQyxDQUFDakIsUUFBUTtRQUNuQixJQUFJZSxTQUFTQyxNQUFNLEtBQUssV0FBVztZQUMvQkQsU0FBU0MsTUFBTSxHQUFHO1lBQ2xCRCxTQUFTZixLQUFLLEdBQUdBO1FBQ3JCLENBQUM7SUFDTCxHQUFHLENBQUNrQixNQUFNO1FBQ04sSUFBSUgsU0FBU0MsTUFBTSxLQUFLLFdBQVc7WUFDL0JELFNBQVNDLE1BQU0sR0FBRztZQUNsQkQsU0FBU2YsS0FBSyxHQUFHa0I7UUFDckIsQ0FBQztJQUNMO0lBQ0EsT0FBT0g7QUFDWDtBQUNBOztDQUVDLEdBQUcsU0FBU0ksZ0JBQWdCSixRQUFRLEVBQUU7SUFDbkMsa0NBQWtDO0lBQ2xDLElBQUlBLFNBQVNDLE1BQU0sS0FBSyxhQUFhO1FBQ2pDLGtDQUFrQztRQUNs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L0JvSixPQUFPcEosT0FBTyxHQUFHQSxRQUFRVyxPQUFPO0FBQ2xDLENBQUMsQ0FFRCxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTMuMS41X3JlYWN0LWRvbUAxOC4yLjArcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVkdWNlci5qcz9hMDEyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jcmVhdGVIcmVmRnJvbVVybCA9IGNyZWF0ZUhyZWZGcm9tVXJsO1xuZXhwb3J0cy5yZWR1Y2VyID0gZXhwb3J0cy5BQ1RJT05fUFJFRkVUQ0ggPSBleHBvcnRzLkFDVElPTl9TRVJWRVJfUEFUQ0ggPSBleHBvcnRzLkFDVElPTl9SRVNUT1JFID0gZXhwb3J0cy5BQ1RJT05fTkFWSUdBVEUgPSBleHBvcnRzLkFDVElPTl9SRUZSRVNIID0gdm9pZCAwO1xudmFyIF9leHRlbmRzID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2V4dGVuZHMuanNcIikuZGVmYXVsdDtcbnZhciBfYXBwUm91dGVyQ29udGV4dCA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dFwiKTtcbnZhciBfbWF0Y2hTZWdtZW50cyA9IHJlcXVpcmUoXCIuL21hdGNoLXNlZ21lbnRzXCIpO1xudmFyIF9hcHBSb3V0ZXIgPSByZXF1aXJlKFwiLi9hcHAtcm91dGVyXCIpO1xuLyoqXG4gKiBDcmVhdGUgZGF0YSBmZXRjaGluZyByZWNvcmQgZm9yIFByb21pc2UuXG4gKi8gLy8gVE9ETy1BUFA6IGNoYW5nZSBgYW55YCB0byB0eXBlIGluZmVyZW5jZS5cbmZ1bmN0aW9uIGNyZWF0ZVJlY29yZEZyb21UaGVuYWJsZSh0aGVuYWJsZSkge1xuICAgIHRoZW5hYmxlLnN0YXR1cyA9ICdwZW5kaW5nJztcbiAgICB0aGVuYWJsZS50aGVuKCh2YWx1ZSk9PntcbiAgICAgICAgaWYgKHRoZW5hYmxlLnN0YXR1cyA9PT0gJ3BlbmRpbmcnKSB7XG4gICAgICAgICAgICB0aGVuYWJsZS5zdGF0dXMgPSAnZnVsZmlsbGVkJztcbiAgICAgICAgICAgIHRoZW5hYmxlLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LCAoZXJyKT0+e1xuICAgICAgICBpZiAodGhlbmFibGUuc3RhdHVzID09PSAncGVuZGluZycpIHtcbiAgICAgICAgICAgIHRoZW5hYmxlLnN0YXR1cyA9ICdyZWplY3RlZCc7XG4gICAgICAgICAgICB0aGVuYWJsZS52YWx1ZSA9IGVycjtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGVuYWJsZTtcbn1cbi8qKlxuICogUmVhZCByZWNvcmQgdmFsdWUgb3IgdGhyb3cgUHJvbWlzZSBpZiBpdCdzIG5vdCByZXNvbHZlZCB5ZXQuXG4gKi8gZnVuY3Rpb24gcmVhZFJlY29yZFZhbHVlKHRoZW5hYmxlKSB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPOiBmaXggdHlwZVxuICAgIGlmICh0aGVuYWJsZS5zdGF0dXMgPT09ICdmdWxmaWxsZWQnKSB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETzogZml4IHR5cGVcbiAgICAgICAgcmV0dXJuIHRoZW5hYmxlLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHRoZW5hYmxlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUhyZWZGcm9tVXJsKHVybCkge1xuICAgIHJldHVybiB1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoICsgdXJsLmhhc2g7XG59XG4vKipcbiAqIEludmFsaWRhdGUgY2FjaGUgb25lIGxldmVsIGRvd24gZnJvbSB0aGUgcm91dGVyIHN0YXRlLlxuICovIGZ1bmN0aW9uIGludmFsaWRhdGVDYWNoZUJ5Um91dGVyU3RhdGUobmV3Q2FjaGUsIGV4aXN0aW5nQ2FjaGUsIHJvdXRlclN0YXRlKSB7XG4gICAgLy8gUmVtb3ZlIHNlZ21lbnQgdGhhdCB3ZSBnb3QgZGF0YSBmb3Igc28gdGhhdCBpdCBpcyBmaWxsZWQgaW4gZHVyaW5nIHJlbmRlcmluZyBvZiBzdWJUcmVlRGF0YS5cbiAgICBmb3IoY29uc3Qga2V5IGluIHJvdXRlclN0YXRlWzFdKXtcbiAgICAgICAgY29uc3Qgc2VnbWVudEZvclBhcmFsbGVsUm91dGUgPSByb3V0ZXJTdGF0ZVsxXVtrZXldWzBdO1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9IEFycmF5LmlzQXJyYXkoc2VnbWVudEZvclBhcmFsbGVsUm91dGUpID8gc2VnbWVudEZvclBhcmFsbGVsUm91dGVbMV0gOiBzZWdtZW50Rm9yUGFyYWxsZWxSb3V0ZTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdQYXJhbGxlbFJvdXRlc0NhY2hlTm9kZSA9IGV4aXN0aW5nQ2FjaGUucGFyYWxsZWxSb3V0ZXMuZ2V0KGtleSk7XG4gICAgICAgIGlmIChleGlzdGluZ1BhcmFsbGVsUm91dGVzQ2FjaGVOb2RlKSB7XG4gICAgICAgICAgICBsZXQgcGFyYWxsZWxSb3V0ZUNhY2hlTm9kZSA9IG5ldyBNYXAoZXhpc3RpbmdQYXJhbGxlbFJvdXRlc0NhY2hlTm9kZSk7XG4gICAgICAgICAgICBwYXJhbGxlbFJvdXRlQ2FjaGVOb2RlLmRlbGV0ZShjYWNoZUtleSk7XG4gICAgICAgICAgICBuZXdDYWNoZS5wYXJhbGxlbFJvdXRlcy5zZXQoa2V5LCBwYXJhbGxlbFJvdXRlQ2FjaGVOb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkKG5ld0NhY2hlLCBleGlzdGluZ0NhY2hlLCByb3V0ZXJTdGF0ZSwgaGVhZCkge1xuICAgIGNvbnN0IGlzTGFzdFNlZ21lbnQgPSBPYmplY3Qua2V5cyhyb3V0ZXJTdGF0ZVsxXSkubGVuZ3RoID09PSAwO1xuICAgIGlmIChpc0xhc3RTZWdtZW50KSB7XG4gICAgICAgIG5ld0NhY2hlLmhlYWQgPSBoZWFkO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFJlbW92ZSBzZWdtZW50IHRoYXQgd2UgZ290IGRhdGEgZm9yIHNvIHRoYXQgaXQgaXMgZmlsbGVkIGluIGR1cmluZyByZW5kZXJpbmcgb2Ygc3ViVHJlZURhdGEuXG4gICAgZm9yKGNvbnN0IGtleSBpbiByb3V0ZXJTdGF0ZVsxXSl7XG4gICAgICAgIGNvbnN0IHBhcmFsbGVsUm91dGVTdGF0ZSA9IHJvdXRlclN0YXRlWzFdW2tleV07XG4gICAgICAgIGNvbnN0IHNlZ21lbnRGb3JQYXJhbGxlbFJvdXRlID0gcGFyYWxsZWxSb3V0ZVN0YXRlWzBdO1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9IEFycmF5LmlzQXJyYXkoc2VnbWVudEZvclBhcmFsbGVsUm91dGUpID8gc2VnbWVudEZvclBhcmFsbGVsUm91dGVbMV0gOiBzZWdtZW50Rm9yUGFyYWxsZWxSb3V0ZTtcbiAgICAgICAgaWYgKGV4aXN0aW5nQ2FjaGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nUGFyYWxsZWxSb3V0ZXNDYWNoZU5vZGUgPSBleGlzdGluZ0NhY2hlLnBhcmFsbGVsUm91dGVzLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nUGFyYWxsZWxSb3V0ZXNDYWNoZU5vZGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGFyYWxsZWxSb3V0ZUNhY2hlTm9kZSA9IG5ldyBNYXAoZXhpc3RpbmdQYXJhbGxlbFJvdXRlc0NhY2hlTm9kZSk7XG4gICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZUNhY2hlTm9kZS5kZWxldGUoY2FjaGVLZXkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0NhY2hlTm9kZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5MQVpZX0lOSVRJQUxJWkVELFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBzdWJUcmVlRGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZUNhY2hlTm9kZS5zZXQoY2FjaGVLZXksIG5ld0NhY2hlTm9kZSk7XG4gICAgICAgICAgICAgICAgZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQobmV3Q2FjaGVOb2RlLCB1bmRlZmluZWQsIHBhcmFsbGVsUm91dGVTdGF0ZSwgaGVhZCk7XG4gICAgICAgICAgICAgICAgbmV3Q2FjaGUucGFyYWxsZWxSb3V0ZXMuc2V0KGtleSwgcGFyYWxsZWxSb3V0ZUNhY2hlTm9kZSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3Q2FjaGVOb2RlID0ge1xuICAgICAgICAgICAgc3RhdHVzOiBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5MQVpZX0lOSVRJQUxJWkVELFxuICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgIHN1YlRyZWVEYXRhOiBudWxsLFxuICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoKVxuICAgICAgICB9O1xuICAgICAgICBuZXdDYWNoZS5wYXJhbGxlbFJvdXRlcy5zZXQoa2V5LCBuZXcgTWFwKFtcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBjYWNoZUtleSxcbiAgICAgICAgICAgICAgICBuZXdDYWNoZU5vZGVcbiAgICAgICAgICAgIF1cbiAgICAgICAgXSkpO1xuICAgICAgICBmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZChuZXdDYWNoZU5vZGUsIHVuZGVmaW5lZCwgcGFyYWxsZWxSb3V0ZVN0YXRlLCBoZWFkKTtcbiAgICB9XG59XG4vKipcbiAqIEZpbGwgY2FjaGUgd2l0aCBzdWJUcmVlRGF0YSBiYXNlZCBvbiBmbGlnaHREYXRhUGF0aFxuICovIGZ1bmN0aW9uIGZpbGxDYWNoZVdpdGhOZXdTdWJUcmVlRGF0YShuZXdDYWNoZSwgZXhpc3RpbmdDYWNoZSwgZmxpZ2h0RGF0YVBhdGgpIHtcbiAgICBjb25zdCBpc0xhc3RFbnRyeSA9IGZsaWdodERhdGFQYXRoLmxlbmd0aCA8PSA1O1xuICAgIGNvbnN0IFtwYXJhbGxlbFJvdXRlS2V5LCBzZWdtZW50XSA9IGZsaWdodERhdGFQYXRoO1xuICAgIGNvbnN0IHNlZ21lbnRGb3JDYWNoZSA9IEFycmF5LmlzQXJyYXkoc2VnbWVudCkgPyBzZWdtZW50WzFdIDogc2VnbWVudDtcbiAgICBjb25zdCBleGlzdGluZ0NoaWxkU2VnbWVudE1hcCA9IGV4aXN0aW5nQ2FjaGUucGFyYWxsZWxSb3V0ZXMuZ2V0KHBhcmFsbGVsUm91dGVLZXkpO1xuICAgIGlmICghZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXApIHtcbiAgICAgICAgLy8gQmFpbG91dCBiZWNhdXNlIHRoZSBleGlzdGluZyBjYWNoZSBkb2VzIG5vdCBoYXZlIHRoZSBwYXRoIHRvIHRoZSBsZWFmIG5vZGVcbiAgICAgICAgLy8gV2lsbCB0cmlnZ2VyIGxhenkgZmV0Y2ggaW4gbGF5b3V0LXJvdXRlciBiZWNhdXNlIG9mIG1pc3Npbmcgc2VnbWVudFxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBjaGlsZFNlZ21lbnRNYXAgPSBuZXdDYWNoZS5wYXJhbGxlbFJvdXRlcy5nZXQocGFyYWxsZWxSb3V0ZUtleSk7XG4gICAgaWYgKCFjaGlsZFNlZ21lbnRNYXAgfHwgY2hpbGRTZWdtZW50TWFwID09PSBleGlzdGluZ0NoaWxkU2VnbWVudE1hcCkge1xuICAgICAgICBjaGlsZFNlZ21lbnRNYXAgPSBuZXcgTWFwKGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwKTtcbiAgICAgICAgbmV3Q2FjaGUucGFyYWxsZWxSb3V0ZXMuc2V0KHBhcmFsbGVsUm91dGVLZXksIGNoaWxkU2VnbWVudE1hcCk7XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUgPSBleGlzdGluZ0NoaWxkU2VnbWVudE1hcC5nZXQoc2VnbWVudEZvckNhY2hlKTtcbiAgICBsZXQgY2hpbGRDYWNoZU5vZGUgPSBjaGlsZFNlZ21lbnRNYXAuZ2V0KHNlZ21lbnRGb3JDYWNoZSk7XG4gICAgaWYgKGlzTGFzdEVudHJ5KSB7XG4gICAgICAgIGlmICghY2hpbGRDYWNoZU5vZGUgfHwgIWNoaWxkQ2FjaGVOb2RlLmRhdGEgfHwgY2hpbGRDYWNoZU5vZGUgPT09IGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUpIHtcbiAgICAgICAgICAgIGNoaWxkQ2FjaGVOb2RlID0ge1xuICAgICAgICAgICAgICAgIHN0YXR1czogX2FwcFJvdXRlckNvbnRleHQuQ2FjaGVTdGF0ZXMuUkVBRFksXG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBzdWJUcmVlRGF0YTogZmxpZ2h0RGF0YVBhdGhbM10sXG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIHNlZ21lbnRzIG90aGVyIHRoYW4gdGhlIG9uZSB3ZSBnb3QgZGF0YSBmb3IgYXJlIHByZXNlcnZlZC5cbiAgICAgICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogZXhpc3RpbmdDaGlsZENhY2hlTm9kZSA/IG5ldyBNYXAoZXhpc3RpbmdDaGlsZENhY2hlTm9kZS5wYXJhbGxlbFJvdXRlcykgOiBuZXcgTWFwKClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdDaGlsZENhY2hlTm9kZSkge1xuICAgICAgICAgICAgICAgIGludmFsaWRhdGVDYWNoZUJ5Um91dGVyU3RhdGUoY2hpbGRDYWNoZU5vZGUsIGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUsIGZsaWdodERhdGFQYXRoWzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkKGNoaWxkQ2FjaGVOb2RlLCBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlLCBmbGlnaHREYXRhUGF0aFsyXSwgZmxpZ2h0RGF0YVBhdGhbNF0pO1xuICAgICAgICAgICAgY2hpbGRTZWdtZW50TWFwLnNldChzZWdtZW50Rm9yQ2FjaGUsIGNoaWxkQ2FjaGVOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghY2hpbGRDYWNoZU5vZGUgfHwgIWV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUpIHtcbiAgICAgICAgLy8gQmFpbG91dCBiZWNhdXNlIHRoZSBleGlzdGluZyBjYWNoZSBkb2VzIG5vdCBoYXZlIHRoZSBwYXRoIHRvIHRoZSBsZWFmIG5vZGVcbiAgICAgICAgLy8gV2lsbCB0cmlnZ2VyIGxhenkgZmV0Y2ggaW4gbGF5b3V0LXJvdXRlciBiZWNhdXNlIG9mIG1pc3Npbmcgc2VnbWVudFxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjaGlsZENhY2hlTm9kZSA9PT0gZXhpc3RpbmdDaGlsZENhY2hlTm9kZSkge1xuICAgICAgICBjaGlsZENhY2hlTm9kZSA9IHtcbiAgICAgICAgICAgIHN0YXR1czogY2hpbGRDYWNoZU5vZGUuc3RhdHVzLFxuICAgICAgICAgICAgZGF0YTogY2hpbGRDYWNoZU5vZGUuZGF0YSxcbiAgICAgICAgICAgIHN1YlRyZWVEYXRhOiBjaGlsZENhY2hlTm9kZS5zdWJUcmVlRGF0YSxcbiAgICAgICAgICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKGNoaWxkQ2FjaGVOb2RlLnBhcmFsbGVsUm91dGVzKVxuICAgICAgICB9O1xuICAgICAgICBjaGlsZFNlZ21lbnRNYXAuc2V0KHNlZ21lbnRGb3JDYWNoZSwgY2hpbGRDYWNoZU5vZGUpO1xuICAgIH1cbiAgICBmaWxsQ2FjaGVXaXRoTmV3U3ViVHJlZURhdGEoY2hpbGRDYWNoZU5vZGUsIGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUsIGZsaWdodERhdGFQYXRoLnNsaWNlKDIpKTtcbn1cbi8qKlxuICogRmlsbCBjYWNoZSB1cCB0byB0aGUgZW5kIG9mIHRoZSBmbGlnaHRTZWdtZW50UGF0aCwgaW52YWxpZGF0aW5nIGFueXRoaW5nIGJlbG93IGl0LlxuICovIGZ1bmN0aW9uIGludmFsaWRhdGVDYWNoZUJlbG93RmxpZ2h0U2VnbWVudFBhdGgobmV3Q2FjaGUsIGV4aXN0aW5nQ2FjaGUsIGZsaWdodFNlZ21lbnRQYXRoKSB7XG4gICAgY29uc3QgaXNMYXN0RW50cnkgPSBmbGlnaHRTZWdtZW50UGF0aC5sZW5ndGggPD0gMjtcbiAgICBjb25zdCBbcGFyYWxsZWxSb3V0ZUtleSwgc2VnbWVudF0gPSBmbGlnaHRTZWdtZW50UGF0aDtcbiAgICBjb25zdCBzZWdtZW50Rm9yQ2FjaGUgPSBBcnJheS5pc0FycmF5KHNlZ21lbnQpID8gc2VnbWVudFsxXSA6IHNlZ21lbnQ7XG4gICAgY29uc3QgZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXAgPSBleGlzdGluZ0NhY2hlLnBhcmFsbGVsUm91dGVzLmdldChwYXJhbGxlbFJvdXRlS2V5KTtcbiAgICBpZiAoIWV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwKSB7XG4gICAgICAgIC8vIEJhaWxvdXQgYmVjYXVzZSB0aGUgZXhpc3RpbmcgY2FjaGUgZG9lcyBub3QgaGF2ZSB0aGUgcGF0aCB0byB0aGUgbGVhZiBub2RlXG4gICAgICAgIC8vIFdpbGwgdHJpZ2dlciBsYXp5IGZldGNoIGluIGxheW91dC1yb3V0ZXIgYmVjYXVzZSBvZiBtaXNzaW5nIHNlZ21lbnRcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgY2hpbGRTZWdtZW50TWFwID0gbmV3Q2FjaGUucGFyYWxsZWxSb3V0ZXMuZ2V0KHBhcmFsbGVsUm91dGVLZXkpO1xuICAgIGlmICghY2hpbGRTZWdtZW50TWFwIHx8IGNoaWxkU2VnbWVudE1hcCA9PT0gZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXApIHtcbiAgICAgICAgY2hpbGRTZWdtZW50TWFwID0gbmV3IE1hcChleGlzdGluZ0NoaWxkU2VnbWVudE1hcCk7XG4gICAgICAgIG5ld0NhY2hlLnBhcmFsbGVsUm91dGVzLnNldChwYXJhbGxlbFJvdXRlS2V5LCBjaGlsZFNlZ21lbnRNYXApO1xuICAgIH1cbiAgICAvLyBJbiBjYXNlIG9mIGxhc3QgZW50cnkgZG9uJ3QgY29weSBmdXJ0aGVyIGRvd24uXG4gICAgaWYgKGlzTGFzdEVudHJ5KSB7XG4gICAgICAgIGNoaWxkU2VnbWVudE1hcC5kZWxldGUoc2VnbWVudEZvckNhY2hlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlID0gZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXAuZ2V0KHNlZ21lbnRGb3JDYWNoZSk7XG4gICAgbGV0IGNoaWxkQ2FjaGVOb2RlID0gY2hpbGRTZWdtZW50TWFwLmdldChzZWdtZW50Rm9yQ2FjaGUpO1xuICAgIGlmICghY2hpbGRDYWNoZU5vZGUgfHwgIWV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUpIHtcbiAgICAgICAgLy8gQmFpbG91dCBiZWNhdXNlIHRoZSBleGlzdGluZyBjYWNoZSBkb2VzIG5vdCBoYXZlIHRoZSBwYXRoIHRvIHRoZSBsZWFmIG5vZGVcbiAgICAgICAgLy8gV2lsbCB0cmlnZ2VyIGxhenkgZmV0Y2ggaW4gbGF5b3V0LXJvdXRlciBiZWNhdXNlIG9mIG1pc3Npbmcgc2VnbWVudFxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjaGlsZENhY2hlTm9kZSA9PT0gZXhpc3RpbmdDaGlsZENhY2hlTm9kZSkge1xuICAgICAgICBjaGlsZENhY2hlTm9kZSA9IHtcbiAgICAgICAgICAgIHN0YXR1czogY2hpbGRDYWNoZU5vZGUuc3RhdHVzLFxuICAgICAgICAgICAgZGF0YTogY2hpbGRDYWNoZU5vZGUuZGF0YSxcbiAgICAgICAgICAgIHN1YlRyZWVEYXRhOiBjaGlsZENhY2hlTm9kZS5zdWJUcmVlRGF0YSxcbiAgICAgICAgICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKGNoaWxkQ2FjaGVOb2RlLnBhcmFsbGVsUm91dGVzKVxuICAgICAgICB9O1xuICAgICAgICBjaGlsZFNlZ21lbnRNYXAuc2V0KHNlZ21lbnRGb3JDYWNoZSwgY2hpbGRDYWNoZU5vZGUpO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlQ2FjaGVCZWxvd0ZsaWdodFNlZ21lbnRQYXRoKGNoaWxkQ2FjaGVOb2RlLCBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlLCBmbGlnaHRTZWdtZW50UGF0aC5zbGljZSgyKSk7XG59XG4vKipcbiAqIEtpY2sgb2ZmIGZldGNoIGJhc2VkIG9uIHRoZSBjb21tb24gbGF5b3V0IGJldHdlZW4gdHdvIHJvdXRlcy4gRmlsbCBjYWNoZSB3aXRoIGRhdGEgcHJvcGVydHkgaG9sZGluZyB0aGUgaW4tcHJvZ3Jlc3MgZmV0Y2guXG4gKi8gZnVuY3Rpb24gZmlsbENhY2hlV2l0aERhdGFQcm9wZXJ0eShuZXdDYWNoZSwgZXhpc3RpbmdDYWNoZSwgc2VnbWVudHMsIGZldGNoUmVzcG9uc2UpIHtcbiAgICBjb25zdCBpc0xhc3RFbnRyeSA9IHNlZ21lbnRzLmxlbmd0aCA9PT0gMTtcbiAgICBjb25zdCBwYXJhbGxlbFJvdXRlS2V5ID0gJ2NoaWxkcmVuJztcbiAgICBjb25zdCBbc2VnbWVudF0gPSBzZWdtZW50cztcbiAgICBjb25zdCBleGlzdGluZ0NoaWxkU2VnbWVudE1hcCA9IGV4aXN0aW5nQ2FjaGUucGFyYWxsZWxSb3V0ZXMuZ2V0KHBhcmFsbGVsUm91dGVLZXkpO1xuICAgIGlmICghZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXApIHtcbiAgICAgICAgLy8gQmFpbG91dCBiZWNhdXNlIHRoZSBleGlzdGluZyBjYWNoZSBkb2VzIG5vdCBoYXZlIHRoZSBwYXRoIHRvIHRoZSBsZWFmIG5vZGVcbiAgICAgICAgLy8gV2lsbCB0cmlnZ2VyIGxhenkgZmV0Y2ggaW4gbGF5b3V0LXJvdXRlciBiZWNhdXNlIG9mIG1pc3Npbmcgc2VnbWVudFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYmFpbE9wdGltaXN0aWM6IHRydWVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbGV0IGNoaWxkU2VnbWVudE1hcCA9IG5ld0NhY2hlLnBhcmFsbGVsUm91dGVzLmdldChwYXJhbGxlbFJvdXRlS2V5KTtcbiAgICBpZiAoIWNoaWxkU2VnbWVudE1hcCB8fCBjaGlsZFNlZ21lbnRNYXAgPT09IGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwKSB7XG4gICAgICAgIGNoaWxkU2VnbWVudE1hcCA9IG5ldyBNYXAoZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXApO1xuICAgICAgICBuZXdDYWNoZS5wYXJhbGxlbFJvdXRlcy5zZXQocGFyYWxsZWxSb3V0ZUtleSwgY2hpbGRTZWdtZW50TWFwKTtcbiAgICB9XG4gICAgY29uc3QgZXhpc3RpbmdDaGlsZENhY2hlTm9kZSA9IGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwLmdldChzZWdtZW50KTtcbiAgICBsZXQgY2hpbGRDYWNoZU5vZGUgPSBjaGlsZFNlZ21lbnRNYXAuZ2V0KHNlZ21lbnQpO1xuICAgIC8vIEluIGNhc2Ugb2YgbGFzdCBzZWdtZW50IHN0YXJ0IG9mZiB0aGUgZmV0Y2ggYXQgdGhpcyBsZXZlbCBhbmQgZG9uJ3QgY29weSBmdXJ0aGVyIGRvd24uXG4gICAgaWYgKGlzTGFzdEVudHJ5KSB7XG4gICAgICAgIGlmICghY2hpbGRDYWNoZU5vZGUgfHwgIWNoaWxkQ2FjaGVOb2RlLmRhdGEgfHwgY2hpbGRDYWNoZU5vZGUgPT09IGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUpIHtcbiAgICAgICAgICAgIGNoaWxkU2VnbWVudE1hcC5zZXQoc2VnbWVudCwge1xuICAgICAgICAgICAgICAgIHN0YXR1czogX2FwcFJvdXRlckNvbnRleHQuQ2FjaGVTdGF0ZXMuREFUQV9GRVRDSCxcbiAgICAgICAgICAgICAgICBkYXRhOiBmZXRjaFJlc3BvbnNlKCksXG4gICAgICAgICAgICAgICAgc3ViVHJlZURhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWNoaWxkQ2FjaGVOb2RlIHx8ICFleGlzdGluZ0NoaWxkQ2FjaGVOb2RlKSB7XG4gICAgICAgIC8vIFN0YXJ0IGZldGNoIGluIHRoZSBwbGFjZSB3aGVyZSB0aGUgZXhpc3RpbmcgY2FjaGUgZG9lc24ndCBoYXZlIHRoZSBkYXRhIHlldC5cbiAgICAgICAgaWYgKCFjaGlsZENhY2hlTm9kZSkge1xuICAgICAgICAgICAgY2hpbGRTZWdtZW50TWFwLnNldChzZWdtZW50LCB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5EQVRBX0ZFVENILFxuICAgICAgICAgICAgICAgIGRhdGE6IGZldGNoUmVzcG9uc2UoKSxcbiAgICAgICAgICAgICAgICBzdWJUcmVlRGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcCgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjaGlsZENhY2hlTm9kZSA9PT0gZXhpc3RpbmdDaGlsZENhY2hlTm9kZSkge1xuICAgICAgICBjaGlsZENhY2hlTm9kZSA9IHtcbiAgICAgICAgICAgIHN0YXR1czogY2hpbGRDYWNoZU5vZGUuc3RhdHVzLFxuICAgICAgICAgICAgZGF0YTogY2hpbGRDYWNoZU5vZGUuZGF0YSxcbiAgICAgICAgICAgIHN1YlRyZWVEYXRhOiBjaGlsZENhY2hlTm9kZS5zdWJUcmVlRGF0YSxcbiAgICAgICAgICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKGNoaWxkQ2FjaGVOb2RlLnBhcmFsbGVsUm91dGVzKVxuICAgICAgICB9O1xuICAgICAgICBjaGlsZFNlZ21lbnRNYXAuc2V0KHNlZ21lbnQsIGNoaWxkQ2FjaGVOb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbGxDYWNoZVdpdGhEYXRhUHJvcGVydHkoY2hpbGRDYWNoZU5vZGUsIGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUsIHNlZ21lbnRzLnNsaWNlKDEpLCBmZXRjaFJlc3BvbnNlKTtcbn1cbi8qKlxuICogQ3JlYXRlIG9wdGltaXN0aWMgdmVyc2lvbiBvZiByb3V0ZXIgc3RhdGUgYmFzZWQgb24gdGhlIGV4aXN0aW5nIHJvdXRlciBzdGF0ZSBhbmQgc2VnbWVudHMuXG4gKiBUaGlzIGlzIHVzZWQgdG8gYWxsb3cgcmVuZGVyaW5nIGxheW91dC1yb3V0ZXJzIHVwIHRpbGwgdGhlIHBvaW50IHdoZXJlIGRhdGEgaXMgbWlzc2luZy5cbiAqLyBmdW5jdGlvbiBjcmVhdGVPcHRpbWlzdGljVHJlZShzZWdtZW50cywgZmxpZ2h0Um91dGVyU3RhdGUsIF9pc0ZpcnN0U2VnbWVudCwgcGFyZW50UmVmZXRjaCwgX2hyZWYpIHtcbiAgICBjb25zdCBbZXhpc3RpbmdTZWdtZW50LCBleGlzdGluZ1BhcmFsbGVsUm91dGVzXSA9IGZsaWdodFJvdXRlclN0YXRlIHx8IFtcbiAgICAgICAgbnVsbCxcbiAgICAgICAge30sIFxuICAgIF07XG4gICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzWzBdO1xuICAgIGNvbnN0IGlzTGFzdFNlZ21lbnQgPSBzZWdtZW50cy5sZW5ndGggPT09IDE7XG4gICAgY29uc3Qgc2VnbWVudE1hdGNoZXMgPSBleGlzdGluZ1NlZ21lbnQgIT09IG51bGwgJiYgKDAsIF9tYXRjaFNlZ21lbnRzKS5tYXRjaFNlZ21lbnQoZXhpc3RpbmdTZWdtZW50LCBzZWdtZW50KTtcbiAgICBjb25zdCBzaG91bGRSZWZldGNoVGhpc0xldmVsID0gIWZsaWdodFJvdXRlclN0YXRlIHx8ICFzZWdtZW50TWF0Y2hlcztcbiAgICBsZXQgcGFyYWxsZWxSb3V0ZXMgPSB7fTtcbiAgICBpZiAoZXhpc3RpbmdTZWdtZW50ICE9PSBudWxsICYmIHNlZ21lbnRNYXRjaGVzKSB7XG4gICAgICAgIHBhcmFsbGVsUm91dGVzID0gZXhpc3RpbmdQYXJhbGxlbFJvdXRlcztcbiAgICB9XG4gICAgbGV0IGNoaWxkVHJlZTtcbiAgICBpZiAoIWlzTGFzdFNlZ21lbnQpIHtcbiAgICAgICAgY29uc3QgY2hpbGRJdGVtID0gY3JlYXRlT3B0aW1pc3RpY1RyZWUoc2VnbWVudHMuc2xpY2UoMSksIHBhcmFsbGVsUm91dGVzID8gcGFyYWxsZWxSb3V0ZXMuY2hpbGRyZW4gOiBudWxsLCBmYWxzZSwgcGFyZW50UmVmZXRjaCB8fCBzaG91bGRSZWZldGNoVGhpc0xldmVsKTtcbiAgICAgICAgY2hpbGRUcmVlID0gY2hpbGRJdGVtO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbXG4gICAgICAgIHNlZ21lbnQsXG4gICAgICAgIF9leHRlbmRzKHt9LCBwYXJhbGxlbFJvdXRlcywgY2hpbGRUcmVlID8ge1xuICAgICAgICAgICAgY2hpbGRyZW46IGNoaWxkVHJlZVxuICAgICAgICB9IDoge30pLCBcbiAgICBdO1xuICAgIGlmICghcGFyZW50UmVmZXRjaCAmJiBzaG91bGRSZWZldGNoVGhpc0xldmVsKSB7XG4gICAgICAgIHJlc3VsdFszXSA9ICdyZWZldGNoJztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQXBwbHkgdGhlIHJvdXRlciBzdGF0ZSBmcm9tIHRoZSBGbGlnaHQgcmVzcG9uc2UuIENyZWF0ZXMgYSBuZXcgcm91dGVyIHN0YXRlIHRyZWUuXG4gKi8gZnVuY3Rpb24gYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlKGZsaWdodFNlZ21lbnRQYXRoLCBmbGlnaHRSb3V0ZXJTdGF0ZSwgdHJlZVBhdGNoKSB7XG4gICAgY29uc3QgW3NlZ21lbnQsIHBhcmFsbGVsUm91dGVzLCAsICwgaXNSb290TGF5b3V0XSA9IGZsaWdodFJvdXRlclN0YXRlO1xuICAgIC8vIFJvb3QgcmVmcmVzaFxuICAgIGlmIChmbGlnaHRTZWdtZW50UGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY29uc3QgdHJlZSA9IFtcbiAgICAgICAgICAgIC4uLnRyZWVQYXRjaFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICB9XG4gICAgY29uc3QgW2N1cnJlbnRTZWdtZW50LCBwYXJhbGxlbFJvdXRlS2V5XSA9IGZsaWdodFNlZ21lbnRQYXRoO1xuICAgIC8vIFRyZWUgcGF0aCByZXR1cm5lZCBmcm9tIHRoZSBzZXJ2ZXIgc2hvdWxkIGFsd2F5cyBtYXRjaCB1cCB3aXRoIHRoZSBjdXJyZW50IHRyZWUgaW4gdGhlIGJyb3dzZXJcbiAgICBpZiAoISgwLCBfbWF0Y2hTZWdtZW50cykubWF0Y2hTZWdtZW50KGN1cnJlbnRTZWdtZW50LCBzZWdtZW50KSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgbGFzdFNlZ21lbnQgPSBmbGlnaHRTZWdtZW50UGF0aC5sZW5ndGggPT09IDI7XG4gICAgbGV0IHBhcmFsbGVsUm91dGVQYXRjaDtcbiAgICBpZiAobGFzdFNlZ21lbnQpIHtcbiAgICAgICAgcGFyYWxsZWxSb3V0ZVBhdGNoID0gdHJlZVBhdGNoO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmFsbGVsUm91dGVQYXRjaCA9IGFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZShmbGlnaHRTZWdtZW50UGF0aC5zbGljZSgyKSwgcGFyYWxsZWxSb3V0ZXNbcGFyYWxsZWxSb3V0ZUtleV0sIHRyZWVQYXRjaCk7XG4gICAgICAgIGlmIChwYXJhbGxlbFJvdXRlUGF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRyZWUgPSBbXG4gICAgICAgIGZsaWdodFNlZ21lbnRQYXRoWzBdLFxuICAgICAgICBfZXh0ZW5kcyh7fSwgcGFyYWxsZWxSb3V0ZXMsIHtcbiAgICAgICAgICAgIFtwYXJhbGxlbFJvdXRlS2V5XTogcGFyYWxsZWxSb3V0ZVBhdGNoXG4gICAgICAgIH0pLCBcbiAgICBdO1xuICAgIC8vIEN1cnJlbnQgc2VnbWVudCBpcyB0aGUgcm9vdCBsYXlvdXRcbiAgICBpZiAoaXNSb290TGF5b3V0KSB7XG4gICAgICAgIHRyZWVbNF0gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdHJlZTtcbn1cbmZ1bmN0aW9uIHNob3VsZEhhcmROYXZpZ2F0ZShmbGlnaHRTZWdtZW50UGF0aCwgZmxpZ2h0Um91dGVyU3RhdGUsIHRyZWVQYXRjaCkge1xuICAgIGNvbnN0IFtzZWdtZW50LCBwYXJhbGxlbFJvdXRlc10gPSBmbGlnaHRSb3V0ZXJTdGF0ZTtcbiAgICAvLyBUT0RPLUFQUDogQ2hlY2sgaWYgYGFzYCBjYW4gYmUgcmVwbGFjZWQuXG4gICAgY29uc3QgW2N1cnJlbnRTZWdtZW50LCBwYXJhbGxlbFJvdXRlS2V5XSA9IGZsaWdodFNlZ21lbnRQYXRoO1xuICAgIC8vIENoZWNrIGlmIGN1cnJlbnQgc2VnbWVudCBtYXRjaGVzIHRoZSBleGlzdGluZyBzZWdtZW50LlxuICAgIGlmICghKDAsIF9tYXRjaFNlZ21lbnRzKS5tYXRjaFNlZ21lbnQoY3VycmVudFNlZ21lbnQsIHNlZ21lbnQpKSB7XG4gICAgICAgIC8vIElmIGR5bmFtaWMgcGFyYW1ldGVyIGluIHRyZWUgZG9lc24ndCBtYXRjaCB1cCB3aXRoIHNlZ21lbnQgcGF0aCBhIGhhcmQgbmF2aWdhdGlvbiBpcyB0cmlnZ2VyZWQuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnRTZWdtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGV4aXN0aW5nIHNlZ21lbnQgZGlkIG5vdCBtYXRjaCBzb2Z0IG5hdmlnYXRpb24gaXMgdHJpZ2dlcmVkLlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGxhc3RTZWdtZW50ID0gZmxpZ2h0U2VnbWVudFBhdGgubGVuZ3RoIDw9IDI7XG4gICAgaWYgKGxhc3RTZWdtZW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHNob3VsZEhhcmROYXZpZ2F0ZShmbGlnaHRTZWdtZW50UGF0aC5zbGljZSgyKSwgcGFyYWxsZWxSb3V0ZXNbcGFyYWxsZWxSb3V0ZUtleV0sIHRyZWVQYXRjaCk7XG59XG5mdW5jdGlvbiBpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQoY3VycmVudFRyZWUsIG5leHRUcmVlKSB7XG4gICAgLy8gQ29tcGFyZSBzZWdtZW50c1xuICAgIGNvbnN0IGN1cnJlbnRUcmVlU2VnbWVudCA9IGN1cnJlbnRUcmVlWzBdO1xuICAgIGNvbnN0IG5leHRUcmVlU2VnbWVudCA9IG5leHRUcmVlWzBdO1xuICAgIC8vIElmIGFueSBzZWdtZW50IGlzIGRpZmZlcmVudCBiZWZvcmUgd2UgZmluZCB0aGUgcm9vdCBsYXlvdXQsIHRoZSByb290IGxheW91dCBoYXMgY2hhbmdlZC5cbiAgICAvLyBFLmcuIC9zYW1lLyhncm91cDEpL2xheW91dC5qcyAtPiAvc2FtZS8oZ3JvdXAyKS9sYXlvdXQuanNcbiAgICAvLyBGaXJzdCBzZWdtZW50IGlzICdzYW1lJyBmb3IgYm90aCwga2VlcCBsb29raW5nLiAoZ3JvdXAxKSBjaGFuZ2VkIHRvIChncm91cDIpIGJlZm9yZSB0aGUgcm9vdCBsYXlvdXQgd2FzIGZvdW5kLCBpdCBtdXN0IGhhdmUgY2hhbmdlZC5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50VHJlZVNlZ21lbnQpICYmIEFycmF5LmlzQXJyYXkobmV4dFRyZWVTZWdtZW50KSkge1xuICAgICAgICAvLyBDb21wYXJlIGR5bmFtaWMgcGFyYW0gbmFtZSBhbmQgdHlwZSBidXQgaWdub3JlIHRoZSB2YWx1ZSwgZGlmZmVyZW50IHZhbHVlcyB3b3VsZCBub3QgYWZmZWN0IHRoZSBjdXJyZW50IHJvb3QgbGF5b3V0XG4gICAgICAgIC8vIC9bbmFtZV0gLSAvc2x1ZzEgYW5kIC9zbHVnMiwgYm90aCB2YWx1ZXMgKHNsdWcxICYgc2x1ZzIpIHN0aWxsIGhhcyB0aGUgc2FtZSBsYXlvdXQgL1tuYW1lXS9sYXlvdXQuanNcbiAgICAgICAgaWYgKGN1cnJlbnRUcmVlU2VnbWVudFswXSAhPT0gbmV4dFRyZWVTZWdtZW50WzBdIHx8IGN1cnJlbnRUcmVlU2VnbWVudFsyXSAhPT0gbmV4dFRyZWVTZWdtZW50WzJdKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY3VycmVudFRyZWVTZWdtZW50ICE9PSBuZXh0VHJlZVNlZ21lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIEN1cnJlbnQgdHJlZSByb290IGxheW91dCBmb3VuZFxuICAgIGlmIChjdXJyZW50VHJlZVs0XSkge1xuICAgICAgICAvLyBJZiB0aGUgbmV4dCB0cmVlIGRvZXNuJ3QgaGF2ZSB0aGUgcm9vdCBsYXlvdXQgZmxhZywgaXQgbXVzdCBoYXZlIGNoYW5nZWQuXG4gICAgICAgIHJldHVybiAhbmV4dFRyZWVbNF07XG4gICAgfVxuICAgIC8vIEN1cnJlbnQgdHJlZSAgZGlkbid0IGhhdmUgaXRzIHJvb3QgbGF5b3V0IGhlcmUsIG11c3QgaGF2ZSBjaGFuZ2VkLlxuICAgIGlmIChuZXh0VHJlZVs0XSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gV2UgY2FuJ3QgYXNzdW1lIGl0J3MgYHBhcmFsbGVsUm91dGVzLmNoaWxkcmVuYCBoZXJlIGluIGNhc2UgdGhlIHJvb3QgbGF5b3V0IGlzIGBhcHAvQHNvbWV0aGluZy9sYXlvdXQuanNgXG4gICAgLy8gQnV0IGl0J3Mgbm90IHBvc3NpYmxlIHRvIGJlIG1vcmUgdGhhbiBvbmUgcGFyYWxsZWxSb3V0ZXMgYmVmb3JlIHRoZSByb290IGxheW91dCBpcyBmb3VuZFxuICAgIC8vIFRPRE8tQVBQOiBjaGFuZ2UgdG8gdHJhdmVyc2UgYWxsIHBhcmFsbGVsIHJvdXRlc1xuICAgIGNvbnN0IGN1cnJlbnRUcmVlQ2hpbGQgPSBPYmplY3QudmFsdWVzKGN1cnJlbnRUcmVlWzFdKVswXTtcbiAgICBjb25zdCBuZXh0VHJlZUNoaWxkID0gT2JqZWN0LnZhbHVlcyhuZXh0VHJlZVsxXSlbMF07XG4gICAgaWYgKCFjdXJyZW50VHJlZUNoaWxkIHx8ICFuZXh0VHJlZUNoaWxkKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KGN1cnJlbnRUcmVlQ2hpbGQsIG5leHRUcmVlQ2hpbGQpO1xufVxuY29uc3QgQUNUSU9OX1JFRlJFU0ggPSAncmVmcmVzaCc7XG5leHBvcnRzLkFDVElPTl9SRUZSRVNIID0gQUNUSU9OX1JFRlJFU0g7XG5jb25zdCBBQ1RJT05fTkFWSUdBVEUgPSAnbmF2aWdhdGUnO1xuZXhwb3J0cy5BQ1RJT05fTkFWSUdBVEUgPSBBQ1RJT05fTkFWSUdBVEU7XG5jb25zdCBBQ1RJT05fUkVTVE9SRSA9ICdyZXN0b3JlJztcbmV4cG9ydHMuQUNUSU9OX1JFU1RPUkUgPSBBQ1RJT05fUkVTVE9SRTtcbmNvbnN0IEFDVElPTl9TRVJWRVJfUEFUQ0ggPSAnc2VydmVyLXBhdGNoJztcbmV4cG9ydHMuQUNUSU9OX1NFUlZFUl9QQVRDSCA9IEFDVElPTl9TRVJWRVJfUEFUQ0g7XG5jb25zdCBBQ1RJT05fUFJFRkVUQ0ggPSAncHJlZmV0Y2gnO1xuZXhwb3J0cy5BQ1RJT05fUFJFRkVUQ0ggPSBBQ1RJT05fUFJFRkVUQ0g7XG4vKipcbiAqIFJlZHVjZXIgdGhhdCBoYW5kbGVzIHRoZSBhcHAtcm91dGVyIHN0YXRlIHVwZGF0ZXMuXG4gKi8gZnVuY3Rpb24gY2xpZW50UmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgc3dpdGNoKGFjdGlvbi50eXBlKXtcbiAgICAgICAgY2FzZSBBQ1RJT05fTkFWSUdBVEU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB1cmwgLCBuYXZpZ2F0ZVR5cGUgLCBjYWNoZSAsIG11dGFibGUgLCBmb3JjZU9wdGltaXN0aWNOYXZpZ2F0aW9uICB9ID0gYWN0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGF0aG5hbWUgLCBzZWFyY2ggIH0gPSB1cmw7XG4gICAgICAgICAgICAgICAgY29uc3QgaHJlZiA9IGNyZWF0ZUhyZWZGcm9tVXJsKHVybCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGVuZGluZ1B1c2ggPSBuYXZpZ2F0ZVR5cGUgPT09ICdwdXNoJztcbiAgICAgICAgICAgICAgICBjb25zdCBpc0ZvckN1cnJlbnRUcmVlID0gSlNPTi5zdHJpbmdpZnkobXV0YWJsZS5wcmV2aW91c1RyZWUpID09PSBKU09OLnN0cmluZ2lmeShzdGF0ZS50cmVlKTtcbiAgICAgICAgICAgICAgICBpZiAobXV0YWJsZS5tcGFOYXZpZ2F0aW9uICYmIGlzRm9yQ3VycmVudFRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCBocmVmLlxuICAgICAgICAgICAgICAgICAgICAgICAgY2Fub25pY2FsVXJsOiBtdXRhYmxlLmNhbm9uaWNhbFVybE92ZXJyaWRlID8gbXV0YWJsZS5jYW5vbmljYWxVcmxPdmVycmlkZSA6IGhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1B1c2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXBhTmF2aWdhdGlvbjogbXV0YWJsZS5tcGFOYXZpZ2F0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsIG5hdmlnYXRpb24gcmVxdWlyZXMgc2Nyb2xsIGFuZCBmb2N1cyBtYW5hZ2VtZW50IHRvIHRyaWdnZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb2N1c0FuZFNjcm9sbFJlZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IGNhY2hlLlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGU6IHN0YXRlLmNhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmV0Y2hDYWNoZTogc3RhdGUucHJlZmV0Y2hDYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IHBhdGNoZWQgcm91dGVyIHN0YXRlLlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJlZTogc3RhdGUudHJlZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgY29uY3VycmVudCByZW5kZXJpbmcgLyBzdHJpY3QgbW9kZSBjYXNlIHdoZXJlIHRoZSBjYWNoZSBhbmQgdHJlZSB3ZXJlIGFscmVhZHkgcG9wdWxhdGVkLlxuICAgICAgICAgICAgICAgIGlmIChtdXRhYmxlLnBhdGNoZWRUcmVlICYmIGlzRm9yQ3VycmVudFRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCBocmVmLlxuICAgICAgICAgICAgICAgICAgICAgICAgY2Fub25pY2FsVXJsOiBtdXRhYmxlLmNhbm9uaWNhbFVybE92ZXJyaWRlID8gbXV0YWJsZS5jYW5vbmljYWxVcmxPdmVycmlkZSA6IGhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1B1c2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXBhTmF2aWdhdGlvbjogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGwgbmF2aWdhdGlvbiByZXF1aXJlcyBzY3JvbGwgYW5kIGZvY3VzIG1hbmFnZW1lbnQgdG8gdHJpZ2dlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHk6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlOiBtdXRhYmxlLnVzZUV4aXN0aW5nQ2FjaGUgPyBzdGF0ZS5jYWNoZSA6IGNhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmV0Y2hDYWNoZTogc3RhdGUucHJlZmV0Y2hDYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IHBhdGNoZWQgcm91dGVyIHN0YXRlLlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJlZTogbXV0YWJsZS5wYXRjaGVkVHJlZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwcmVmZXRjaFZhbHVlcyA9IHN0YXRlLnByZWZldGNoQ2FjaGUuZ2V0KGhyZWYpO1xuICAgICAgICAgICAgICAgIGlmIChwcmVmZXRjaFZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgb25lIGJlZm9yZSBsYXN0IGl0ZW0gaXMgdGhlIHJvdXRlciBzdGF0ZSB0cmVlIHBhdGNoXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZmxpZ2h0RGF0YSAsIHRyZWU6IG5ld1RyZWUgLCBjYW5vbmljYWxVcmxPdmVycmlkZSAsICB9ID0gcHJlZmV0Y2hWYWx1ZXM7XG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gbmF2aWdhdGluZyB0byBwYWdlIGluIGBwYWdlc2AgZnJvbSBgYXBwYFxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZsaWdodERhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbm9uaWNhbFVybDogZmxpZ2h0RGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFbmFibGUgbXBhTmF2aWdhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hSZWY6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1B1c2g6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1wYU5hdmlnYXRpb246IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGFwcGx5IHNjcm9sbCBhbmQgZm9jdXMgbWFuYWdlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb2N1c0FuZFNjcm9sbFJlZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBseTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlOiBzdGF0ZS5jYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyZWU6IHN0YXRlLnRyZWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1RyZWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGFibGUucHJldmlvdXNUcmVlID0gc3RhdGUudHJlZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGFibGUucGF0Y2hlZFRyZWUgPSBuZXdUcmVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YWJsZS5tcGFOYXZpZ2F0aW9uID0gaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KHN0YXRlLnRyZWUsIG5ld1RyZWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1RyZWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NFR01FTlQgTUlTTUFUQ0gnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZlZhbCA9IGNhbm9uaWNhbFVybE92ZXJyaWRlID8gY3JlYXRlSHJlZkZyb21VcmwoY2Fub25pY2FsVXJsT3ZlcnJpZGUpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZlZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGFibGUuY2Fub25pY2FsVXJsT3ZlcnJpZGUgPSBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWZWYWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBtdXRhYmxlLm1wYU5hdmlnYXRpb24gPSBpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQoc3RhdGUudHJlZSwgbmV3VHJlZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPLUFQUDogQ3VycmVudGx5IHRoZSBGbGlnaHQgZGF0YSBjYW4gb25seSBoYXZlIG9uZSBpdGVtIGJ1dCBpbiB0aGUgZnV0dXJlIGl0IGNhbiBoYXZlIG11bHRpcGxlIHBhdGhzLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmxpZ2h0RGF0YVBhdGggPSBmbGlnaHREYXRhWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmxpZ2h0U2VnbWVudFBhdGggPSBmbGlnaHREYXRhUGF0aC5zbGljZSgwLCAtMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgb25lIGJlZm9yZSBsYXN0IGl0ZW0gaXMgdGhlIHJvdXRlciBzdGF0ZSB0cmVlIHBhdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbdHJlZVBhdGNoLCBzdWJUcmVlRGF0YSwgaGVhZF0gPSBmbGlnaHREYXRhUGF0aC5zbGljZSgtMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGVzIGNhc2Ugd2hlcmUgcHJlZmV0Y2ggb25seSByZXR1cm5zIHRoZSByb3V0ZXIgdHJlZSBwYXRjaCB3aXRob3V0IHJlbmRlcmVkIGNvbXBvbmVudHMuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3ViVHJlZURhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmxpZ2h0RGF0YVBhdGgubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLnN0YXR1cyA9IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLlJFQURZO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5zdWJUcmVlRGF0YSA9IHN1YlRyZWVEYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5wYXJhbGxlbFJvdXRlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQoY2FjaGUsIHN0YXRlLmNhY2hlLCB0cmVlUGF0Y2gsIGhlYWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLnN0YXR1cyA9IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLlJFQURZO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IHN1YlRyZWVEYXRhIGZvciB0aGUgcm9vdCBub2RlIG9mIHRoZSBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuc3ViVHJlZURhdGEgPSBzdGF0ZS5jYWNoZS5zdWJUcmVlRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgY29weSBvZiB0aGUgZXhpc3RpbmcgY2FjaGUgd2l0aCB0aGUgc3ViVHJlZURhdGEgYXBwbGllZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbENhY2hlV2l0aE5ld1N1YlRyZWVEYXRhKGNhY2hlLCBzdGF0ZS5jYWNoZSwgZmxpZ2h0RGF0YVBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhcmROYXZpZ2F0ZSA9IC8vIFRPRE8tQVBQOiBSZXZpc2l0IGlmIHRoaXMgaXMgY29ycmVjdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaCAhPT0gbG9jYXRpb24uc2VhcmNoIHx8IHNob3VsZEhhcmROYXZpZ2F0ZSgvLyBUT0RPLUFQUDogcmVtb3ZlICcnXG4gICAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uZmxpZ2h0U2VnbWVudFBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sIHN0YXRlLnRyZWUsIG5ld1RyZWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhcmROYXZpZ2F0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLnN0YXR1cyA9IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLlJFQURZO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvcHkgc3ViVHJlZURhdGEgZm9yIHRoZSByb290IG5vZGUgb2YgdGhlIGNhY2hlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLnN1YlRyZWVEYXRhID0gc3RhdGUuY2FjaGUuc3ViVHJlZURhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW52YWxpZGF0ZUNhY2hlQmVsb3dGbGlnaHRTZWdtZW50UGF0aChjYWNoZSwgc3RhdGUuY2FjaGUsIGZsaWdodFNlZ21lbnRQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB0aGUgZXhpc3RpbmcgY2FjaGUgdmFsdWUgaXMgdXNlZCB3aGVuIHRoZSBjYWNoZSB3YXMgbm90IGludmFsaWRhdGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdWJUcmVlRGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGFibGUudXNlRXhpc3RpbmdDYWNoZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYgPSBjYW5vbmljYWxVcmxPdmVycmlkZSA/IGNyZWF0ZUhyZWZGcm9tVXJsKGNhbm9uaWNhbFVybE92ZXJyaWRlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhYmxlLmNhbm9uaWNhbFVybE92ZXJyaWRlID0gY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgaHJlZi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5vbmljYWxVcmw6IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiA/IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiA6IGhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHBlbmRpbmdQdXNoLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hSZWY6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1B1c2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1wYU5hdmlnYXRpb246IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGwgbmF2aWdhdGlvbiByZXF1aXJlcyBzY3JvbGwgYW5kIGZvY3VzIG1hbmFnZW1lbnQgdG8gdHJpZ2dlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb2N1c0FuZFNjcm9sbFJlZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBseTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgcGF0Y2hlZCBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZTogbXV0YWJsZS51c2VFeGlzdGluZ0NhY2hlID8gc3RhdGUuY2FjaGUgOiBjYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IHBhdGNoZWQgdHJlZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmVlOiBuZXdUcmVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdoZW4gZG9pbmcgYSBoYXJkIHB1c2ggdGhlcmUgY2FuIGJlIHR3byBjYXNlczogd2l0aCBvcHRpbWlzdGljIHRyZWUgYW5kIHdpdGhvdXRcbiAgICAgICAgICAgICAgICAvLyBUaGUgd2l0aCBvcHRpbWlzdGljIHRyZWUgY2FzZSBvbmx5IGhhcHBlbnMgd2hlbiB0aGUgbGF5b3V0cyBoYXZlIGEgbG9hZGluZyBzdGF0ZSAobG9hZGluZy5qcylcbiAgICAgICAgICAgICAgICAvLyBUaGUgd2l0aG91dCBvcHRpbWlzdGljIHRyZWUgY2FzZSBoYXBwZW5zIHdoZW4gdGhlcmUgaXMgbm8gbG9hZGluZyBzdGF0ZSwgaW4gdGhhdCBjYXNlIHdlIHN1c3BlbmQgaW4gdGhpcyByZWR1Y2VyXG4gICAgICAgICAgICAgICAgLy8gZm9yY2VPcHRpbWlzdGljTmF2aWdhdGlvbiBpcyB1c2VkIGZvciBsaW5rcyB0aGF0IGhhdmUgYHByZWZldGNoPXtmYWxzZX1gLlxuICAgICAgICAgICAgICAgIGlmIChmb3JjZU9wdGltaXN0aWNOYXZpZ2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlZ21lbnRzID0gcGF0aG5hbWUuc3BsaXQoJy8nKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETy1BUFA6IGZpZ3VyZSBvdXQgc29tZXRoaW5nIGJldHRlciBmb3IgaW5kZXggcGFnZXNcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaCgnJyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXN0aWMgdHJlZSBjYXNlLlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb3B0aW1pc3RpYyB0cmVlIGlzIGRlZXBlciB0aGFuIHRoZSBjdXJyZW50IHN0YXRlIGxlYXZlIHRoYXQgZGVlcGVyIHBhcnQgb3V0IG9mIHRoZSBmZXRjaFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHRpbWlzdGljVHJlZSA9IGNyZWF0ZU9wdGltaXN0aWNUcmVlKHNlZ21lbnRzLCBzdGF0ZS50cmVlLCB0cnVlLCBmYWxzZSwgaHJlZik7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvcHkgc3ViVHJlZURhdGEgZm9yIHRoZSByb290IG5vZGUgb2YgdGhlIGNhY2hlLlxuICAgICAgICAgICAgICAgICAgICBjYWNoZS5zdGF0dXMgPSBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5SRUFEWTtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUuc3ViVHJlZURhdGEgPSBzdGF0ZS5jYWNoZS5zdWJUcmVlRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29weSBleGlzdGluZyBjYWNoZSBub2RlcyBhcyBmYXIgYXMgcG9zc2libGUgYW5kIGZpbGwgaW4gYGRhdGFgIHByb3BlcnR5IHdpdGggdGhlIHN0YXJ0ZWQgZGF0YSBmZXRjaC5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGBkYXRhYCBwcm9wZXJ0eSBpcyB1c2VkIHRvIHN1c3BlbmQgaW4gbGF5b3V0LXJvdXRlciBkdXJpbmcgcmVuZGVyIGlmIGl0IGhhc24ndCByZXNvbHZlZCB5ZXQgYnkgdGhlIHRpbWUgaXQgcmVuZGVycy5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0gZmlsbENhY2hlV2l0aERhdGFQcm9wZXJ0eShjYWNoZSwgc3RhdGUuY2FjaGUsIC8vIFRPRE8tQVBQOiBzZWdtZW50cy5zbGljZSgxKSBzdHJpcHMgJycsIHdlIGNhbiBnZXQgcmlkIG9mICcnIGFsdG9nZXRoZXIuXG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzLnNsaWNlKDEpLCAoKT0+KDAsIF9hcHBSb3V0ZXIpLmZldGNoU2VydmVyUmVzcG9uc2UodXJsLCBvcHRpbWlzdGljVHJlZSkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBvcHRpbWlzdGljIGZldGNoIGNvdWxkbid0IGhhcHBlbiBpdCBmYWxscyBiYWNrIHRvIHRoZSBub24tb3B0aW1pc3RpYyBjYXNlLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShyZXMgPT0gbnVsbCA/IHZvaWQgMCA6IHJlcy5iYWlsT3B0aW1pc3RpYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGFibGUucHJldmlvdXNUcmVlID0gc3RhdGUudHJlZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGFibGUucGF0Y2hlZFRyZWUgPSBvcHRpbWlzdGljVHJlZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGFibGUubXBhTmF2aWdhdGlvbiA9IGlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dChzdGF0ZS50cmVlLCBvcHRpbWlzdGljVHJlZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCBocmVmLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbm9uaWNhbFVybDogaHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgcGVuZGluZ1B1c2guXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVzaFJlZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nUHVzaCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXBhTmF2aWdhdGlvbjogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbCBuYXZpZ2F0aW9uIHJlcXVpcmVzIHNjcm9sbCBhbmQgZm9jdXMgbWFuYWdlbWVudCB0byB0cmlnZ2VyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5OiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBwYXRjaGVkIGNhY2hlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlOiBjYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IG9wdGltaXN0aWMgdHJlZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmVlOiBvcHRpbWlzdGljVHJlZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBCZWxvdyBpcyB0aGUgbm90LW9wdGltaXN0aWMgY2FzZS4gRGF0YSBpcyBmZXRjaGVkIGF0IHRoZSByb290IGFuZCBzdXNwZW5kZWQgdGhlcmUgd2l0aG91dCBhIHN1c3BlbnNlIGJvdW5kYXJ5LlxuICAgICAgICAgICAgICAgIC8vIElmIG5vIGluLWZsaWdodCBmZXRjaCBhdCB0aGUgdG9wLCBzdGFydCBpdC5cbiAgICAgICAgICAgICAgICBpZiAoIWNhY2hlLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUuZGF0YSA9IGNyZWF0ZVJlY29yZEZyb21UaGVuYWJsZSgoMCwgX2FwcFJvdXRlcikuZmV0Y2hTZXJ2ZXJSZXNwb25zZSh1cmwsIHN0YXRlLnRyZWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVW53cmFwIGNhY2hlIGRhdGEgd2l0aCBgdXNlYCB0byBzdXNwZW5kIGhlcmUgKGluIHRoZSByZWR1Y2VyKSB1bnRpbCB0aGUgZmV0Y2ggcmVzb2x2ZXMuXG4gICAgICAgICAgICAgICAgY29uc3QgW2ZsaWdodERhdGEsIGNhbm9uaWNhbFVybE92ZXJyaWRlXSA9IHJlYWRSZWNvcmRWYWx1ZShjYWNoZS5kYXRhKTtcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgY2FzZSB3aGVuIG5hdmlnYXRpbmcgdG8gcGFnZSBpbiBgcGFnZXNgIGZyb20gYGFwcGBcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZsaWdodERhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5vbmljYWxVcmw6IGZsaWdodERhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbmFibGUgbXBhTmF2aWdhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgcHVzaFJlZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdQdXNoOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1wYU5hdmlnYXRpb246IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBhcHBseSBzY3JvbGwgYW5kIGZvY3VzIG1hbmFnZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb2N1c0FuZFNjcm9sbFJlZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlOiBzdGF0ZS5jYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZldGNoQ2FjaGU6IHN0YXRlLnByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmVlOiBzdGF0ZS50cmVlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBjYWNoZS5kYXRhIGFzIGl0IGhhcyBiZWVuIHJlc29sdmVkIGF0IHRoaXMgcG9pbnQuXG4gICAgICAgICAgICAgICAgY2FjaGUuZGF0YSA9IG51bGw7XG4gICAgICAgICAgICAgICAgLy8gVE9ETy1BUFA6IEN1cnJlbnRseSB0aGUgRmxpZ2h0IGRhdGEgY2FuIG9ubHkgaGF2ZSBvbmUgaXRlbSBidXQgaW4gdGhlIGZ1dHVyZSBpdCBjYW4gaGF2ZSBtdWx0aXBsZSBwYXRocy5cbiAgICAgICAgICAgICAgICBjb25zdCBmbGlnaHREYXRhUGF0aCA9IGZsaWdodERhdGFbMF07XG4gICAgICAgICAgICAgICAgLy8gVGhlIG9uZSBiZWZvcmUgbGFzdCBpdGVtIGlzIHRoZSByb3V0ZXIgc3RhdGUgdHJlZSBwYXRjaFxuICAgICAgICAgICAgICAgIGNvbnN0IFt0cmVlUGF0Y2gsIHN1YlRyZWVEYXRhLCBoZWFkXSA9IGZsaWdodERhdGFQYXRoLnNsaWNlKC0zKTtcbiAgICAgICAgICAgICAgICAvLyBQYXRoIHdpdGhvdXQgdGhlIGxhc3Qgc2VnbWVudCwgcm91dGVyIHN0YXRlLCBhbmQgdGhlIHN1YlRyZWVEYXRhXG4gICAgICAgICAgICAgICAgY29uc3QgZmxpZ2h0U2VnbWVudFBhdGggPSBmbGlnaHREYXRhUGF0aC5zbGljZSgwLCAtNCk7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIG5ldyB0cmVlIGJhc2VkIG9uIHRoZSBmbGlnaHRTZWdtZW50UGF0aCBhbmQgcm91dGVyIHN0YXRlIHBhdGNoXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3VHJlZSA9IGFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSgvLyBUT0RPLUFQUDogcmVtb3ZlICcnXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICAgICAgICAgLi4uZmxpZ2h0U2VnbWVudFBhdGhcbiAgICAgICAgICAgICAgICBdLCBzdGF0ZS50cmVlLCB0cmVlUGF0Y2gpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdUcmVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU0VHTUVOVCBNSVNNQVRDSCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYgPSBjYW5vbmljYWxVcmxPdmVycmlkZSA/IGNyZWF0ZUhyZWZGcm9tVXJsKGNhbm9uaWNhbFVybE92ZXJyaWRlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAoY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIG11dGFibGUuY2Fub25pY2FsVXJsT3ZlcnJpZGUgPSBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG11dGFibGUucHJldmlvdXNUcmVlID0gc3RhdGUudHJlZTtcbiAgICAgICAgICAgICAgICBtdXRhYmxlLnBhdGNoZWRUcmVlID0gbmV3VHJlZTtcbiAgICAgICAgICAgICAgICBtdXRhYmxlLm1wYU5hdmlnYXRpb24gPSBpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQoc3RhdGUudHJlZSwgbmV3VHJlZSk7XG4gICAgICAgICAgICAgICAgaWYgKGZsaWdodERhdGFQYXRoLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZS5zdGF0dXMgPSBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5SRUFEWTtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUuc3ViVHJlZURhdGEgPSBzdWJUcmVlRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQoY2FjaGUsIHN0YXRlLmNhY2hlLCB0cmVlUGF0Y2gsIGhlYWQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvcHkgc3ViVHJlZURhdGEgZm9yIHRoZSByb290IG5vZGUgb2YgdGhlIGNhY2hlLlxuICAgICAgICAgICAgICAgICAgICBjYWNoZS5zdGF0dXMgPSBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5SRUFEWTtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUuc3ViVHJlZURhdGEgPSBzdGF0ZS5jYWNoZS5zdWJUcmVlRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgY29weSBvZiB0aGUgZXhpc3RpbmcgY2FjaGUgd2l0aCB0aGUgc3ViVHJlZURhdGEgYXBwbGllZC5cbiAgICAgICAgICAgICAgICAgICAgZmlsbENhY2hlV2l0aE5ld1N1YlRyZWVEYXRhKGNhY2hlLCBzdGF0ZS5jYWNoZSwgZmxpZ2h0RGF0YVBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgaHJlZi5cbiAgICAgICAgICAgICAgICAgICAgY2Fub25pY2FsVXJsOiBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYgPyBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYgOiBocmVmLFxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgcGVuZGluZ1B1c2guXG4gICAgICAgICAgICAgICAgICAgIHB1c2hSZWY6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdQdXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgbXBhTmF2aWdhdGlvbjogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgLy8gQWxsIG5hdmlnYXRpb24gcmVxdWlyZXMgc2Nyb2xsIGFuZCBmb2N1cyBtYW5hZ2VtZW50IHRvIHRyaWdnZXIuXG4gICAgICAgICAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBseTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBwYXRjaGVkIGNhY2hlLlxuICAgICAgICAgICAgICAgICAgICBjYWNoZTogY2FjaGUsXG4gICAgICAgICAgICAgICAgICAgIHByZWZldGNoQ2FjaGU6IHN0YXRlLnByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IHBhdGNoZWQgdHJlZS5cbiAgICAgICAgICAgICAgICAgICAgdHJlZTogbmV3VHJlZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgQUNUSU9OX1NFUlZFUl9QQVRDSDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGZsaWdodERhdGEgLCBwcmV2aW91c1RyZWUgLCBvdmVycmlkZUNhbm9uaWNhbFVybCAsIGNhY2hlICwgbXV0YWJsZSAgfSA9IGFjdGlvbjtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIGEgZmV0Y2ggaXMgc2xvdyB0byByZXNvbHZlIGl0IGNvdWxkIGJlIHRoYXQgeW91IG5hdmlnYXRlZCBhd2F5IHdoaWxlIHRoZSByZXF1ZXN0IHdhcyBoYXBwZW5pbmcgb3IgYmVmb3JlIHRoZSByZWR1Y2VyIHJ1bnMuXG4gICAgICAgICAgICAgICAgLy8gSW4gdGhhdCBjYXNlIG9wdC1vdXQgb2YgYXBwbHlpbmcgdGhlIHBhdGNoIGdpdmVuIHRoYXQgdGhlIGRhdGEgY291bGQgYmUgc3RhbGUuXG4gICAgICAgICAgICAgICAgaWYgKEpTT04uc3RyaW5naWZ5KHByZXZpb3VzVHJlZSkgIT09IEpTT04uc3RyaW5naWZ5KHN0YXRlLnRyZWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8tQVBQOiBIYW5kbGUgdHJlZSBtaXNtYXRjaFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVFJFRSBNSVNNQVRDSCcpO1xuICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIGV2ZXJ5dGhpbmcgYXMtaXMuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG11dGFibGUubXBhTmF2aWdhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGhyZWYuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5vbmljYWxVcmw6IG11dGFibGUuY2Fub25pY2FsVXJsT3ZlcnJpZGUgPyBtdXRhYmxlLmNhbm9uaWNhbFVybE92ZXJyaWRlIDogc3RhdGUuY2Fub25pY2FsVXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETy1BUFA6IHZlcmlmeSBtcGFOYXZpZ2F0aW9uIG5vdCBiZWluZyBzZXQgaXMgY29ycmVjdCBoZXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgcHVzaFJlZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdQdXNoOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1wYU5hdmlnYXRpb246IG11dGFibGUubXBhTmF2aWdhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbCBuYXZpZ2F0aW9uIHJlcXVpcmVzIHNjcm9sbCBhbmQgZm9jdXMgbWFuYWdlbWVudCB0byB0cmlnZ2VyLlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWY6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBseTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlOiBzdGF0ZS5jYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZldGNoQ2FjaGU6IHN0YXRlLnByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBwYXRjaGVkIHJvdXRlciBzdGF0ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWU6IHN0YXRlLnRyZWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGNvbmN1cnJlbnQgcmVuZGVyaW5nIC8gc3RyaWN0IG1vZGUgY2FzZSB3aGVyZSB0aGUgY2FjaGUgYW5kIHRyZWUgd2VyZSBhbHJlYWR5IHBvcHVsYXRlZC5cbiAgICAgICAgICAgICAgICBpZiAobXV0YWJsZS5wYXRjaGVkVHJlZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCBocmVmIGFzIGl0IHdhcyBzZXQgZHVyaW5nIG5hdmlnYXRlIC8gcmVzdG9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgY2Fub25pY2FsVXJsOiBtdXRhYmxlLmNhbm9uaWNhbFVybE92ZXJyaWRlID8gbXV0YWJsZS5jYW5vbmljYWxVcmxPdmVycmlkZSA6IHN0YXRlLmNhbm9uaWNhbFVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEtlZXAgcHVzaFJlZiBhcyBzZXJ2ZXItcGF0Y2ggb25seSBjYXVzZXMgY2FjaGUvdHJlZSB1cGRhdGUuXG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoUmVmOiBzdGF0ZS5wdXNoUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCBmb2N1c0FuZFNjcm9sbFJlZiBhcyBzZXJ2ZXItcGF0Y2ggb25seSBjYXVzZXMgY2FjaGUvdHJlZSB1cGRhdGUuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb2N1c0FuZFNjcm9sbFJlZjogc3RhdGUuZm9jdXNBbmRTY3JvbGxSZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBwYXRjaGVkIHJvdXRlciBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJlZTogbXV0YWJsZS5wYXRjaGVkVHJlZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZldGNoQ2FjaGU6IHN0YXRlLnByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBwYXRjaGVkIGNhY2hlXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZTogY2FjaGVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiBuYXZpZ2F0aW5nIHRvIHBhZ2UgaW4gYHBhZ2VzYCBmcm9tIGBhcHBgXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbGlnaHREYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGhyZWYuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5vbmljYWxVcmw6IGZsaWdodERhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbmFibGUgbXBhTmF2aWdhdGlvbiBhcyB0aGlzIGlzIGEgbmF2aWdhdGlvbiB0aGF0IHRoZSBhcHAtcm91dGVyIHNob3VsZG4ndCBoYW5kbGUuXG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1B1c2g6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXBhTmF2aWdhdGlvbjogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGFwcGx5IHNjcm9sbCBhbmQgZm9jdXMgbWFuYWdlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHk6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXIgc3RhdGUgaXMga2VwdCBhcy1pcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlOiBzdGF0ZS5jYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZldGNoQ2FjaGU6IHN0YXRlLnByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmVlOiBzdGF0ZS50cmVlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRPRE8tQVBQOiBDdXJyZW50bHkgdGhlIEZsaWdodCBkYXRhIGNhbiBvbmx5IGhhdmUgb25lIGl0ZW0gYnV0IGluIHRoZSBmdXR1cmUgaXQgY2FuIGhhdmUgbXVsdGlwbGUgcGF0aHMuXG4gICAgICAgICAgICAgICAgY29uc3QgZmxpZ2h0RGF0YVBhdGggPSBmbGlnaHREYXRhWzBdO1xuICAgICAgICAgICAgICAgIC8vIFNsaWNlcyBvZmYgdGhlIGxhc3Qgc2VnbWVudCAod2hpY2ggaXMgYXQgLTQpIGFzIGl0IGRvZXNuJ3QgZXhpc3QgaW4gdGhlIHRyZWUgeWV0XG4gICAgICAgICAgICAgICAgY29uc3QgZmxpZ2h0U2VnbWVudFBhdGggPSBmbGlnaHREYXRhUGF0aC5zbGljZSgwLCAtNCk7XG4gICAgICAgICAgICAgICAgY29uc3QgW3RyZWVQYXRjaCwgc3ViVHJlZURhdGEsIGhlYWRdID0gZmxpZ2h0RGF0YVBhdGguc2xpY2UoLTMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1RyZWUgPSBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUoLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAgICAgICAgIC4uLmZsaWdodFNlZ21lbnRQYXRoXG4gICAgICAgICAgICAgICAgXSwgc3RhdGUudHJlZSwgdHJlZVBhdGNoKTtcbiAgICAgICAgICAgICAgICBpZiAobmV3VHJlZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NFR01FTlQgTUlTTUFUQ0gnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmID0gb3ZlcnJpZGVDYW5vbmljYWxVcmwgPyBjcmVhdGVIcmVmRnJvbVVybChvdmVycmlkZUNhbm9uaWNhbFVybCkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZikge1xuICAgICAgICAgICAgICAgICAgICBtdXRhYmxlLmNhbm9uaWNhbFVybE92ZXJyaWRlID0gY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtdXRhYmxlLnBhdGNoZWRUcmVlID0gbmV3VHJlZTtcbiAgICAgICAgICAgICAgICBtdXRhYmxlLm1wYU5hdmlnYXRpb24gPSBpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQoc3RhdGUudHJlZSwgbmV3VHJlZSk7XG4gICAgICAgICAgICAgICAgLy8gUm9vdCByZWZyZXNoXG4gICAgICAgICAgICAgICAgaWYgKGZsaWdodERhdGFQYXRoLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZS5zdGF0dXMgPSBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5SRUFEWTtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUuc3ViVHJlZURhdGEgPSBzdWJUcmVlRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQoY2FjaGUsIHN0YXRlLmNhY2hlLCB0cmVlUGF0Y2gsIGhlYWQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvcHkgc3ViVHJlZURhdGEgZm9yIHRoZSByb290IG5vZGUgb2YgdGhlIGNhY2hlLlxuICAgICAgICAgICAgICAgICAgICBjYWNoZS5zdGF0dXMgPSBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5SRUFEWTtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUuc3ViVHJlZURhdGEgPSBzdGF0ZS5jYWNoZS5zdWJUcmVlRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgZmlsbENhY2hlV2l0aE5ld1N1YlRyZWVEYXRhKGNhY2hlLCBzdGF0ZS5jYWNoZSwgZmxpZ2h0RGF0YVBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIGhyZWYgYXMgaXQgd2FzIHNldCBkdXJpbmcgbmF2aWdhdGUgLyByZXN0b3JlXG4gICAgICAgICAgICAgICAgICAgIGNhbm9uaWNhbFVybDogY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmID8gY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmIDogc3RhdGUuY2Fub25pY2FsVXJsLFxuICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIHB1c2hSZWYgYXMgc2VydmVyLXBhdGNoIG9ubHkgY2F1c2VzIGNhY2hlL3RyZWUgdXBkYXRlLlxuICAgICAgICAgICAgICAgICAgICBwdXNoUmVmOiBzdGF0ZS5wdXNoUmVmLFxuICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIGZvY3VzQW5kU2Nyb2xsUmVmIGFzIHNlcnZlci1wYXRjaCBvbmx5IGNhdXNlcyBjYWNoZS90cmVlIHVwZGF0ZS5cbiAgICAgICAgICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWY6IHN0YXRlLmZvY3VzQW5kU2Nyb2xsUmVmLFxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBwYXRjaGVkIHJvdXRlciBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICB0cmVlOiBuZXdUcmVlLFxuICAgICAgICAgICAgICAgICAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBwYXRjaGVkIGNhY2hlXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlOiBjYWNoZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgQUNUSU9OX1JFU1RPUkU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB1cmwgLCB0cmVlICB9ID0gYWN0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhyZWYgPSBjcmVhdGVIcmVmRnJvbVVybCh1cmwpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBjYW5vbmljYWwgdXJsXG4gICAgICAgICAgICAgICAgICAgIGNhbm9uaWNhbFVybDogaHJlZixcbiAgICAgICAgICAgICAgICAgICAgcHVzaFJlZjogc3RhdGUucHVzaFJlZixcbiAgICAgICAgICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWY6IHN0YXRlLmZvY3VzQW5kU2Nyb2xsUmVmLFxuICAgICAgICAgICAgICAgICAgICBjYWNoZTogc3RhdGUuY2FjaGUsXG4gICAgICAgICAgICAgICAgICAgIHByZWZldGNoQ2FjaGU6IHN0YXRlLnByZWZldGNoQ2FjaGUsXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgcHJvdmlkZWQgdHJlZVxuICAgICAgICAgICAgICAgICAgICB0cmVlOiB0cmVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgLy8gVE9ETy1BUFA6IEFkZCB0ZXN0IGZvciBub3Qgc2Nyb2xsaW5nIHRvIG5lYXJlc3QgbGF5b3V0IHdoZW4gY2FsbGluZyByZWZyZXNoLlxuICAgICAgICAvLyBUT0RPLUFQUDogQWRkIHRlc3QgZm9yIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7cm91dGVyLnB1c2goJy8nKTsgcm91dGVyLnJlZnJlc2goKTt9KSwgdGhhdCBjYXNlIHNob3VsZCBzY3JvbGwuXG4gICAgICAgIGNhc2UgQUNUSU9OX1JFRlJFU0g6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBjYWNoZSAsIG11dGFibGUgIH0gPSBhY3Rpb247XG4gICAgICAgICAgICAgICAgY29uc3QgaHJlZiA9IHN0YXRlLmNhbm9uaWNhbFVybDtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0ZvckN1cnJlbnRUcmVlID0gSlNPTi5zdHJpbmdpZnkobXV0YWJsZS5wcmV2aW91c1RyZWUpID09PSBKU09OLnN0cmluZ2lmeShzdGF0ZS50cmVlKTtcbiAgICAgICAgICAgICAgICBpZiAobXV0YWJsZS5tcGFOYXZpZ2F0aW9uICYmIGlzRm9yQ3VycmVudFRyZWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCBocmVmLlxuICAgICAgICAgICAgICAgICAgICAgICAgY2Fub25pY2FsVXJsOiBtdXRhYmxlLmNhbm9uaWNhbFVybE92ZXJyaWRlID8gbXV0YWJsZS5jYW5vbmljYWxVcmxPdmVycmlkZSA6IHN0YXRlLmNhbm9uaWNhbFVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8tQVBQOiB2ZXJpZnkgbXBhTmF2aWdhdGlvbiBub3QgYmVpbmcgc2V0IGlzIGNvcnJlY3QgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hSZWY6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nUHVzaDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtcGFOYXZpZ2F0aW9uOiBtdXRhYmxlLm1wYU5hdmlnYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGwgbmF2aWdhdGlvbiByZXF1aXJlcyBzY3JvbGwgYW5kIGZvY3VzIG1hbmFnZW1lbnQgdG8gdHJpZ2dlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHk6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgY2FjaGUuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZTogc3RhdGUuY2FjaGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgcGF0Y2hlZCByb3V0ZXIgc3RhdGUuXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmVlOiBzdGF0ZS50cmVlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBjb25jdXJyZW50IHJlbmRlcmluZyAvIHN0cmljdCBtb2RlIGNhc2Ugd2hlcmUgdGhlIGNhY2hlIGFuZCB0cmVlIHdlcmUgYWxyZWFkeSBwb3B1bGF0ZWQuXG4gICAgICAgICAgICAgICAgaWYgKG11dGFibGUucGF0Y2hlZFRyZWUgJiYgaXNGb3JDdXJyZW50VHJlZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGhyZWYuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5vbmljYWxVcmw6IG11dGFibGUuY2Fub25pY2FsVXJsT3ZlcnJpZGUgPyBtdXRhYmxlLmNhbm9uaWNhbFVybE92ZXJyaWRlIDogaHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldCBwZW5kaW5nUHVzaCAoYWx3YXlzIGZhbHNlIGluIHRoaXMgY2FzZSkuXG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoUmVmOiBzdGF0ZS5wdXNoUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgZm9jdXMgYW5kIHNjcm9sbC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8tQVBQOiBtaWdodCBuZWVkIHRvIGRpc2FibGUgdGhpcyBmb3IgRmFzdCBSZWZyZXNoLlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWY6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBseTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZTogY2FjaGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJlZTogbXV0YWJsZS5wYXRjaGVkVHJlZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWNhY2hlLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmV0Y2ggZGF0YSBmcm9tIHRoZSByb290IG9mIHRoZSB0cmVlLlxuICAgICAgICAgICAgICAgICAgICBjYWNoZS5kYXRhID0gY3JlYXRlUmVjb3JkRnJvbVRoZW5hYmxlKCgwLCBfYXBwUm91dGVyKS5mZXRjaFNlcnZlclJlc3BvbnNlKG5ldyBVUkwoaHJlZiwgbG9jYXRpb24ub3JpZ2luKSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUudHJlZVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnRyZWVbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS50cmVlWzJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JlZmV0Y2gnLCBcbiAgICAgICAgICAgICAgICAgICAgXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBbZmxpZ2h0RGF0YSwgY2Fub25pY2FsVXJsT3ZlcnJpZGVdID0gcmVhZFJlY29yZFZhbHVlKGNhY2hlLmRhdGEpO1xuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gbmF2aWdhdGluZyB0byBwYWdlIGluIGBwYWdlc2AgZnJvbSBgYXBwYFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbm9uaWNhbFVybDogZmxpZ2h0RGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hSZWY6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nUHVzaDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtcGFOYXZpZ2F0aW9uOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWY6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBseTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZTogc3RhdGUuY2FjaGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJlZTogc3RhdGUudHJlZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgY2FjaGUuZGF0YSBhcyBpdCBoYXMgYmVlbiByZXNvbHZlZCBhdCB0aGlzIHBvaW50LlxuICAgICAgICAgICAgICAgIGNhY2hlLmRhdGEgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vIFRPRE8tQVBQOiBDdXJyZW50bHkgdGhlIEZsaWdodCBkYXRhIGNhbiBvbmx5IGhhdmUgb25lIGl0ZW0gYnV0IGluIHRoZSBmdXR1cmUgaXQgY2FuIGhhdmUgbXVsdGlwbGUgcGF0aHMuXG4gICAgICAgICAgICAgICAgY29uc3QgZmxpZ2h0RGF0YVBhdGggPSBmbGlnaHREYXRhWzBdO1xuICAgICAgICAgICAgICAgIC8vIEZsaWdodERhdGFQYXRoIHdpdGggbW9yZSB0aGFuIHR3byBpdGVtcyBtZWFucyB1bmV4cGVjdGVkIEZsaWdodCBkYXRhIHdhcyByZXR1cm5lZFxuICAgICAgICAgICAgICAgIGlmIChmbGlnaHREYXRhUGF0aC5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETy1BUFA6IGhhbmRsZSB0aGlzIGNhc2UgYmV0dGVyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSRUZSRVNIIEZBSUxFRCcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEdpdmVuIHRoZSBwYXRoIGNhbiBvbmx5IGhhdmUgdHdvIGl0ZW1zIHRoZSBpdGVtcyBhcmUgb25seSB0aGUgcm91dGVyIHN0YXRlIGFuZCBzdWJUcmVlRGF0YSBmb3IgdGhlIHJvb3QuXG4gICAgICAgICAgICAgICAgY29uc3QgW3RyZWVQYXRjaCwgc3ViVHJlZURhdGEsIGhlYWRdID0gZmxpZ2h0RGF0YVBhdGg7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3VHJlZSA9IGFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSgvLyBUT0RPLUFQUDogcmVtb3ZlICcnXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAnJ1xuICAgICAgICAgICAgICAgIF0sIHN0YXRlLnRyZWUsIHRyZWVQYXRjaCk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1RyZWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTRUdNRU5UIE1JU01BVENIJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiA9IGNhbm9uaWNhbFVybE92ZXJyaWRlID8gY3JlYXRlSHJlZkZyb21VcmwoY2Fub25pY2FsVXJsT3ZlcnJpZGUpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmIChjYW5vbmljYWxVcmxPdmVycmlkZSkge1xuICAgICAgICAgICAgICAgICAgICBtdXRhYmxlLmNhbm9uaWNhbFVybE92ZXJyaWRlID0gY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtdXRhYmxlLnByZXZpb3VzVHJlZSA9IHN0YXRlLnRyZWU7XG4gICAgICAgICAgICAgICAgbXV0YWJsZS5wYXRjaGVkVHJlZSA9IG5ld1RyZWU7XG4gICAgICAgICAgICAgICAgbXV0YWJsZS5tcGFOYXZpZ2F0aW9uID0gaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KHN0YXRlLnRyZWUsIG5ld1RyZWUpO1xuICAgICAgICAgICAgICAgIC8vIFNldCBzdWJUcmVlRGF0YSBmb3IgdGhlIHJvb3Qgbm9kZSBvZiB0aGUgY2FjaGUuXG4gICAgICAgICAgICAgICAgY2FjaGUuc3RhdHVzID0gX2FwcFJvdXRlckNvbnRleHQuQ2FjaGVTdGF0ZXMuUkVBRFk7XG4gICAgICAgICAgICAgICAgY2FjaGUuc3ViVHJlZURhdGEgPSBzdWJUcmVlRGF0YTtcbiAgICAgICAgICAgICAgICBmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZChjYWNoZSwgc3RhdGUuY2FjaGUsIHRyZWVQYXRjaCwgaGVhZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGhyZWYsIHRoaXMgZG9lc24ndCByZXVzZSB0aGUgc3RhdGUuY2Fub25pY2FsVXJsIGFzIGJlY2F1c2Ugb2YgY29uY3VycmVudCByZW5kZXJpbmcgdGhlIGhyZWYgbWlnaHQgY2hhbmdlIGJldHdlZW4gZGlzcGF0Y2hpbmcgYW5kIGFwcGx5aW5nLlxuICAgICAgICAgICAgICAgICAgICBjYW5vbmljYWxVcmw6IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiA/IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiA6IGhyZWYsXG4gICAgICAgICAgICAgICAgICAgIC8vIHNldCBwZW5kaW5nUHVzaCAoYWx3YXlzIGZhbHNlIGluIHRoaXMgY2FzZSkuXG4gICAgICAgICAgICAgICAgICAgIHB1c2hSZWY6IHN0YXRlLnB1c2hSZWYsXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8tQVBQOiBtaWdodCBuZWVkIHRvIGRpc2FibGUgdGhpcyBmb3IgRmFzdCBSZWZyZXNoLlxuICAgICAgICAgICAgICAgICAgICBmb2N1c0FuZFNjcm9sbFJlZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHk6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IHBhdGNoZWQgY2FjaGUuXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlOiBjYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgcHJlZmV0Y2hDYWNoZTogc3RhdGUucHJlZmV0Y2hDYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgcGF0Y2hlZCByb3V0ZXIgc3RhdGUuXG4gICAgICAgICAgICAgICAgICAgIHRyZWU6IG5ld1RyZWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIEFDVElPTl9QUkVGRVRDSDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHVybCAsIHNlcnZlclJlc3BvbnNlICB9ID0gYWN0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IFtmbGlnaHREYXRhLCBjYW5vbmljYWxVcmxPdmVycmlkZV0gPSBzZXJ2ZXJSZXNwb25zZTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZsaWdodERhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaHJlZiA9IGNyZWF0ZUhyZWZGcm9tVXJsKHVybCk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETy1BUFA6IEN1cnJlbnRseSB0aGUgRmxpZ2h0IGRhdGEgY2FuIG9ubHkgaGF2ZSBvbmUgaXRlbSBidXQgaW4gdGhlIGZ1dHVyZSBpdCBjYW4gaGF2ZSBtdWx0aXBsZSBwYXRocy5cbiAgICAgICAgICAgICAgICBjb25zdCBmbGlnaHREYXRhUGF0aCA9IGZsaWdodERhdGFbMF07XG4gICAgICAgICAgICAgICAgLy8gVGhlIG9uZSBiZWZvcmUgbGFzdCBpdGVtIGlzIHRoZSByb3V0ZXIgc3RhdGUgdHJlZSBwYXRjaFxuICAgICAgICAgICAgICAgIGNvbnN0IFt0cmVlUGF0Y2hdID0gZmxpZ2h0RGF0YVBhdGguc2xpY2UoLTMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZsaWdodFNlZ21lbnRQYXRoID0gZmxpZ2h0RGF0YVBhdGguc2xpY2UoMCwgLTMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1RyZWUgPSBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUoLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAgICAgICAgIC4uLmZsaWdodFNlZ21lbnRQYXRoXG4gICAgICAgICAgICAgICAgXSwgc3RhdGUudHJlZSwgdHJlZVBhdGNoKTtcbiAgICAgICAgICAgICAgICAvLyBQYXRjaCBkaWQgbm90IGFwcGx5IGNvcnJlY3RseVxuICAgICAgICAgICAgICAgIGlmIChuZXdUcmVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIG5ldyB0cmVlIGJhc2VkIG9uIHRoZSBmbGlnaHRTZWdtZW50UGF0aCBhbmQgcm91dGVyIHN0YXRlIHBhdGNoXG4gICAgICAgICAgICAgICAgc3RhdGUucHJlZmV0Y2hDYWNoZS5zZXQoaHJlZiwge1xuICAgICAgICAgICAgICAgICAgICBmbGlnaHREYXRhLFxuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgbmV3IHRyZWUgYmFzZWQgb24gdGhlIGZsaWdodFNlZ21lbnRQYXRoIGFuZCByb3V0ZXIgc3RhdGUgcGF0Y2hcbiAgICAgICAgICAgICAgICAgICAgdHJlZTogbmV3VHJlZSxcbiAgICAgICAgICAgICAgICAgICAgY2Fub25pY2FsVXJsT3ZlcnJpZGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgY2FzZSBzaG91bGQgbmV2ZXIgYmUgaGl0IGFzIGRpc3BhdGNoIGlzIHN0cm9uZ2x5IHR5cGVkLlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGFjdGlvbicpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNlcnZlclJlZHVjZXIoc3RhdGUsIF9hY3Rpb24pIHtcbiAgICByZXR1cm4gc3RhdGU7XG59XG5jb25zdCByZWR1Y2VyID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBzZXJ2ZXJSZWR1Y2VyIDogY2xpZW50UmVkdWNlcjtcbmV4cG9ydHMucmVkdWNlciA9IHJlZHVjZXI7XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZHVjZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiY3JlYXRlSHJlZkZyb21VcmwiLCJyZWR1Y2VyIiwiQUNUSU9OX1BSRUZFVENIIiwiQUNUSU9OX1NFUlZFUl9QQVRDSCIsIkFDVElPTl9SRVNUT1JFIiwiQUNUSU9OX05BVklHQVRFIiwiQUNUSU9OX1JFRlJFU0giLCJfZXh0ZW5kcyIsInJlcXVpcmUiLCJkZWZhdWx0IiwiX2FwcFJvdXRlckNvbnRleHQiLCJfbWF0Y2hTZWdtZW50cyIsIl9hcHBSb3V0ZXIiLCJjcmVhdGVSZWNvcmRGcm9tVGhlbmFibGUiLCJ0aGVuYWJsZSIsInN0YXR1cyIsInRoZW4iLCJlcnIiLCJyZWFkUmVjb3JkVmFsdWUiLCJ1cmwiLCJwYXRobmFtZSIsInNlYXJjaCIsImhhc2giLCJpbnZhbGlkYXRlQ2FjaGVCeVJvdXRlclN0YXRlIiwibmV3Q2FjaGUiLCJleGlzdGluZ0NhY2hlIiwicm91dGVyU3RhdGUiLCJrZXkiLCJzZWdtZW50Rm9yUGFyYWxsZWxSb3V0ZSIsImNhY2hlS2V5IiwiQXJyYXkiLCJpc0FycmF5IiwiZXhpc3RpbmdQYXJhbGxlbFJvdXRlc0NhY2hlTm9kZSIsInBhcmFsbGVsUm91dGVzIiwiZ2V0IiwicGFyYWxsZWxSb3V0ZUNhY2hlTm9kZSIsIk1hcCIsImRlbGV0ZSIsInNldCIsImZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkIiwiaGVhZCIsImlzTGFzdFNlZ21lbnQiLCJrZXlzIiwibGVuZ3RoIiwicGFyYWxsZWxSb3V0ZVN0YXRlIiwibmV3Q2FjaGVOb2RlIiwiQ2FjaGVTdGF0ZXMiLCJMQVpZX0lOSVRJQUxJWkVEIiwiZGF0YSIsInN1YlRyZWVEYXRhIiwidW5kZWZpbmVkIiwiZmlsbENhY2hlV2l0aE5ld1N1YlRyZWVEYXRhIiwiZmxpZ2h0RGF0YVBhdGgiLCJpc0xhc3RFbnRyeSIsInBhcmFsbGVsUm91dGVLZXkiLCJzZWdtZW50Iiwic2VnbWVudEZvckNhY2hlIiwiZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXAiLCJjaGlsZFNlZ21lbnRNYXAiLCJleGlzdGluZ0NoaWxkQ2FjaGVOb2RlIiwiY2hpbGRDYWNoZU5vZGUiLCJSRUFEWSIsInNsaWNlIiwiaW52YWxpZGF0ZUNhY2hlQmVsb3dGbGlnaHRTZWdtZW50UGF0aCIsImZsaWdodFNlZ21lbnRQYXRoIiwiZmlsbENhY2hlV2l0aERhdGFQcm9wZXJ0eSIsInNlZ21lbnRzIiwiZmV0Y2hSZXNwb25zZSIsImJhaWxPcHRpbWlzdGljIiwiREFUQV9GRVRDSCIsImNyZWF0ZU9wdGltaXN0aWNUcmVlIiwiZmxpZ2h0Um91dGVyU3RhdGUiLCJfaXNGaXJzdFNlZ21lbnQiLCJwYXJlbnRSZWZldGNoIiwiX2hyZWYiLCJleGlzdGluZ1NlZ21lbnQiLCJleGlzdGluZ1BhcmFsbGVsUm91dGVzIiwic2VnbWVudE1hdGNoZXMiLCJtYXRjaFNlZ21lbnQiLCJzaG91bGRSZWZldGNoVGhpc0xldmVsIiwiY2hpbGRUcmVlIiwiY2hpbGRJdGVtIiwiY2hpbGRyZW4iLCJyZXN1bHQiLCJhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUiLCJ0cmVlUGF0Y2giLCJpc1Jvb3RMYXlvdXQiLCJ0cmVlIiwiY3VycmVudFNlZ21lbnQiLCJsYXN0U2VnbWVudCIsInBhcmFsbGVsUm91dGVQYXRjaCIsInNob3VsZEhhcmROYXZpZ2F0ZSIsImlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCIsImN1cnJlbnRUcmVlIiwibmV4dFRyZWUiLCJjdXJyZW50VHJlZVNlZ21lbnQiLCJuZXh0VHJlZVNlZ21lbnQiLCJjdXJyZW50VHJlZUNoaWxkIiwidmFsdWVzIiwibmV4dFRyZWVDaGlsZCIsImNsaWVudFJlZHVjZXIiLCJzdGF0ZSIsImFjdGlvbiIsInR5cGUiLCJuYXZpZ2F0ZVR5cGUiLCJjYWNoZSIsIm11dGFibGUiLCJmb3JjZU9wdGltaXN0aWNOYXZpZ2F0aW9uIiwiaHJlZiIsInBlbmRpbmdQdXNoIiwiaXNGb3JDdXJyZW50VHJlZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJwcmV2aW91c1RyZWUiLCJtcGFOYXZpZ2F0aW9uIiwiY2Fub25pY2FsVXJsIiwiY2Fub25pY2FsVXJsT3ZlcnJpZGUiLCJwdXNoUmVmIiwiZm9jdXNBbmRTY3JvbGxSZWYiLCJhcHBseSIsInByZWZldGNoQ2FjaGUiLCJwYXRjaGVkVHJlZSIsInVzZUV4aXN0aW5nQ2FjaGUiLCJwcmVmZXRjaFZhbHVlcyIsImZsaWdodERhdGEiLCJuZXdUcmVlIiwiRXJyb3IiLCJjYW5vbmljYWxVcmxPdmVycmlkZUhyZWZWYWwiLCJoYXJkTmF2aWdhdGUiLCJsb2NhdGlvbiIsImNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiIsInNwbGl0IiwicHVzaCIsIm9wdGltaXN0aWNUcmVlIiwicmVzIiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsIm92ZXJyaWRlQ2Fub25pY2FsVXJsIiwiY29uc29sZSIsImxvZyIsIlVSTCIsIm9yaWdpbiIsInNlcnZlclJlc3BvbnNlIiwic2VydmVyUmVkdWNlciIsIl9hY3Rpb24iLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/reducer.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/render-from-template-context.js":
/*!***********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/render-from-template-context.js ***!
  \***********************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = RenderFromTemplateContext;\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"(app-client)/./node_modules/.pnpm/@swc+helpers@0.4.14/node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar _react = _interop_require_wildcard(__webpack_require__(/*! react */ \"(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/compiled/react/index.js\"));\nvar _appRouterContext = __webpack_require__(/*! ../../shared/lib/app-router-context */ \"(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/shared/lib/app-router-context.js\");\nfunction RenderFromTemplateContext() {\n    _s();\n    const children = (0, _react).useContext(_appRouterContext.TemplateContext);\n    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, children);\n}\n_s(RenderFromTemplateContext, \"Fd1ieM0FAzMq7OA5+LlfYPV5S7Y=\");\n_c = RenderFromTemplateContext;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=render-from-template-context.js.map\nvar _c;\n$RefreshReg$(_c, \"RenderFromTemplateContext\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTMuMS41X3JlYWN0LWRvbUAxOC4yLjArcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVuZGVyLWZyb20tdGVtcGxhdGUtY29udGV4dC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFDYTs7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsa0JBQWUsR0FBR0c7QUFDbEIsSUFBSUMsNEJBQTRCQyx5TUFBZ0U7QUFDaEcsSUFBSUMsU0FBU0YsMEJBQTBCQyxtQkFBT0EsQ0FBQyx5SUFBTztBQUN0RCxJQUFJRSxvQkFBb0JGLG1CQUFPQSxDQUFDLGdMQUFxQztBQUNyRSxTQUFTRiw0QkFBNEI7O0lBQ2pDLE1BQU1LLFdBQVcsQ0FBQyxHQUFHRixNQUFNLEVBQUVHLFVBQVUsQ0FBQ0Ysa0JBQWtCRyxlQUFlO0lBQ3pFLE9BQU8sV0FBVyxHQUFHSixPQUFPSixPQUFPLENBQUNTLGFBQWEsQ0FBQ0wsT0FBT0osT0FBTyxDQUFDVSxRQUFRLEVBQUUsSUFBSSxFQUFFSjtBQUNyRjtHQUhTTDtLQUFBQTtBQU1ULElBQUksQ0FBQyxPQUFPSCxRQUFRRSxPQUFPLEtBQUssY0FBZSxPQUFPRixRQUFRRSxPQUFPLEtBQUssWUFBWUYsUUFBUUUsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPRixRQUFRRSxPQUFPLENBQUNXLFVBQVUsS0FBSyxhQUFhO0lBQ3JLZixPQUFPQyxjQUFjLENBQUNDLFFBQVFFLE9BQU8sRUFBRSxjQUFjO1FBQUVELE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPZ0IsTUFBTSxDQUFDZCxRQUFRRSxPQUFPLEVBQUVGO0lBQy9CZSxPQUFPZixPQUFPLEdBQUdBLFFBQVFFLE9BQU87QUFDbEMsQ0FBQyxDQUVELHdEQUF3RCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxMy4xLjVfcmVhY3QtZG9tQDE4LjIuMCtyZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZW5kZXItZnJvbS10ZW1wbGF0ZS1jb250ZXh0LmpzP2ZiMWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFJlbmRlckZyb21UZW1wbGF0ZUNvbnRleHQ7XG52YXIgX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQuanNcIikuZGVmYXVsdDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX2FwcFJvdXRlckNvbnRleHQgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHRcIik7XG5mdW5jdGlvbiBSZW5kZXJGcm9tVGVtcGxhdGVDb250ZXh0KCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gKDAsIF9yZWFjdCkudXNlQ29udGV4dChfYXBwUm91dGVyQ29udGV4dC5UZW1wbGF0ZUNvbnRleHQpO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuKTtcbn1cblxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW5kZXItZnJvbS10ZW1wbGF0ZS1jb250ZXh0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlZmF1bHQiLCJSZW5kZXJGcm9tVGVtcGxhdGVDb250ZXh0IiwiX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCIsInJlcXVpcmUiLCJfcmVhY3QiLCJfYXBwUm91dGVyQ29udGV4dCIsImNoaWxkcmVuIiwidXNlQ29udGV4dCIsIlRlbXBsYXRlQ29udGV4dCIsImNyZWF0ZUVsZW1lbnQiLCJGcmFnbWVudCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/render-from-template-context.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/use-reducer-with-devtools.js":
/*!********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/use-reducer-with-devtools.js ***!
  \********************************************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.useReducerWithReduxDevtools = void 0;\nvar _react = __webpack_require__(/*! react */ \"(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/compiled/react/index.js\");\nfunction normalizeRouterState(val) {\n    if (val instanceof Map) {\n        const obj = {};\n        for (const [key, value] of val.entries()){\n            if (typeof value === \"function\") {\n                obj[key] = \"fn()\";\n                continue;\n            }\n            if (typeof value === \"object\" && value !== null) {\n                if (value.$$typeof) {\n                    obj[key] = value.$$typeof.toString();\n                    continue;\n                }\n                if (value._bundlerConfig) {\n                    obj[key] = \"FlightData\";\n                    continue;\n                }\n            }\n            obj[key] = normalizeRouterState(value);\n        }\n        return obj;\n    }\n    if (typeof val === \"object\" && val !== null) {\n        const obj = {};\n        for(const key in val){\n            const value = val[key];\n            if (typeof value === \"function\") {\n                obj[key] = \"fn()\";\n                continue;\n            }\n            if (typeof value === \"object\" && value !== null) {\n                if (value.$$typeof) {\n                    obj[key] = value.$$typeof.toString();\n                    continue;\n                }\n                if (value.hasOwnProperty(\"_bundlerConfig\")) {\n                    obj[key] = \"FlightData\";\n                    continue;\n                }\n            }\n            obj[key] = normalizeRouterState(value);\n        }\n        return obj;\n    }\n    if (Array.isArray(val)) {\n        return val.map(normalizeRouterState);\n    }\n    return val;\n}\nfunction devToolReducer(fn, ref) {\n    return (state, action)=>{\n        const res = fn(state, action);\n        if (ref.current) {\n            ref.current.send(action, normalizeRouterState(res));\n        }\n        return res;\n    };\n}\nfunction useReducerWithReduxDevtoolsNoop(fn, initialState) {\n    _s();\n    const [state, dispatch] = (0, _react).useReducer(fn, initialState);\n    return [\n        state,\n        dispatch,\n        ()=>{}\n    ];\n}\n_s(useReducerWithReduxDevtoolsNoop, \"6JWkGZ32UPfojeNx+xqn8ZU8A0Q=\");\nfunction useReducerWithReduxDevtoolsImpl(fn, initialState) {\n    _s1();\n    const devtoolsConnectionRef = (0, _react).useRef();\n    const enabledRef = (0, _react).useRef();\n    (0, _react).useEffect(()=>{\n        if (devtoolsConnectionRef.current || enabledRef.current === false) {\n            return;\n        }\n        if (enabledRef.current === undefined && typeof window.__REDUX_DEVTOOLS_EXTENSION__ === \"undefined\") {\n            enabledRef.current = false;\n            return;\n        }\n        devtoolsConnectionRef.current = window.__REDUX_DEVTOOLS_EXTENSION__.connect({\n            instanceId: 1,\n            name: \"next-router\"\n        });\n        if (devtoolsConnectionRef.current) {\n            devtoolsConnectionRef.current.init(normalizeRouterState(initialState));\n        }\n        return ()=>{\n            devtoolsConnectionRef.current = undefined;\n        };\n    }, [\n        initialState\n    ]);\n    const [state, dispatch] = (0, _react).useReducer(devToolReducer(/* logReducer( */ fn /*)*/ , devtoolsConnectionRef), initialState);\n    const sync = (0, _react).useCallback(()=>{\n        if (devtoolsConnectionRef.current) {\n            devtoolsConnectionRef.current.send({\n                type: \"RENDER_SYNC\"\n            }, normalizeRouterState(state));\n        }\n    }, [\n        state\n    ]);\n    return [\n        state,\n        dispatch,\n        sync\n    ];\n}\n_s1(useReducerWithReduxDevtoolsImpl, \"pLR6zS9fUqATAvEc1j249W8BDm8=\");\nconst useReducerWithReduxDevtools =  true ? useReducerWithReduxDevtoolsImpl : 0;\nexports.useReducerWithReduxDevtools = useReducerWithReduxDevtools;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-reducer-with-devtools.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTMuMS41X3JlYWN0LWRvbUAxOC4yLjArcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvdXNlLXJlZHVjZXItd2l0aC1kZXZ0b29scy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsbUNBQW1DLEdBQUcsS0FBSztBQUMzQyxJQUFJRyxTQUFTQyxtQkFBT0EsQ0FBQyx5SUFBTztBQUM1QixTQUFTQyxxQkFBcUJDLEdBQUcsRUFBRTtJQUMvQixJQUFJQSxlQUFlQyxLQUFLO1FBQ3BCLE1BQU1DLE1BQU0sQ0FBQztRQUNiLEtBQUssTUFBTSxDQUFDQyxLQUFLUixNQUFNLElBQUlLLElBQUlJLE9BQU8sR0FBRztZQUNyQyxJQUFJLE9BQU9ULFVBQVUsWUFBWTtnQkFDN0JPLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHO2dCQUNYLFFBQVM7WUFDYixDQUFDO1lBQ0QsSUFBSSxPQUFPUixVQUFVLFlBQVlBLFVBQVUsSUFBSSxFQUFFO2dCQUM3QyxJQUFJQSxNQUFNVSxRQUFRLEVBQUU7b0JBQ2hCSCxHQUFHLENBQUNDLElBQUksR0FBR1IsTUFBTVUsUUFBUSxDQUFDQyxRQUFRO29CQUNsQyxRQUFTO2dCQUNiLENBQUM7Z0JBQ0QsSUFBSVgsTUFBTVksY0FBYyxFQUFFO29CQUN0QkwsR0FBRyxDQUFDQyxJQUFJLEdBQUc7b0JBQ1gsUUFBUztnQkFDYixDQUFDO1lBQ0wsQ0FBQztZQUNERCxHQUFHLENBQUNDLElBQUksR0FBR0oscUJBQXFCSjtRQUNwQztRQUNBLE9BQU9PO0lBQ1gsQ0FBQztJQUNELElBQUksT0FBT0YsUUFBUSxZQUFZQSxRQUFRLElBQUksRUFBRTtRQUN6QyxNQUFNRSxNQUFNLENBQUM7UUFDYixJQUFJLE1BQU1DLE9BQU9ILElBQUk7WUFDakIsTUFBTUws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QUF3Q1QsTUFBTTVCLDhCQUE4QixLQUFrQixHQUFjNEIsa0NBQWtDSixDQUErQjtBQUNySTFCLG1DQUFtQyxHQUFHRTtBQUV0QyxJQUFJLENBQUMsT0FBT0YsUUFBUTZDLE9BQU8sS0FBSyxjQUFlLE9BQU83QyxRQUFRNkMsT0FBTyxLQUFLLFlBQVk3QyxRQUFRNkMsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPN0MsUUFBUTZDLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktoRCxPQUFPQyxjQUFjLENBQUNDLFFBQVE2QyxPQUFPLEVBQUUsY0FBYztRQUFFNUMsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9pRCxNQUFNLENBQUMvQyxRQUFRNkMsT0FBTyxFQUFFN0M7SUFDL0JnRCxPQUFPaEQsT0FBTyxHQUFHQSxRQUFRNkMsT0FBTztBQUNsQyxDQUFDLENBRUQscURBQXFEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDEzLjEuNV9yZWFjdC1kb21AMTguMi4wK3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3VzZS1yZWR1Y2VyLXdpdGgtZGV2dG9vbHMuanM/ZGQzMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMudXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzID0gdm9pZCAwO1xudmFyIF9yZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZVJvdXRlclN0YXRlKHZhbCkge1xuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHZhbC5lbnRyaWVzKCkpe1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIG9ialtrZXldID0gJ2ZuKCknO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqW2tleV0gPSB2YWx1ZS4kJHR5cGVvZi50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLl9idW5kbGVyQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gJ0ZsaWdodERhdGEnO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvYmpba2V5XSA9IG5vcm1hbGl6ZVJvdXRlclN0YXRlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBmb3IoY29uc3Qga2V5IGluIHZhbCl7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbFtrZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIG9ialtrZXldID0gJ2ZuKCknO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqW2tleV0gPSB2YWx1ZS4kJHR5cGVvZi50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmhhc093blByb3BlcnR5KCdfYnVuZGxlckNvbmZpZycpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gJ0ZsaWdodERhdGEnO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvYmpba2V5XSA9IG5vcm1hbGl6ZVJvdXRlclN0YXRlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIHJldHVybiB2YWwubWFwKG5vcm1hbGl6ZVJvdXRlclN0YXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbn1cbmZ1bmN0aW9uIGRldlRvb2xSZWR1Y2VyKGZuLCByZWYpIHtcbiAgICByZXR1cm4gKHN0YXRlLCBhY3Rpb24pPT57XG4gICAgICAgIGNvbnN0IHJlcyA9IGZuKHN0YXRlLCBhY3Rpb24pO1xuICAgICAgICBpZiAocmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJlZi5jdXJyZW50LnNlbmQoYWN0aW9uLCBub3JtYWxpemVSb3V0ZXJTdGF0ZShyZXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG59XG5mdW5jdGlvbiB1c2VSZWR1Y2VyV2l0aFJlZHV4RGV2dG9vbHNOb29wKGZuLCBpbml0aWFsU3RhdGUpIHtcbiAgICBjb25zdCBbc3RhdGUsIGRpc3BhdGNoXSA9ICgwLCBfcmVhY3QpLnVzZVJlZHVjZXIoZm4sIGluaXRpYWxTdGF0ZSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGRpc3BhdGNoLFxuICAgICAgICAoKT0+e31cbiAgICBdO1xufVxuZnVuY3Rpb24gdXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzSW1wbChmbiwgaW5pdGlhbFN0YXRlKSB7XG4gICAgY29uc3QgZGV2dG9vbHNDb25uZWN0aW9uUmVmID0gKDAsIF9yZWFjdCkudXNlUmVmKCk7XG4gICAgY29uc3QgZW5hYmxlZFJlZiA9ICgwLCBfcmVhY3QpLnVzZVJlZigpO1xuICAgICgwLCBfcmVhY3QpLnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICBpZiAoZGV2dG9vbHNDb25uZWN0aW9uUmVmLmN1cnJlbnQgfHwgZW5hYmxlZFJlZi5jdXJyZW50ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmFibGVkUmVmLmN1cnJlbnQgPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBlbmFibGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkZXZ0b29sc0Nvbm5lY3Rpb25SZWYuY3VycmVudCA9IHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fLmNvbm5lY3Qoe1xuICAgICAgICAgICAgaW5zdGFuY2VJZDogMSxcbiAgICAgICAgICAgIG5hbWU6ICduZXh0LXJvdXRlcidcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkZXZ0b29sc0Nvbm5lY3Rpb25SZWYuY3VycmVudCkge1xuICAgICAgICAgICAgZGV2dG9vbHNDb25uZWN0aW9uUmVmLmN1cnJlbnQuaW5pdChub3JtYWxpemVSb3V0ZXJTdGF0ZShpbml0aWFsU3RhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIGRldnRvb2xzQ29ubmVjdGlvblJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgaW5pdGlhbFN0YXRlXG4gICAgXSk7XG4gICAgY29uc3QgW3N0YXRlLCBkaXNwYXRjaF0gPSAoMCwgX3JlYWN0KS51c2VSZWR1Y2VyKGRldlRvb2xSZWR1Y2VyKC8qIGxvZ1JlZHVjZXIoICovIGZuIC8qKSovICwgZGV2dG9vbHNDb25uZWN0aW9uUmVmKSwgaW5pdGlhbFN0YXRlKTtcbiAgICBjb25zdCBzeW5jID0gKDAsIF9yZWFjdCkudXNlQ2FsbGJhY2soKCk9PntcbiAgICAgICAgaWYgKGRldnRvb2xzQ29ubmVjdGlvblJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBkZXZ0b29sc0Nvbm5lY3Rpb25SZWYuY3VycmVudC5zZW5kKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnUkVOREVSX1NZTkMnXG4gICAgICAgICAgICB9LCBub3JtYWxpemVSb3V0ZXJTdGF0ZShzdGF0ZSkpO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBzdGF0ZVxuICAgIF0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBkaXNwYXRjaCxcbiAgICAgICAgc3luY1xuICAgIF07XG59XG5jb25zdCB1c2VSZWR1Y2VyV2l0aFJlZHV4RGV2dG9vbHMgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHVzZVJlZHVjZXJXaXRoUmVkdXhEZXZ0b29sc0ltcGwgOiB1c2VSZWR1Y2VyV2l0aFJlZHV4RGV2dG9vbHNOb29wO1xuZXhwb3J0cy51c2VSZWR1Y2VyV2l0aFJlZHV4RGV2dG9vbHMgPSB1c2VSZWR1Y2VyV2l0aFJlZHV4RGV2dG9vbHM7XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1yZWR1Y2VyLXdpdGgtZGV2dG9vbHMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzIiwiX3JlYWN0IiwicmVxdWlyZSIsIm5vcm1hbGl6ZVJvdXRlclN0YXRlIiwidmFsIiwiTWFwIiwib2JqIiwia2V5IiwiZW50cmllcyIsIiQkdHlwZW9mIiwidG9TdHJpbmciLCJfYnVuZGxlckNvbmZpZyIsImhhc093blByb3BlcnR5IiwiQXJyYXkiLCJpc0FycmF5IiwibWFwIiwiZGV2VG9vbFJlZHVjZXIiLCJmbiIsInJlZiIsInN0YXRlIiwiYWN0aW9uIiwicmVzIiwiY3VycmVudCIsInNlbmQiLCJ1c2VSZWR1Y2VyV2l0aFJlZHV4RGV2dG9vbHNOb29wIiwiaW5pdGlhbFN0YXRlIiwiZGlzcGF0Y2giLCJ1c2VSZWR1Y2VyIiwidXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzSW1wbCIsImRldnRvb2xzQ29ubmVjdGlvblJlZiIsInVzZVJlZiIsImVuYWJsZWRSZWYiLCJ1c2VFZmZlY3QiLCJ1bmRlZmluZWQiLCJ3aW5kb3ciLCJfX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fIiwiY29ubmVjdCIsImluc3RhbmNlSWQiLCJuYW1lIiwiaW5pdCIsInN5bmMiLCJ1c2VDYWxsYmFjayIsInR5cGUiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/client/components/use-reducer-with-devtools.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-client)/./node_modules/.pnpm/next@13.1.5_react-dom@18.2.0+react@18.2.0/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5Ccciu-2023-ic%5Cnode_modules%5C.pnpm%5Cnext%4013.1.5_react-dom%4018.2.0%2Breact%4018.2.0%5Cnode_modules%5Cnext%5Cdist%5Cclient%5Ccomponents%5Clayout-router.js&modules=C%3A%5Ccciu-2023-ic%5Cnode_modules%5C.pnpm%5Cnext%4013.1.5_react-dom%4018.2.0%2Breact%4018.2.0%5Cnode_modules%5Cnext%5Cdist%5Cclient%5Ccomponents%5Crender-from-template-context.js&modules=C%3A%5Ccciu-2023-ic%5Cnode_modules%5C.pnpm%5Cnext%4013.1.5_react-dom%4018.2.0%2Breact%4018.2.0%5Cnode_modules%5Cnext%5Cdist%5Cclient%5Ccomponents%5Capp-router.js&modules=C%3A%5Ccciu-2023-ic%5Cnode_modules%5C.pnpm%5Cnext%4013.1.5_react-dom%4018.2.0%2Breact%4018.2.0%5Cnode_modules%5Cnext%5Cdist%5Cclient%5Ccomponents%5Cerror-boundary.js&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);